diff -Nuar merlin-bkp/shared/bcmrobo.c merlin-new/shared/bcmrobo.c
--- merlin-bkp/shared/bcmrobo.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/bcmrobo.c	2014-02-24 14:15:11.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * Broadcom 53xx RoboSwitch device driver.
  *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * Copyright (C) 2014, Broadcom Corporation. All Rights Reserved.
  * 
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -15,7 +15,7 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
- * $Id: bcmrobo.c 428037 2013-10-07 14:50:53Z $
+ * $Id: bcmrobo.c 448163 2014-01-13 13:21:00Z $
  */
 
 
@@ -217,6 +217,9 @@
 	bcm_mdelay(1); \
 } while (1)
 
+/* a flag to control Manage Mode enable/disable */
+static bool mang_mode_en = FALSE;
+
 #define RXTX_FLOW_CTRL_MASK	0x3	/* 53125 flow control capability mask */
 #define RXTX_FLOW_CTRL_SHIFT	4	/* 53125 flow contorl capability offset */
 
@@ -2012,6 +2015,12 @@
 	/* Switch Mode register (Page 0, Address 0x0B) */
 	robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
 
+	if (!mang_mode_en) {
+		/* Set unmanaged mode if no any other GMAC enable mang mode */
+		val8 &= (~(1 << 0));
+		robo->ops->write_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
+	}
+
 	/* Bit 1 enables switching/forwarding */
 	if (!(val8 & (1 << 1))) {
 		/* Set unmanaged mode */
@@ -2129,6 +2138,15 @@
 				robo->ops->write_reg(robo, PAGE_VLAN, REG_VLAN_CTRL5,
 					&val8, sizeof(val8));
 
+				/* Switch Mode Register (Page 0, Address 0x0B): Set Managed Mode */
+				val8 = 0;
+				robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MODE,
+					&val8, sizeof(val8));
+				val8 |= (1 << 0);	/* SW_FWDG_MODE Managed Mode */
+				robo->ops->write_reg(robo, PAGE_CTRL, REG_CTRL_MODE,
+					&val8, sizeof(val8));
+				mang_mode_en = TRUE;
+
 				/* Enable ports 5 and 7 for SMP dual core 3 GMAC setup */
 
 				/* Port 5 GMII Port States Override Register
@@ -2184,14 +2202,6 @@
 		/* Disable CFP by default */
 		val8 = 0x0;
 		robo->ops->write_reg(robo, PAGE_CFP, REG_CFP_CTL_REG, &val8, sizeof(val8));
-
-		/* Switch Mode Register (Page 0, Address 0x0B): Managed and SW Fwding */
-		val8 = 0;
-		robo->ops->read_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
-		val8 |=
-			(1 << 1) |		/* SW_FWDG_EN Frame Forwarding is enabled */
-			(1 << 0);		/* SW_FWDG_MODE Managed Mode */
-		robo->ops->write_reg(robo, PAGE_CTRL, REG_CTRL_MODE, &val8, sizeof(val8));
 	}
 
 	/* Disable management interface access */
diff -Nuar merlin-bkp/shared/bcm_rpc_tp_dbus.c merlin-new/shared/bcm_rpc_tp_dbus.c
--- merlin-bkp/shared/bcm_rpc_tp_dbus.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/bcm_rpc_tp_dbus.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1183 +0,0 @@
-/*
- * RPC Transport layer(for host dbus driver)
- * Broadcom 802.11abg Networking Device Driver
- *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
- * 
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * $Id: bcm_rpc_tp_dbus.c 422800 2013-09-10 01:12:42Z $
- */
-
-#if (!defined(WLC_HIGH) && !defined(WLC_LOW))
-#error "SPLIT"
-#endif
-
-#include <typedefs.h>
-#include <bcmdefs.h>
-#include <bcmendian.h>
-#include <osl.h>
-#include <bcmutils.h>
-
-#include <dbus.h>
-#include <bcm_rpc_tp.h>
-#include <bcm_rpc.h>
-#include <rpc_osl.h>
-#ifdef CTFPOOL
-#include <linux_osl.h>
-#endif	/* CTFPOOL */
-
-static uint8 tp_level_host = RPC_TP_MSG_HOST_ERR_VAL;
-#define	RPC_TP_ERR(args)   do {if (tp_level_host & RPC_TP_MSG_HOST_ERR_VAL) printf args;} while (0)
-
-#ifdef BCMDBG
-#define	RPC_TP_DBG(args)   do {if (tp_level_host & RPC_TP_MSG_HOST_DBG_VAL) printf args;} while (0)
-#define	RPC_TP_AGG(args)   do {if (tp_level_host & RPC_TP_MSG_HOST_AGG_VAL) printf args;} while (0)
-#define	RPC_TP_DEAGG(args) do {if (tp_level_host & RPC_TP_MSG_HOST_DEA_VAL) printf args;} while (0)
-#else
-#define RPC_TP_DBG(args)
-#define RPC_TP_AGG(args)
-#define RPC_TP_DEAGG(args)
-#endif
-
-#define RPCNUMBUF	\
-	(BCM_RPC_TP_DBUS_NTXQ_PKT + BCM_RPC_TP_DBUS_NRXQ_CTRL + BCM_RPC_TP_DBUS_NRXQ_PKT * 2)
-#define RPCRX_WM_HI	(RPCNUMBUF - (BCM_RPC_TP_DBUS_NTXQ + BCM_RPC_TP_DBUS_NRXQ))
-#define RPCRX_WM_LO	(RPCNUMBUF - (BCM_RPC_TP_DBUS_NTXQ + BCM_RPC_TP_DBUS_NRXQ))
-
-
-#define RPC_BUS_SEND_WAIT_TIMEOUT_MSEC 500
-#define RPC_BUS_SEND_WAIT_EXT_TIMEOUT_MSEC 750
-
-#define BCM_RPC_TP_HOST_TOTALLEN_ZLP		512
-#define BCM_RPC_TP_HOST_TOTALLEN_ZLP_PAD	8
-
-#ifdef NDIS
-#define RPC_TP_LOCK(ri)		NdisAcquireSpinLock(&(ri)->lock)
-#define RPC_TP_UNLOCK(ri)	NdisReleaseSpinLock(&(ri)->lock)
-#else
-#define RPC_TP_LOCK(ri)		spin_lock_irqsave(&(ri)->lock, (ri)->flags);
-#define RPC_TP_UNLOCK(ri)	spin_unlock_irqrestore(&(ri)->lock, (ri)->flags);
-#endif
-
-/* RPC TRANSPORT API */
-
-static void bcm_rpc_tp_tx_encap(rpc_tp_info_t * rpcb, rpc_buf_t *b);
-static int  bcm_rpc_tp_buf_send_internal(rpc_tp_info_t * rpcb, rpc_buf_t *b);
-static rpc_buf_t *bcm_rpc_tp_pktget(rpc_tp_info_t * rpcb, int len, bool send);
-static void bcm_rpc_tp_pktfree(rpc_tp_info_t * rpcb, rpc_buf_t *b, bool send);
-
-static void bcm_rpc_tp_tx_agg_initstate(rpc_tp_info_t * rpcb);
-static int  bcm_rpc_tp_tx_agg(rpc_tp_info_t *rpcb, rpc_buf_t *b);
-static void bcm_rpc_tp_tx_agg_append(rpc_tp_info_t * rpcb, rpc_buf_t *b);
-static int  bcm_rpc_tp_tx_agg_release(rpc_tp_info_t * rpcb);
-static void bcm_rpc_tp_tx_agg_flush(rpc_tp_info_t * rpcb);
-
-static void bcm_rpc_tp_rx(rpc_tp_info_t *rpcb, void *p);
-
-struct rpc_transport_info {
-	osl_t *osh;
-	rpc_osl_t *rpc_osh;
-	struct dbus_pub *bus;
-
-	rpc_tx_complete_fn_t tx_complete;
-	void* tx_context;
-
-	rpc_rx_fn_t rx_pkt;
-	void* rx_context;
-	void* rx_rtn_pkt;
-
-#if defined(NDIS)
-	shared_info_t *sh;
-	NDIS_SPIN_LOCK	lock;
-#else
-	spinlock_t	lock;
-	ulong flags;
-#endif /* NDIS */
-
-	uint bufalloc;
-	int buf_cnt_inuse;	/* outstanding buf(alloc, not freed) */
-	uint tx_cnt;		/* send successfully */
-	uint txerr_cnt;		/* send failed */
-	uint buf_cnt_max;
-	uint rx_cnt;
-	uint rxdrop_cnt;
-
-	uint bus_mtu;		/* Max size of bus packet */
-	uint bus_txdepth;	/* Max TX that can be posted */
-	uint bus_txpending;	/* How many posted */
-	bool tx_flowctl;	/* tx flow control active */
-	bool tx_flowctl_override;	/* out of band tx flow control */
-	uint tx_flowctl_cnt;	/* tx flow control transition times */
-	bool rxflowctrl;	/* rx flow control active */
-	uint32 rpctp_dbus_hist[BCM_RPC_TP_DBUS_NTXQ];	/* histogram for dbus pending pkt */
-
-	mbool tp_tx_aggregation;	/* aggregate into transport buffers */
-	rpc_buf_t *tp_tx_agg_p;		/* current aggregate chain header */
-	rpc_buf_t *tp_tx_agg_ptail;	/* current aggregate chain tail */
-	uint tp_tx_agg_sframes;		/* current aggregate packet subframes */
-	uint8 tp_tx_agg_sframes_limit;	/* agg sframe limit */
-	uint tp_tx_agg_bytes;		/* current aggregate packet total length */
-	uint16 tp_tx_agg_bytes_max;	/* agg byte max */
-	uint tp_tx_agg_cnt_chain;	/* total aggregated pkt */
-	uint tp_tx_agg_cnt_sf;		/* total aggregated subframes */
-	uint tp_tx_agg_cnt_bytes;	/* total aggregated bytes */
-	uint tp_tx_agg_cnt_noagg;	/* no. pkts not aggregated */
-	uint tp_tx_agg_cnt_pass;	/* no. pkt bypass agg */
-
-	uint tp_host_deagg_cnt_chain;	/* multifrag pkt */
-	uint tp_host_deagg_cnt_sf;	/* total no. of frag inside multifrag */
-	uint tp_host_deagg_cnt_bytes;	/* total deagg bytes */
-	uint tp_host_deagg_cnt_badfmt;	/* bad format */
-	uint tp_host_deagg_cnt_badsflen;	/* bad sf len */
-	uint tp_host_deagg_cnt_pass;	/* passthrough, single frag */
-	int has_2nd_bulk_in_ep;
-};
-
-extern dbus_extdl_t dbus_extdl;
-
-/* TP aggregation: set, init, agg, append, close, flush */
-void
-bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, uint32 reason, bool set)
-{
-	if (set) {
-		RPC_TP_AGG(("%s: agg start 0x%x\n", __FUNCTION__, reason));
-
-		mboolset(rpcb->tp_tx_aggregation, reason);
-
-	} else if (rpcb->tp_tx_aggregation) {
-		RPC_TP_AGG(("%s: agg end 0x%x\n", __FUNCTION__, reason));
-
-		mboolclr(rpcb->tp_tx_aggregation, reason);
-		if (!rpcb->tp_tx_aggregation)
-			bcm_rpc_tp_tx_agg_release(rpcb);
-	}
-}
-
-void
-bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, uint8 sf, uint16 bytes)
-{
-	rpc_th->tp_tx_agg_sframes_limit = sf;
-	rpc_th->tp_tx_agg_bytes_max = bytes;
-}
-
-void
-bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, uint8 *sf, uint16 *bytes)
-{
-	*sf = rpc_th->tp_tx_agg_sframes_limit;
-	*bytes = rpc_th->tp_tx_agg_bytes_max;
-}
-
-static void
-bcm_rpc_tp_tx_agg_initstate(rpc_tp_info_t * rpcb)
-{
-	rpcb->tp_tx_agg_p = NULL;
-	rpcb->tp_tx_agg_ptail = NULL;
-	rpcb->tp_tx_agg_sframes = 0;
-	rpcb->tp_tx_agg_bytes = 0;
-}
-
-static int
-bcm_rpc_tp_tx_agg(rpc_tp_info_t *rpcb, rpc_buf_t *b)
-{
-	uint totlen;
-	uint pktlen;
-	int err = 0;
-
-	ASSERT(rpcb->tp_tx_aggregation);
-
-	pktlen = pkttotlen(rpcb->osh, b);
-	totlen = pktlen + rpcb->tp_tx_agg_bytes;
-
-	if ((totlen > rpcb->tp_tx_agg_bytes_max) ||
-		(rpcb->tp_tx_agg_sframes + 1 > rpcb->tp_tx_agg_sframes_limit)) {
-
-		RPC_TP_AGG(("%s: terminte TP agg for txbyte %d or txframe %d\n", __FUNCTION__,
-			rpcb->tp_tx_agg_bytes_max, rpcb->tp_tx_agg_sframes_limit));
-
-		/* release current agg, continue with new agg */
-		err = bcm_rpc_tp_tx_agg_release(rpcb);
-	}
-
-	bcm_rpc_tp_tx_agg_append(rpcb, b);
-
-	/* if the new frag is also already over the agg limit, release it */
-	if (pktlen >= rpcb->tp_tx_agg_bytes_max) {
-		int new_err;
-		new_err = bcm_rpc_tp_tx_agg_release(rpcb);
-		if (!err)
-			err = new_err;
-	}
-
-	return err;
-}
-
-/*
- * tp_tx_agg_p points to the header lbuf, tp_tx_agg_ptail points to the tail lbuf
- *
- * The TP agg format typically will be below
- *   | TP header(len) | subframe1 rpc_header | subframe1 data |
- *     | TP header(len) | subframe2 rpc_header | subframe2 data |
- *          ...
- *           | TP header(len) | subframeN rpc_header | subframeN data |
- * no padding
-*/
-static void
-bcm_rpc_tp_tx_agg_append(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	uint tp_len;
-
-	tp_len = pkttotlen(rpcb->osh, b);
-
-	if (rpcb->tp_tx_agg_p == NULL) {
-		/* toc, set tail to last fragment */
-		if (PKTNEXT(rpcb->osh, b)) {
-			rpcb->tp_tx_agg_p = b;
-			rpcb->tp_tx_agg_ptail = pktlast(rpcb->osh, b);
-		} else
-			rpcb->tp_tx_agg_p =  rpcb->tp_tx_agg_ptail = b;
-	} else {
-		/* chain the pkts at the end of current one */
-		ASSERT(rpcb->tp_tx_agg_ptail != NULL);
-		PKTSETNEXT(rpcb->osh, rpcb->tp_tx_agg_ptail, b);
-		/* toc, set tail to last fragment */
-		if (PKTNEXT(rpcb->osh, b)) {
-			rpcb->tp_tx_agg_ptail = pktlast(rpcb->osh, b);
-		} else
-			rpcb->tp_tx_agg_ptail = b;
-
-	}
-
-	rpcb->tp_tx_agg_sframes++;
-	rpcb->tp_tx_agg_bytes += tp_len;
-
-	RPC_TP_AGG(("%s: tp_len %d tot %d, sframe %d\n", __FUNCTION__, tp_len,
-	                rpcb->tp_tx_agg_bytes, rpcb->tp_tx_agg_sframes));
-}
-
-static int
-bcm_rpc_tp_tx_agg_release(rpc_tp_info_t * rpcb)
-{
-	rpc_buf_t *b;
-	int err;
-
-	/* no aggregation formed */
-	if (rpcb->tp_tx_agg_p == NULL)
-		return 0;
-
-	RPC_TP_AGG(("%s: send %d, sframe %d\n", __FUNCTION__,
-		rpcb->tp_tx_agg_bytes, rpcb->tp_tx_agg_sframes));
-
-	b = rpcb->tp_tx_agg_p;
-	rpcb->tp_tx_agg_cnt_chain++;
-	rpcb->tp_tx_agg_cnt_sf += rpcb->tp_tx_agg_sframes;
-	rpcb->tp_tx_agg_cnt_bytes += rpcb->tp_tx_agg_bytes;
-
-	if (rpcb->tp_tx_agg_sframes == 1)
-		rpcb->tp_tx_agg_cnt_noagg++;
-
-	err = bcm_rpc_tp_buf_send_internal(rpcb, b);
-	bcm_rpc_tp_tx_agg_initstate(rpcb);
-	return err;
-}
-
-static void
-bcm_rpc_tp_tx_agg_flush(rpc_tp_info_t * rpcb)
-{
-	/* toss the chained buffer */
-	if (rpcb->tp_tx_agg_p)
-		bcm_rpc_tp_buf_free(rpcb, rpcb->tp_tx_agg_p);
-
-	bcm_rpc_tp_tx_agg_initstate(rpcb);
-}
-
-
-static void BCMFASTPATH
-rpc_dbus_send_complete(void *handle, void *pktinfo, int status)
-{
-	rpc_tp_info_t *rpcb = (rpc_tp_info_t *)handle;
-
-	ASSERT(rpcb);
-
-	/* tx_complete is for (BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPPY) */
-	if (rpcb->tx_complete)
-		(rpcb->tx_complete)(rpcb->tx_context, pktinfo, status);
-	else if (pktinfo)
-		bcm_rpc_tp_pktfree(rpcb, pktinfo, TRUE);
-
-	RPC_TP_LOCK(rpcb);
-
-	rpcb->bus_txpending--;
-
-	if (rpcb->tx_flowctl && rpcb->bus_txpending == (rpcb->bus_txdepth - 1)) {
-		RPC_OSL_WAKE(rpcb->rpc_osh);
-	}
-
-	RPC_TP_UNLOCK(rpcb);
-
-	if (status)
-		printf("%s: tx failed=%d\n", __FUNCTION__, status);
-}
-
-static void BCMFASTPATH
-rpc_dbus_recv_pkt(void *handle, void *pkt)
-{
-	rpc_tp_info_t *rpcb = handle;
-
-	if ((rpcb == NULL) || (pkt == NULL))
-		return;
-
-	bcm_rpc_buf_pull(rpcb, pkt, BCM_RPC_TP_ENCAP_LEN);
-	bcm_rpc_tp_rx(rpcb, pkt);
-}
-
-static void BCMFASTPATH
-rpc_dbus_recv_buf(void *handle, uint8 *buf, int len)
-{
-	rpc_tp_info_t *rpcb = handle;
-	void *pkt;
-	uint32 rpc_len;
-	uint frag;
-	uint agglen;
-	if ((rpcb == NULL) || (buf == NULL))
-		return;
-	frag = rpcb->tp_host_deagg_cnt_sf;
-	agglen = len;
-
-	/* TP pkt should have more than encapsulation header */
-	if (len <= BCM_RPC_TP_ENCAP_LEN) {
-		RPC_TP_ERR(("%s: wrong len %d\n", __FUNCTION__, len));
-		goto error;
-	}
-
-	while (len > BCM_RPC_TP_ENCAP_LEN) {
-		rpc_len = ltoh32_ua(buf);
-
-		if (rpc_len > (uint32)(len - BCM_RPC_TP_ENCAP_LEN)) {
-			rpcb->tp_host_deagg_cnt_badsflen++;
-			return;
-		}
-		/* RPC_BUFFER_RX: allocate */
-#if defined(BCM_RPC_ROC)
-		if ((pkt = PKTGET(rpcb->osh, rpc_len, FALSE)) == NULL) {
-#else
-		if ((pkt = bcm_rpc_tp_pktget(rpcb, rpc_len, FALSE)) == NULL) {
-#endif
-			printf("%s: bcm_rpc_tp_pktget failed (len %d)\n", __FUNCTION__, len);
-			goto error;
-		}
-		/* RPC_BUFFER_RX: BYTE_COPY from dbus buffer */
-		bcopy(buf + BCM_RPC_TP_ENCAP_LEN, bcm_rpc_buf_data(rpcb, pkt), rpc_len);
-
-		/* !! send up */
-		bcm_rpc_tp_rx(rpcb, pkt);
-
-		len -= (BCM_RPC_TP_ENCAP_LEN + rpc_len);
-		buf += (BCM_RPC_TP_ENCAP_LEN + rpc_len);
-
-		if (len > BCM_RPC_TP_ENCAP_LEN) {	/* more frag */
-			rpcb->tp_host_deagg_cnt_sf++;
-			RPC_TP_DEAGG(("%s: deagg %d(remaining %d) bytes\n", __FUNCTION__,
-				rpc_len, len));
-		} else {
-			if (len != 0) {
-				printf("%s: deagg, remaining len %d is not 0\n", __FUNCTION__, len);
-			}
-			rpcb->tp_host_deagg_cnt_pass++;
-		}
-	}
-
-	if (frag < rpcb->tp_host_deagg_cnt_sf) {	/* aggregated frames */
-		rpcb->tp_host_deagg_cnt_sf++;	/* last one was not counted */
-		rpcb->tp_host_deagg_cnt_chain++;
-
-		rpcb->tp_host_deagg_cnt_bytes += agglen;
-	}
-error:
-	return;
-}
-
-int BCMFASTPATH
-bcm_rpc_tp_recv_rtn(rpc_tp_info_t *rpcb)
-{
-	void *pkt;
-	int status = 0;
-	if (!rpcb)
-		return BCME_BADARG;
-
-	if ((pkt = bcm_rpc_tp_pktget(rpcb, PKTBUFSZ, FALSE)) == NULL) {
-		return BCME_NORESOURCE;
-	}
-
-	RPC_TP_LOCK(rpcb);
-	if (rpcb->rx_rtn_pkt != NULL) {
-		RPC_TP_UNLOCK(rpcb);
-		if (pkt != NULL)
-			bcm_rpc_tp_pktfree(rpcb, pkt, FALSE);
-		return BCME_BUSY;
-	}
-	rpcb->rx_rtn_pkt = pkt;
-	RPC_TP_UNLOCK(rpcb);
-
-#ifndef  BCMUSBDEV_EP_FOR_RPCRETURN
-	status = dbus_recv_ctl(rpcb->bus, bcm_rpc_buf_data(rpcb, rpcb->rx_rtn_pkt), PKTBUFSZ);
-#else
-	if (rpcb->has_2nd_bulk_in_ep) {
-		status = dbus_recv_bulk(rpcb->bus, USBDEV_BULK_IN_EP2);
-	} else {
-		status = dbus_recv_ctl(rpcb->bus, bcm_rpc_buf_data(rpcb, rpcb->rx_rtn_pkt),
-			PKTBUFSZ);
-	}
-#endif /* BCMUSBDEV_EP_FOR_RPCRETURN */
-	if (status) {
-		/* May have been cleared by complete routine */
-		RPC_TP_LOCK(rpcb);
-		pkt = rpcb->rx_rtn_pkt;
-		rpcb->rx_rtn_pkt = NULL;
-		RPC_TP_UNLOCK(rpcb);
-		if (pkt != NULL)
-			bcm_rpc_tp_pktfree(rpcb, pkt, FALSE);
-		if (status == DBUS_ERR_RXFAIL)
-			status  = BCME_RXFAIL;
-		else if (status == DBUS_ERR_NODEVICE)
-			status  = BCME_NODEVICE;
-		else
-			status  = BCME_ERROR;
-	}
-	return status;
-}
-
-static void
-rpc_dbus_flowctrl_tx(void *handle, bool on)
-{
-}
-
-static void
-rpc_dbus_errhandler(void *handle, int err)
-{
-}
-
-static void
-rpc_dbus_ctl_complete(void *handle, int type, int status)
-{
-	rpc_tp_info_t *rpcb = (rpc_tp_info_t *)handle;
-	void *pkt;
-
-	RPC_TP_LOCK(rpcb);
-	pkt = rpcb->rx_rtn_pkt;
-	rpcb->rx_rtn_pkt = NULL;
-	RPC_TP_UNLOCK(rpcb);
-
-	if (!status) {
-
-		bcm_rpc_buf_pull(rpcb, pkt, BCM_RPC_TP_ENCAP_LEN);
-		(rpcb->rx_pkt)(rpcb->rx_context, pkt);
-
-	} else {
-		RPC_TP_ERR(("%s: no rpc rx ctl, dropping 0x%x\n", __FUNCTION__, status));
-		bcm_rpc_tp_pktfree(rpcb, pkt, TRUE);
-	}
-}
-
-static void
-rpc_dbus_state_change(void *handle, int state)
-{
-	rpc_tp_info_t *rpcb = handle;
-
-	if (rpcb == NULL)
-		return;
-
-	/* FIX: DBUS is down, need to do something? */
-	if (state == DBUS_STATE_DOWN) {
-		RPC_TP_ERR(("%s: DBUS is down\n", __FUNCTION__));
-	}
-}
-
-static void *
-rpc_dbus_pktget(void *handle, uint len, bool send)
-{
-	rpc_tp_info_t *rpcb = handle;
-	void *p;
-
-	if (rpcb == NULL)
-		return NULL;
-
-	if ((p = bcm_rpc_tp_pktget(rpcb, len, send)) == NULL) {
-		return NULL;
-	}
-
-	return p;
-}
-
-static void
-rpc_dbus_pktfree(void *handle, void *p, bool send)
-{
-	rpc_tp_info_t *rpcb = handle;
-
-	if ((rpcb == NULL) || (p == NULL))
-		return;
-
-	bcm_rpc_tp_pktfree(rpcb, p, send);
-}
-
-static dbus_callbacks_t rpc_dbus_cbs = {
-	rpc_dbus_send_complete,
-	rpc_dbus_recv_buf,
-	rpc_dbus_recv_pkt,
-	rpc_dbus_flowctrl_tx,
-	rpc_dbus_errhandler,
-	rpc_dbus_ctl_complete,
-	rpc_dbus_state_change,
-	rpc_dbus_pktget,
-	rpc_dbus_pktfree
-};
-
-#if !defined(NDIS)
-rpc_tp_info_t *
-bcm_rpc_tp_attach(osl_t * osh, void *bus)
-#else
-rpc_tp_info_t *
-bcm_rpc_tp_attach(osl_t * osh, shared_info_t *shared, void *bus)
-#endif
-{
-	rpc_tp_info_t *rpcb;
-	dbus_pub_t *dbus = NULL;
-	dbus_attrib_t attrib;
-	dbus_config_t config;
-#if defined(linux)
-	void *shared = NULL;
-#endif /* linux */
-
-	rpcb = (rpc_tp_info_t*)MALLOC(osh, sizeof(rpc_tp_info_t));
-	if (rpcb == NULL) {
-		printf("%s: rpc_tp_info_t malloc failed\n", __FUNCTION__);
-		return NULL;
-	}
-	memset(rpcb, 0, sizeof(rpc_tp_info_t));
-
-	bcm_rpc_tp_tx_agg_initstate(rpcb);
-
-#if defined(NDIS)
-	NdisAllocateSpinLock(&rpcb->lock);
-#else
-	spin_lock_init(&rpcb->lock);
-#endif
-	rpcb->osh = osh;
-
-	/* FIX: Need to determine rx size and pass it here */
-	dbus = (struct dbus_pub *)dbus_attach(osh, DBUS_RX_BUFFER_SIZE_RPC, BCM_RPC_TP_DBUS_NRXQ,
-		BCM_RPC_TP_DBUS_NTXQ, rpcb /* info */, &rpc_dbus_cbs, &dbus_extdl, shared);
-
-	if (dbus == NULL) {
-		printf("%s: dbus_attach failed\n", __FUNCTION__);
-		goto error;
-	}
-
-	rpcb->bus = (struct dbus_pub *)dbus;
-
-	memset(&attrib, 0, sizeof(attrib));
-	dbus_get_attrib(dbus, &attrib);
-	rpcb->has_2nd_bulk_in_ep = attrib.has_2nd_bulk_in_ep;
-	rpcb->bus_mtu = attrib.mtu;
-	rpcb->bus_txdepth = BCM_RPC_TP_DBUS_NTXQ;
-
-	config.config_id = DBUS_CONFIG_ID_RXCTL_DEFERRES;
-	config.rxctl_deferrespok = TRUE;
-	dbus_set_config(dbus, &config);
-
-	rpcb->tp_tx_agg_sframes_limit = BCM_RPC_TP_HOST_AGG_MAX_SFRAME;
-	rpcb->tp_tx_agg_bytes_max = BCM_RPC_TP_HOST_AGG_MAX_BYTE;
-
-#if defined(NDIS)
-	rpcb->sh = shared;
-#endif /* NDIS */
-
-	/* Bring DBUS up right away so RPC can start receiving */
-	if (dbus_up(dbus)) {
-		RPC_TP_ERR(("%s: dbus_up failed\n", __FUNCTION__));
-		goto error;
-	}
-
-	return rpcb;
-
-error:
-	if (rpcb)
-		bcm_rpc_tp_detach(rpcb);
-
-	return NULL;
-}
-
-void
-bcm_rpc_tp_detach(rpc_tp_info_t * rpcb)
-{
-	ASSERT(rpcb);
-
-	if (rpcb->bus) {
-#if defined(NDIS)
-		NdisFreeSpinLock(&rpcb->lock);
-#endif
-		if (rpcb->bus != NULL)
-			dbus_detach(rpcb->bus);
-		rpcb->bus = NULL;
-	}
-
-	MFREE(rpcb->osh, rpcb, sizeof(rpc_tp_info_t));
-}
-
-void
-bcm_rpc_tp_watchdog(rpc_tp_info_t *rpcb)
-{
-	static int old = 0;
-
-	/* close agg periodically to avoid stale aggregation(include rpc_agg change) */
-	bcm_rpc_tp_tx_agg_release(rpcb);
-
-	RPC_TP_AGG(("agg delta %d\n", (rpcb->tp_tx_agg_cnt_sf - old)));
-
-	old = rpcb->tp_tx_agg_cnt_sf;
-	BCM_REFERENCE(old);
-}
-
-static void
-bcm_rpc_tp_rx(rpc_tp_info_t *rpcb, void *p)
-{
-	RPC_TP_LOCK(rpcb);
-	rpcb->rx_cnt++;
-	RPC_TP_UNLOCK(rpcb);
-
-	if (rpcb->rx_pkt == NULL) {
-		printf("%s: no rpc rx fn, dropping\n", __FUNCTION__);
-		RPC_TP_LOCK(rpcb);
-		rpcb->rxdrop_cnt++;
-		RPC_TP_UNLOCK(rpcb);
-
-		/* RPC_BUFFER_RX: free if no callback */
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-		PKTFREE(rpcb->osh, p, FALSE);
-#else
-		bcm_rpc_tp_pktfree(rpcb, p, FALSE);
-#endif
-		return;
-	}
-
-	/* RPC_BUFFER_RX: free inside */
-	(rpcb->rx_pkt)(rpcb->rx_context, p);
-}
-
-void
-bcm_rpc_tp_register_cb(rpc_tp_info_t * rpcb,
-                       rpc_tx_complete_fn_t txcmplt, void* tx_context,
-                       rpc_rx_fn_t rxpkt, void* rx_context,
-                       rpc_osl_t *rpc_osh)
-{
-	rpcb->tx_complete = txcmplt;
-	rpcb->tx_context = tx_context;
-	rpcb->rx_pkt = rxpkt;
-	rpcb->rx_context = rx_context;
-	rpcb->rpc_osh = rpc_osh;
-}
-
-void
-bcm_rpc_tp_deregister_cb(rpc_tp_info_t * rpcb)
-{
-	rpcb->tx_complete = NULL;
-	rpcb->tx_context = NULL;
-	rpcb->rx_pkt = NULL;
-	rpcb->rx_context = NULL;
-	rpcb->rpc_osh = NULL;
-}
-
-static void
-bcm_rpc_tp_tx_encap(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	uint32 *tp_lenp;
-	uint32 rpc_len;
-
-	rpc_len = pkttotlen(rpcb->osh, b);
-	tp_lenp = (uint32*)bcm_rpc_buf_push(rpcb, b, BCM_RPC_TP_ENCAP_LEN);
-	*tp_lenp = htol32(rpc_len);
-}
-
-int
-bcm_rpc_tp_buf_send(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	int err;
-
-	/* Add the TP encapsulation */
-	bcm_rpc_tp_tx_encap(rpcb, b);
-
-	/* if aggregation enabled use the agg path, otherwise send immediately */
-	if (rpcb->tp_tx_aggregation) {
-		err = bcm_rpc_tp_tx_agg(rpcb, b);
-	} else {
-		rpcb->tp_tx_agg_cnt_pass++;
-		err = bcm_rpc_tp_buf_send_internal(rpcb, b);
-	}
-
-	return err;
-}
-
-static int BCMFASTPATH
-bcm_rpc_tp_buf_send_internal(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	int err;
-	bool tx_flow_control;
-	int timeout = RPC_BUS_SEND_WAIT_TIMEOUT_MSEC;
-	bool timedout = FALSE;
-	uint pktlen;
-
-	UNUSED_PARAMETER(pktlen);
-	RPC_TP_LOCK(rpcb);
-
-	rpcb->rpctp_dbus_hist[rpcb->bus_txpending]++;
-
-	/* Increment before sending to avoid race condition */
-	rpcb->bus_txpending++;
-	tx_flow_control = (rpcb->bus_txpending >= rpcb->bus_txdepth);
-
-	if (rpcb->tx_flowctl != tx_flow_control) {
-		rpcb->tx_flowctl = tx_flow_control;
-		RPC_TP_DBG(("%s, tx_flowctl change to %d pending %d\n", __FUNCTION__,
-			rpcb->tx_flowctl, rpcb->bus_txpending));
-	}
-	rpcb->tx_flowctl_cnt += rpcb->tx_flowctl ? 1 : 0;
-	RPC_TP_UNLOCK(rpcb);
-
-	if (rpcb->tx_flowctl_override) {
-		timeout = RPC_BUS_SEND_WAIT_EXT_TIMEOUT_MSEC;
-	}
-
-	if (rpcb->tx_flowctl || rpcb->tx_flowctl_override) {
-		err = RPC_OSL_WAIT(rpcb->rpc_osh, timeout, &timedout);
-		if (timedout) {
-			printf("%s: RPC_OSL_WAIT error %d timeout %d(ms)\n", __FUNCTION__, err,
-			       RPC_BUS_SEND_WAIT_TIMEOUT_MSEC);
-			RPC_TP_LOCK(rpcb);
-			rpcb->txerr_cnt++;
-			rpcb->bus_txpending--;
-			RPC_TP_UNLOCK(rpcb);
-			return err;
-		}
-	}
-
-#if defined(BCMUSB) || defined(USBAP)
-	if (rpcb->tp_tx_agg_bytes != 0) {
-		ASSERT(rpcb->tp_tx_agg_p == b);
-		ASSERT(rpcb->tp_tx_agg_ptail != NULL);
-
-		/* Make sure pktlen is not multiple of 512 bytes even after possible dbus padding */
-		if ((ROUNDUP(rpcb->tp_tx_agg_bytes, sizeof(uint32)) % BCM_RPC_TP_HOST_TOTALLEN_ZLP)
-			== 0) {
-			uint32 *tp_lenp = (uint32 *)bcm_rpc_buf_data(rpcb, rpcb->tp_tx_agg_ptail);
-			uint32 tp_len = ltoh32(*tp_lenp);
-			pktlen = bcm_rpc_buf_len_get(rpcb, rpcb->tp_tx_agg_ptail);
-			ASSERT(tp_len + BCM_RPC_TP_ENCAP_LEN == pktlen);
-
-			RPC_TP_DBG(("%s, agg pkt is multiple of 512 bytes\n", __FUNCTION__));
-
-			tp_len += BCM_RPC_TP_HOST_TOTALLEN_ZLP_PAD;
-			pktlen += BCM_RPC_TP_HOST_TOTALLEN_ZLP_PAD;
-			*tp_lenp = htol32(tp_len);
-			bcm_rpc_buf_len_set(rpcb, rpcb->tp_tx_agg_ptail, pktlen);
-		}
-	} else {	/* not aggregated */
-		ASSERT(b != NULL);
-		pktlen = bcm_rpc_buf_len_get(rpcb, b);
-		/* Make sure pktlen is not multiple of 512 bytes even after possible dbus padding */
-		if ((pktlen != 0) &&
-			((ROUNDUP(pktlen, sizeof(uint32)) % BCM_RPC_TP_HOST_TOTALLEN_ZLP) == 0)) {
-			uint32 *tp_lenp = (uint32 *)bcm_rpc_buf_data(rpcb, b);
-			uint32 tp_len = ltoh32(*tp_lenp);
-			ASSERT(tp_len + BCM_RPC_TP_ENCAP_LEN == pktlen);
-
-			RPC_TP_DBG(("%s, nonagg pkt is multiple of 512 bytes\n", __FUNCTION__));
-
-			tp_len += BCM_RPC_TP_HOST_TOTALLEN_ZLP_PAD;
-			pktlen += BCM_RPC_TP_HOST_TOTALLEN_ZLP_PAD;
-			*tp_lenp = htol32(tp_len);
-			bcm_rpc_buf_len_set(rpcb, b, pktlen);
-		}
-	}
-#endif /* defined(BCMUSB) || defined(USBAP) */
-
-#ifdef EHCI_FASTPATH_TX
-	/* With optimization, submit code is lockless, use RPC_TP_LOCK */
-	RPC_TP_LOCK(rpcb);
-	err = dbus_send_pkt(rpcb->bus, b, b);
-#else
-	err = dbus_send_pkt(rpcb->bus, b, b);
-	RPC_TP_LOCK(rpcb);
-#endif	/* EHCI_FASTPATH_TX */
-
-	if (err != 0) {
-		printf("%s: dbus_send_pkt failed\n", __FUNCTION__);
-		rpcb->txerr_cnt++;
-		rpcb->bus_txpending--;
-	} else {
-		rpcb->tx_cnt++;
-	}
-	RPC_TP_UNLOCK(rpcb);
-
-	return err;
-}
-
-/* Buffer manipulation */
-uint
-bcm_rpc_buf_tp_header_len(rpc_tp_info_t * rpc_th)
-{
-	return BCM_RPC_TP_ENCAP_LEN;
-}
-
-/* external pkt allocation, with extra BCM_RPC_TP_ENCAP_LEN */
-rpc_buf_t *
-bcm_rpc_tp_buf_alloc(rpc_tp_info_t * rpcb, int len)
-{
-	rpc_buf_t *b;
-	size_t tp_len = len + BCM_RPC_TP_ENCAP_LEN + BCM_RPC_BUS_HDR_LEN;
-
-	b = bcm_rpc_tp_pktget(rpcb, tp_len, TRUE);
-
-	if (b != NULL)
-		PKTPULL(rpcb->osh, b, BCM_RPC_TP_ENCAP_LEN + BCM_RPC_BUS_HDR_LEN);
-
-	return b;
-}
-
-void BCMFASTPATH
-bcm_rpc_tp_buf_free(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	bcm_rpc_tp_pktfree(rpcb, b, TRUE);
-}
-
-/* internal pkt allocation, no BCM_RPC_TP_ENCAP_LEN */
-static rpc_buf_t *
-bcm_rpc_tp_pktget(rpc_tp_info_t * rpcb, int len, bool send)
-{
-	rpc_buf_t* b;
-
-#if defined(NDIS)
-	struct lbuf *lb;
-
-	if (len > LBDATASZ)
-		return (NULL);
-
-	if (send)
-		lb = shared_lb_get(rpcb->sh, &rpcb->sh->txfree);
-	else
-		lb = shared_lb_get(rpcb->sh, &rpcb->sh->rxfree);
-
-	if (lb != NULL)
-		lb->len = len;
-
-	b = (rpc_buf_t*)lb;
-#else
-
-	struct sk_buff *skb;
-
-#if defined(CTFPOOL)
-	skb = PKTGET(rpcb->osh, len, FALSE);
-#else
-	if ((skb = dev_alloc_skb(len))) {
-		skb_put(skb, len);
-		skb->priority = 0;
-	}
-#endif /* defined(CTFPOOL) */
-
-	b = (rpc_buf_t*)skb;
-
-	if (b != NULL) {
-#ifdef CTFMAP
-		/* Clear the ctf buf flag to allow full dma map */
-		PKTCLRCTF(rpcb->osh, skb);
-		CTFMAPPTR(rpcb->osh, skb) = NULL;
-#endif /* CTFMAP */
-
-		RPC_TP_LOCK(rpcb);
-		rpcb->bufalloc++;
-
-		if (!rpcb->rxflowctrl && (rpcb->buf_cnt_inuse >= RPCRX_WM_HI)) {
-			rpcb->rxflowctrl = TRUE;
-			RPC_TP_ERR(("%s, rxflowctrl change to %d\n", __FUNCTION__,
-				rpcb->rxflowctrl));
-			dbus_flowctrl_rx(rpcb->bus, TRUE);
-		}
-
-		rpcb->buf_cnt_inuse++;
-
-		if (rpcb->buf_cnt_inuse > (int)rpcb->buf_cnt_max)
-			rpcb->buf_cnt_max = rpcb->buf_cnt_inuse;
-
-		RPC_TP_UNLOCK(rpcb);
-	} else {
-		printf("%s: buf alloc failed buf_cnt_inuse %d rxflowctrl:%d\n",
-		       __FUNCTION__, rpcb->buf_cnt_inuse, rpcb->rxflowctrl);
-		ASSERT(0);
-	}
-
-#endif /* NDIS */
-	return b;
-}
-
-static void BCMFASTPATH
-bcm_rpc_tp_pktfree(rpc_tp_info_t * rpcb, rpc_buf_t *b, bool send)
-{
-	uint32 free_cnt = 0;
-#if defined(NDIS)
-	struct lbuf *lb = (struct lbuf*)b;
-	struct lbuf *next;
-
-	ASSERT(rpcb);
-
-	ASSERT(lb != NULL);
-
-	do {
-		next = lb->next;
-		lb->next = NULL;
-		ASSERT(lb->p == NULL);
-
-		shared_lb_put(rpcb->sh, lb->l, lb);
-
-		free_cnt++;
-		lb = next;
-	} while (lb);
-
-#else
-	struct sk_buff *skb = (struct sk_buff*)b, *next;
-
-#if defined(CTFPOOL)
-	next = skb;
-	while (next != NULL) {
-		next = next->next;
-		free_cnt++;
-	}
-
-	PKTFREE(rpcb->osh, skb, FALSE);
-#else
-	while (skb) {
-		next = skb->next;
-
-		if (skb->destructor) {
-		/* cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if destructor exists */
-			dev_kfree_skb_any(skb);
-		} else {
-			/* can free immediately (even in_irq()) if destructor does not exist */
-			dev_kfree_skb(skb);
-		}
-		skb = next;
-		free_cnt++;
-	}
-#endif /* defined(CTFPOOL) */
-
-	RPC_TP_LOCK(rpcb);
-	rpcb->buf_cnt_inuse -= free_cnt;
-
-	if (rpcb->rxflowctrl && (rpcb->buf_cnt_inuse < RPCRX_WM_LO)) {
-		rpcb->rxflowctrl = FALSE;
-		RPC_TP_ERR(("%s, rxflowctrl change to %d\n", __FUNCTION__, rpcb->rxflowctrl));
-		dbus_flowctrl_rx(rpcb->bus, FALSE);
-	}
-
-	RPC_TP_UNLOCK(rpcb);
-#endif /* NDIS */
-
-}
-
-void
-bcm_rpc_tp_down(rpc_tp_info_t *rpcb)
-{
-	bcm_rpc_tp_tx_agg_flush(rpcb);
-
-	dbus_down(rpcb->bus);
-}
-
-int
-bcm_rpc_buf_len_get(rpc_tp_info_t * rpcb, rpc_buf_t* b)
-{
-	return PKTLEN(rpcb->osh, b);
-}
-
-int
-bcm_rpc_buf_len_set(rpc_tp_info_t * rpcb, rpc_buf_t* b, uint len)
-{
-	PKTSETLEN(rpcb->osh, b, len);
-	return 0;
-}
-
-unsigned char*
-bcm_rpc_buf_data(rpc_tp_info_t * rpcb, rpc_buf_t* b)
-{
-	return PKTDATA(rpcb->osh, b);
-}
-
-unsigned char*
-bcm_rpc_buf_push(rpc_tp_info_t * rpcb, rpc_buf_t* b, uint bytes)
-{
-	return PKTPUSH(rpcb->osh, b, bytes);
-}
-
-unsigned char* BCMFASTPATH
-bcm_rpc_buf_pull(rpc_tp_info_t * rpcb, rpc_buf_t* b, uint bytes)
-{
-	return PKTPULL(rpcb->osh, b, bytes);
-}
-
-rpc_buf_t *
-bcm_rpc_buf_next_get(rpc_tp_info_t * rpcb, rpc_buf_t* b)
-{
-	return (rpc_buf_t *)PKTLINK(b);
-}
-
-void
-bcm_rpc_buf_next_set(rpc_tp_info_t * rpcb, rpc_buf_t* b, rpc_buf_t *nextb)
-{
-	PKTSETLINK(b, nextb);
-}
-
-#if defined(WLC_HIGH) && defined(BCMDBG)
-int
-bcm_rpc_tp_dump(rpc_tp_info_t *rpcb, struct bcmstrbuf *b)
-{
-	int i = 0, j = 0;
-
-	RPC_TP_LOCK(rpcb);
-
-	bcm_bprintf(b, "\nRPC_TP_DBUS:\n");
-	bcm_bprintf(b, "bufalloc %d(buf_inuse %d, max %d) tx %d(txerr %d) rx %d(rxdrop %d)\n",
-		rpcb->bufalloc, rpcb->buf_cnt_inuse, rpcb->buf_cnt_max, rpcb->tx_cnt,
-		rpcb->txerr_cnt, rpcb->rx_cnt, rpcb->rxdrop_cnt);
-
-	bcm_bprintf(b, "mtu %d depth %d pending %d tx_flowctrl_cnt %d, rxflowctl %d\n",
-	            rpcb->bus_mtu, rpcb->bus_txdepth, rpcb->bus_txpending, rpcb->tx_flowctl_cnt,
-	            rpcb->rxflowctrl);
-
-	bcm_bprintf(b, "tp_host_deagg chain %d subframes %d bytes %d badsflen %d passthrough %d\n",
-		rpcb->tp_host_deagg_cnt_chain, rpcb->tp_host_deagg_cnt_sf,
-		rpcb->tp_host_deagg_cnt_bytes,
-		rpcb->tp_host_deagg_cnt_badsflen, rpcb->tp_host_deagg_cnt_pass);
-	bcm_bprintf(b, "tp_host_deagg sf/chain %d bytes/chain %d \n",
-		(rpcb->tp_host_deagg_cnt_chain == 0) ?
-		0 : rpcb->tp_host_deagg_cnt_sf/rpcb->tp_host_deagg_cnt_chain,
-		(rpcb->tp_host_deagg_cnt_chain == 0) ?
-		0 : rpcb->tp_host_deagg_cnt_bytes/rpcb->tp_host_deagg_cnt_chain);
-
-	bcm_bprintf(b, "\n");
-
-	bcm_bprintf(b, "tp_host_agg sf_limit %d bytes_limit %d\n",
-		rpcb->tp_tx_agg_sframes_limit, rpcb->tp_tx_agg_bytes_max);
-	bcm_bprintf(b, "tp_host_agg: chain %d, sf %d, bytes %d, non-agg-frame %d bypass %d\n",
-		rpcb->tp_tx_agg_cnt_chain, rpcb->tp_tx_agg_cnt_sf, rpcb->tp_tx_agg_cnt_bytes,
-		rpcb->tp_tx_agg_cnt_noagg, rpcb->tp_tx_agg_cnt_pass);
-	bcm_bprintf(b, "tp_host_agg: sf/chain %d, bytes/chain %d\n",
-		(rpcb->tp_tx_agg_cnt_chain == 0) ?
-		0 : rpcb->tp_tx_agg_cnt_sf/rpcb->tp_tx_agg_cnt_chain,
-		(rpcb->tp_tx_agg_cnt_chain == 0) ?
-		0 : rpcb->tp_tx_agg_cnt_bytes/rpcb->tp_tx_agg_cnt_chain);
-
-	bcm_bprintf(b, "\nRPC TP histogram\n");
-	for (i = 0; i < BCM_RPC_TP_DBUS_NTXQ; i++) {
-		if (rpcb->rpctp_dbus_hist[i]) {
-			bcm_bprintf(b, "%d: %d ", i, rpcb->rpctp_dbus_hist[i]);
-			j++;
-			if (j % 10 == 0) {
-				bcm_bprintf(b, "\n");
-			}
-		}
-	}
-	bcm_bprintf(b, "\n");
-
-	RPC_TP_UNLOCK(rpcb);
-
-	dbus_hist_dump(rpcb->bus, b);
-
-	return 0;
-}
-#endif /* BCMDBG */
-
-void
-bcm_rpc_tp_sleep(rpc_tp_info_t *rpcb)
-{
-	dbus_pnp_sleep(rpcb->bus);
-}
-
-int
-bcm_rpc_tp_resume(rpc_tp_info_t *rpcb, int *fw_reload)
-{
-	return dbus_pnp_resume(rpcb->bus, fw_reload);
-}
-
-#ifdef NDIS
-int
-bcm_rpc_tp_shutdown(rpc_tp_info_t *rpcb)
-{
-	return dbus_shutdown(rpcb->bus);
-}
-
-void
-bcm_rpc_tp_surp_remove(rpc_tp_info_t * rpcb)
-{
-	dbus_pnp_disconnect(rpcb->bus);
-}
-
-
-bool
-bcm_rpc_tp_tx_flowctl_get(rpc_tp_info_t *rpc_th)
-{
-	return rpc_th->tx_flowctl;
-}
-
-#endif /* NDIS */
-
-int
-bcm_rpc_tp_get_device_speed(rpc_tp_info_t *rpc_th)
-{
-	return dbus_get_device_speed(rpc_th->bus);
-}
-
-void
-bcm_rpc_tp_msglevel_set(rpc_tp_info_t *rpc_th, uint8 msglevel, bool high_low)
-{
-	ASSERT(high_low == TRUE);
-
-	tp_level_host = msglevel;
-}
-void
-bcm_rpc_tp_get_vidpid(rpc_tp_info_t *rpc_th, uint16 *dnglvid, uint16 *dnglpid)
-{
-	dbus_attrib_t attrib;
-	if (rpc_th && rpc_th->bus) {
-		memset(&attrib, 0, sizeof(attrib));
-		dbus_get_attrib(rpc_th->bus, &attrib);
-		*dnglvid = (uint16) attrib.vid;
-		*dnglpid = (uint16) attrib.pid;
-	}
-}
-
-void *
-bcm_rpc_tp_get_devinfo(rpc_tp_info_t *rpc_th)
-{
-	if (rpc_th && rpc_th->bus) {
-		return dbus_get_devinfo(rpc_th->bus);
-	}
-
-	return NULL;
-}
-
-int
-bcm_rpc_tp_set_config(rpc_tp_info_t *rpc_th, void *config)
-{
-	int err = DBUS_ERR;
-	if (rpc_th && rpc_th->bus) {
-		err = dbus_set_config(rpc_th->bus, (dbus_config_t*)config);
-	}
-	return err;
-}
diff -Nuar merlin-bkp/shared/bcm_rpc_tp_rte.c merlin-new/shared/bcm_rpc_tp_rte.c
--- merlin-bkp/shared/bcm_rpc_tp_rte.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/bcm_rpc_tp_rte.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,988 +0,0 @@
-/*
- * RPC Transport layer(for HNDRTE bus driver)
- * Broadcom 802.11abg Networking Device Driver
- *
- * Copyright (C) 2013, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: bcm_rpc_tp_rte.c 419467 2013-08-21 09:19:48Z $
- */
-
-#ifndef WLC_LOW
-#error "SPLIT"
-#endif
-
-#include <typedefs.h>
-#include <bcmdefs.h>
-#include <bcmendian.h>
-#include <osl.h>
-#include <bcmutils.h>
-
-#include <bcm_rpc_tp.h>
-#include <bcm_rpc.h>
-
-static uint8 tp_level_bmac = RPC_TP_MSG_DNGL_ERR_VAL; /* RPC_TP_MSG_DNGL_ERR_VAL; */
-#define	RPC_TP_ERR(args)   do {if (tp_level_bmac & RPC_TP_MSG_DNGL_ERR_VAL) printf args;} while (0)
-#ifdef BCMDBG
-#define	RPC_TP_DBG(args)   do {if (tp_level_bmac & RPC_TP_MSG_DNGL_DBG_VAL) printf args;} while (0)
-#define	RPC_TP_AGG(args)   do {if (tp_level_bmac & RPC_TP_MSG_DNGL_AGG_VAL) printf args;} while (0)
-#define	RPC_TP_DEAGG(args) do {if (tp_level_bmac & RPC_TP_MSG_DNGL_DEA_VAL) printf args;} while (0)
-#else
-#define RPC_TP_DBG(args)
-#define RPC_TP_AGG(args)
-#define RPC_TP_DEAGG(args)
-#endif
-
-/* CLIENT dongle drvier RPC Transport implementation
- * HOST dongle driver uses DBUS, so it's in bcm_rpc_tp_dbus.c.
- *   This can be moved to bcm_rpc_th_dngl.c
- */
-
-struct rpc_transport_info {
-	osl_t *osh;
-	hndrte_dev_t	*ctx;
-
-	rpc_tx_complete_fn_t tx_complete;
-	void* tx_context;
-	bool tx_flowctl;		/* Global RX (WL->RPC->BUS->Host) flowcontrol state */
-	struct spktq *tx_flowctlq;	/* Queue to store pkts when in global RX flowcontrol */
-	uint8 tx_q_flowctl_hiwm;	/* Queue high watermask */
-	uint8 tx_q_flowctl_lowm;	/* Queue low watermask */
-	uint  tx_q_flowctl_highwm_cnt;	/* hit high watermark counter */
-	uint8 tx_q_flowctl_segcnt;	/* Queue counter all segments(no. of LBUF) */
-
-	rpc_rx_fn_t rx_pkt;
-	void* rx_context;
-
-	uint bufalloc;
-	int buf_cnt_inuse;		/* outstanding buf(alloc, not freed) */
-	uint tx_cnt;			/* send successfully */
-	uint txerr_cnt;			/* send failed */
-	uint rx_cnt;
-	uint rxdrop_cnt;
-
-	uint tx_flowctl_cnt;		/* tx flow control transition times */
-	bool tx_flowcontrolled;		/* tx flow control active */
-
-	rpc_txflowctl_cb_t txflowctl_cb; /* rpc tx flow control to control wlc_dpc() */
-	void *txflowctl_ctx;
-
-	mbool tp_dngl_aggregation;	/* aggregate into transport buffers */
-	rpc_buf_t *tp_dngl_agg_p;	/* current aggregate chain header */
-	rpc_buf_t *tp_dngl_agg_ptail;	/* current aggregate chain tail */
-	uint tp_dngl_agg_sframes;	/* current aggregate packet subframes */
-	uint8 tp_dngl_agg_sframes_limit;	/* agg sframe limit */
-	uint tp_dngl_agg_bytes;		/* current aggregate packet total length */
-	uint16 tp_dngl_agg_bytes_max;	/* agg byte max */
-	uint tp_dngl_agg_txpending;	/* TBD, for agg watermark flow control */
-	uint tp_dngl_agg_cnt_chain;	/* total aggregated pkt */
-	uint tp_dngl_agg_cnt_sf;	/* total aggregated subframes */
-	uint tp_dngl_agg_cnt_bytes;	/* total aggregated bytes */
-	uint tp_dngl_agg_cnt_noagg;	/* no. pkts not aggregated */
-	uint tp_dngl_agg_cnt_pass;	/* no. pkt bypass agg */
-
-	uint tp_dngl_agg_lazy;		/* lazy to release agg on tp_dngl_aggregation clear */
-
-	uint tp_dngl_deagg_cnt_chain;	/* multifrag pkt */
-	uint tp_dngl_deagg_cnt_sf;	/* no. of frag inside multifrag */
-	uint tp_dngl_deagg_cnt_clone;	/* no. of clone */
-	uint tp_dngl_deagg_cnt_bytes;	/* total deagg bytes */
-	uint tp_dngl_deagg_cnt_badfmt;	/* bad format */
-	uint tp_dngl_deagg_cnt_badsflen;	/* bad sf len */
-	uint tp_dngl_deagg_cnt_pass;	/* passthrough, single frag */
-	int has_2nd_bulk_in_ep;
-};
-
-#define	BCM_RPC_TP_Q_MAX	1024	/* Rx flow control queue size - Set it big and we don't
-					 * expect it to get full. If the memory gets low, we
-					 * just stop processing wlc_dpc
-					 */
-#ifndef BCM_RPC_TP_FLOWCTL_QWM_HIGH
-#define BCM_RPC_TP_FLOWCTL_QWM_HIGH	24	/* high watermark for tp queue */
-#endif
-#define BCM_RPC_TP_FLOWCTL_QWM_LOW	4	/* low watermark for tp queue */
-
-/* no. of aggregated subframes per second to activate/deactivate lazy agg(delay release)
- * For medium traffic, the sf/s is > 5k+
- */
-#define BCM_RPC_TP_AGG_LAZY_WM_HI	50	/* activate lazy agg if higher than this */
-#define BCM_RPC_TP_AGG_LAZY_WM_LO	20	/* deactivate lazy agg if lower than this */
-
-/* this WAR is similar to the preaggregated one in wlc_high_stubs.c
- * #define USB_TOTAL_LEN_BAD		516
- * #define USB_TOTAL_LEN_BAD_PAD	8
- */
-#define BCM_RPC_TP_DNGL_TOTLEN_BAD	516
-#define BCM_RPC_TP_DNGL_TOTLEN_BAD_PAD	8
-
-#define BCM_RPC_TP_DNGL_BULKEP_MPS	512
-#define BCM_RPC_TP_DNGL_CTRLEP_MPS	64
-#define BCM_RPC_TP_DNGL_ZLP_PAD		4	/* pad bytes */
-
-static void bcm_rpc_tp_tx_encap(rpc_tp_info_t * rpcb, rpc_buf_t *b);
-static int  bcm_rpc_tp_buf_send_internal(rpc_tp_info_t * rpc_th, rpc_buf_t *b, uint32 ep_idx);
-static void bcm_rpc_tp_buf_send_enq(rpc_tp_info_t * rpc_th, rpc_buf_t *b);
-
-static void bcm_rpc_tp_dngl_agg_initstate(rpc_tp_info_t * rpcb);
-static int  bcm_rpc_tp_dngl_agg(rpc_tp_info_t *rpcb, rpc_buf_t *b);
-static void bcm_rpc_tp_dngl_agg_append(rpc_tp_info_t * rpcb, rpc_buf_t *b);
-static int  bcm_rpc_tp_dngl_agg_release(rpc_tp_info_t * rpcb);
-static void bcm_rpc_tp_dngl_agg_flush(rpc_tp_info_t * rpcb);
-static void bcm_rpc_tp_buf_pad(rpc_tp_info_t * rpcb, rpc_buf_t *bb, uint padbytes);
-
-rpc_tp_info_t *
-BCMATTACHFN(bcm_rpc_tp_attach)(osl_t * osh, void *bus)
-{
-	rpc_tp_info_t *rpc_th;
-	hndrte_dev_t	*ctx = (hndrte_dev_t *)bus;
-
-	rpc_th = (rpc_tp_info_t *)MALLOC(osh, sizeof(rpc_tp_info_t));
-	if (rpc_th == NULL) {
-		RPC_TP_ERR(("%s: rpc_tp_info_t malloc failed\n", __FUNCTION__));
-		return NULL;
-	}
-
-	memset(rpc_th, 0, sizeof(rpc_tp_info_t));
-
-	rpc_th->osh = osh;
-	rpc_th->ctx = ctx;
-
-	/* Init for flow control */
-	rpc_th->tx_flowctl = FALSE;
-	rpc_th->tx_q_flowctl_segcnt = 0;
-	rpc_th->tx_flowctlq = (struct spktq *)MALLOC(osh, sizeof(struct spktq));
-	if (rpc_th->tx_flowctlq == NULL) {
-		RPC_TP_ERR(("%s: txflowctlq malloc failed\n", __FUNCTION__));
-		MFREE(rpc_th->osh, rpc_th, sizeof(rpc_tp_info_t));
-		return NULL;
-	}
-	pktqinit(rpc_th->tx_flowctlq, BCM_RPC_TP_Q_MAX);
-	rpc_th->tx_q_flowctl_hiwm = BCM_RPC_TP_FLOWCTL_QWM_HIGH;
-	rpc_th->tx_q_flowctl_lowm = BCM_RPC_TP_FLOWCTL_QWM_LOW;
-
-	rpc_th->tp_dngl_agg_lazy = 0;
-	rpc_th->tp_dngl_agg_sframes_limit = BCM_RPC_TP_DNGL_AGG_MAX_SFRAME;
-	rpc_th->tp_dngl_agg_bytes_max = BCM_RPC_TP_DNGL_AGG_MAX_BYTE;
-#ifdef  BCMUSBDEV_EP_FOR_RPCRETURN
-	rpc_th->has_2nd_bulk_in_ep = 1;
-#endif /* BCMUSBDEV_EP_FOR_RPCRETURN */
-	return rpc_th;
-}
-
-void
-BCMATTACHFN(bcm_rpc_tp_detach)(rpc_tp_info_t * rpc_th)
-{
-	ASSERT(rpc_th);
-	if (rpc_th->tx_flowctlq)
-		MFREE(rpc_th->osh, rpc_th->tx_flowctlq, sizeof(struct spktq));
-
-	MFREE(rpc_th->osh, rpc_th, sizeof(rpc_tp_info_t));
-}
-
-void
-bcm_rpc_tp_watchdog(rpc_tp_info_t *rpcb)
-{
-	static uint old = 0;
-	uint delta;
-
-	/* (1) close agg periodically to avoid stale aggregation */
-	bcm_rpc_tp_dngl_agg_release(rpcb);
-
-
-	delta = rpcb->tp_dngl_agg_cnt_sf - old;
-	old = rpcb->tp_dngl_agg_cnt_sf;
-
-	RPC_TP_DBG(("agg delta %d tp flowcontrol queue pending (qlen %d subframe %d)\n", delta,
-		pktq_len(rpcb->tx_flowctlq), rpcb->tx_q_flowctl_segcnt));
-
-	if (rpcb->tp_dngl_agg_lazy)
-		rpcb->tp_dngl_agg_lazy = (delta < BCM_RPC_TP_AGG_LAZY_WM_LO) ? 0 : 1;
-	else
-		rpcb->tp_dngl_agg_lazy = (delta > BCM_RPC_TP_AGG_LAZY_WM_HI) ? 1 : 0;
-}
-
-void
-bcm_rpc_tp_rx_from_dnglbus(rpc_tp_info_t *rpc_th, struct lbuf *lb)
-{
-	void *orig_p, *p;
-	void *rpc_p, *rpc_prev;
-	uint pktlen, tp_len, iter = 0;
-	osl_t *osh;
-	bool dbg_agg;
-	uint dbg_data[16], i;	/* must fit host agg limit BCM_RPC_TP_HOST_AGG_MAX_SFRAME+1 */
-
-	dbg_agg = FALSE;
-
-	rpc_th->rx_cnt++;
-
-	if (rpc_th->rx_pkt == NULL) {
-		RPC_TP_ERR(("%s: no rpc rx fn, dropping\n", __FUNCTION__));
-		rpc_th->rxdrop_cnt++;
-		lb_free(lb);
-		return;
-	}
-	orig_p = PKTFRMNATIVE(rpc_th->osh, lb);
-
-
-	osh = rpc_th->osh;
-
-	/* take ownership of the dnglbus packet chain
-	 * since it will be freed by bcm_rpc_tp_buf_free()
-	 */
-	rpc_th->buf_cnt_inuse += pktsegcnt(rpc_th->osh, orig_p);
-
-	dbg_data[0] = pktsegcnt(rpc_th->osh, orig_p);
-
-	pktlen = PKTLEN(osh, orig_p);
-
-	p = orig_p;
-
-	/* while we have more data in the TP frame's packet chain,
-	 *   create a packet chain(could be cloned) for the next RPC frame
-	 *   then give it away to high layer for process(buffer not freed)
-	 */
-	while (p != NULL) {
-		iter++;
-
-		/* read TP_HDR(len of rpc frame) and pull the data pointer past the length word */
-		if (pktlen >= BCM_RPC_TP_ENCAP_LEN) {
-			ASSERT(((uint)PKTDATA(osh, p) & 0x3) == 0); /* ensure aligned word read */
-			tp_len = ltoh32(*(uint32*)PKTDATA(osh, p));
-			PKTPULL(osh, p, BCM_RPC_TP_ENCAP_LEN);
-			pktlen -= BCM_RPC_TP_ENCAP_LEN;
-		} else {
-			/* error case: less data than the encapsulation size
-			 * treat as an empty tp buffer, at end of current buffer
-			 */
-			tp_len = 0;
-			pktlen = 0;
-
-			rpc_th->tp_dngl_deagg_cnt_badsflen++;	/* bad sf len */
-		}
-
-		/* if TP header finished a buffer(rpc header in next chained buffer), open next */
-		if (pktlen == 0) {
-			void *next_p = PKTNEXT(osh, p);
-			PKTSETNEXT(osh, p, NULL);
-			rpc_th->buf_cnt_inuse--;
-			PKTFREE(osh, p, FALSE);
-			p = next_p;
-			if (p)
-				pktlen = PKTLEN(osh, p);
-		}
-
-		dbg_data[iter] = tp_len;
-
-		if (tp_len < pktlen || dbg_agg) {
-			dbg_agg = TRUE;
-			RPC_TP_DEAGG(("DEAGG: [%d] p %p data %p pktlen %d tp_len %d\n",
-				iter, p, PKTDATA(osh, p), pktlen, tp_len));
-			rpc_th->tp_dngl_deagg_cnt_sf++;
-			rpc_th->tp_dngl_deagg_cnt_bytes += tp_len;
-		}
-
-		/* empty TP buffer (special case: use tp_len to pad for some USB pktsize bugs) */
-		if (tp_len == 0) {
-			rpc_th->tp_dngl_deagg_cnt_pass++;
-			continue;
-		} else if (tp_len > 10000 ) {	/* something is wrong */
-			/* print out msgs according to value of p  -- in case it is NULL */
-			if (p != NULL) {
-				RPC_TP_ERR(("DEAGG: iter %d, p(%p data %p pktlen %d)\n",
-					iter, p, PKTDATA(osh, p), PKTLEN(osh, p)));
-			} else {
-				RPC_TP_ERR(("DEAGG: iter %d, p is NULL", iter));
-			}
-		}
-
-		/* ========= For this TP subframe, find the end, build a chain, sendup ========= */
-
-		/* RPC frame packet chain starts with this packet */
-		rpc_prev = NULL;
-		rpc_p = p;
-		ASSERT(p != NULL);
-
-		/* find the last frag in this rpc chain */
-		while ((tp_len >= pktlen) && p) {
-			if (dbg_agg)
-				RPC_TP_DEAGG(("DEAGG: tp_len %d consumes p(%p pktlen %d)\n", tp_len,
-					p, pktlen));
-			rpc_prev = p;
-			p = PKTNEXT(osh, p);
-			tp_len -= pktlen;
-
-			if (p != NULL) {
-				pktlen = PKTLEN(osh, p);
-			} else {
-				if (tp_len != 0) {
-					uint totlen, seg;
-					totlen = pkttotlen(osh, rpc_p);
-					seg = pktsegcnt(rpc_th->osh, rpc_p);
-
-					RPC_TP_ERR(("DEAGG, toss[%d], orig_p %p segcnt %d",
-					       iter, orig_p, dbg_data[0]));
-					RPC_TP_ERR(("DEAGG,rpc_p %p totlen %d pktl %d tp_len %d\n",
-					       rpc_p, totlen, pktlen, tp_len));
-					for (i = 1; i <= iter; i++)
-						RPC_TP_ERR(("tplen[%d] = %d  ", i, dbg_data[i]));
-					RPC_TP_ERR(("\n"));
-					p = rpc_p;
-					while (p != NULL) {
-						RPC_TP_ERR(("this seg len %d\n", PKTLEN(osh, p)));
-						p = PKTNEXT(osh, p);
-					}
-
-					rpc_th->buf_cnt_inuse -= seg;
-					PKTFREE(osh, rpc_p, FALSE);
-					rpc_th->tp_dngl_deagg_cnt_badfmt++;
-
-					/* big hammer to recover USB
-					 * extern void dngl_reboot(void); dngl_reboot();
-					 */
-					goto end;
-				}
-				pktlen = 0;
-				break;
-			}
-		}
-
-		/* fix up the last frag */
-		if (tp_len == 0) {
-			/* if the whole RPC buffer chain ended at the end of the prev TP buffer,
-			 *    end the RPC buffer chain. we are done
-			 */
-			if (dbg_agg)
-				RPC_TP_DEAGG(("DEAGG: END rpc chain p %p len %d\n\n", rpc_prev,
-					pktlen));
-
-			PKTSETNEXT(osh, rpc_prev, NULL);
-			if (iter > 1) {
-				rpc_th->tp_dngl_deagg_cnt_chain++;
-				RPC_TP_DEAGG(("this frag %d totlen %d\n", pktlen,
-					pkttotlen(osh, orig_p)));
-			}
-
-		} else {
-			/* if pktlen has more bytes than tp_len, another tp frame must follow
-			 *   create a clone of the sub-range of the current TP buffer covered
-			 *   by the RPC buffer, attach to the end of the RPC buffer chain
-			 *   (cut off the original chain link)
-			 *   continue chain looping(p != NULL)
-			 */
-			void *new_p;
-			ASSERT(p != NULL);
-
-			RPC_TP_DEAGG(("DEAGG: cloning %d bytes out of p(%p data %p) len %d\n",
-				tp_len, p, PKTDATA(osh, p), pktlen));
-
-			new_p = osl_pktclone(osh, p, 0, tp_len);
-			rpc_th->buf_cnt_inuse++;
-			rpc_th->tp_dngl_deagg_cnt_clone++;
-
-			RPC_TP_DEAGG(("DEAGG: after clone, newp(%p data %p pktlen %d)\n",
-				new_p, PKTDATA(osh, new_p), PKTLEN(osh, new_p)));
-
-			if (rpc_prev) {
-				RPC_TP_DEAGG(("DEAGG: chaining: %p->%p(clone)\n", rpc_prev,
-					new_p));
-				PKTSETNEXT(osh, rpc_prev, new_p);
-			} else {
-				RPC_TP_DEAGG(("DEAGG: clone %p is a complete rpc pkt\n", new_p));
-				rpc_p = new_p;
-			}
-
-			PKTPULL(osh, p, tp_len);
-			pktlen -= tp_len;
-			RPC_TP_DEAGG(("DEAGG: remainder packet p %p data %p pktlen %d\n",
-				p, PKTDATA(osh, p), PKTLEN(osh, p)));
-		}
-
-		/* !! send up */
-		(rpc_th->rx_pkt)(rpc_th->rx_context, rpc_p);
-	}
-
-end:
-	ASSERT(p == NULL);
-}
-
-void
-bcm_rpc_tp_register_cb(rpc_tp_info_t * rpc_th,
-                               rpc_tx_complete_fn_t txcmplt, void* tx_context,
-                               rpc_rx_fn_t rxpkt, void* rx_context, rpc_osl_t *rpc_osh)
-{
-	rpc_th->tx_complete = txcmplt;
-	rpc_th->tx_context = tx_context;
-	rpc_th->rx_pkt = rxpkt;
-	rpc_th->rx_context = rx_context;
-}
-
-void
-bcm_rpc_tp_deregister_cb(rpc_tp_info_t * rpcb)
-{
-	rpcb->tx_complete = NULL;
-	rpcb->tx_context = NULL;
-	rpcb->rx_pkt = NULL;
-	rpcb->rx_context = NULL;
-}
-
-
-/* This is called by dngl_txstop as txflowcontrol (stopping tx from dongle to host) of bcmwl,
- * but is called rxflowcontrol in wl driver (pausing rx of wl driver). This is for low driver only.
- */
-void
-bcm_rpc_tp_txflowctl(rpc_tp_info_t *rpc_th, bool state, int prio)
-{
-	rpc_buf_t *b;
-
-	ASSERT(rpc_th);
-
-	if (rpc_th->tx_flowctl == state)
-		return;
-
-	RPC_TP_AGG(("tp_txflowctl %d\n", state));
-
-	rpc_th->tx_flowctl = state;
-	rpc_th->tx_flowctl_cnt++;
-	rpc_th->tx_flowcontrolled = state;
-
-	/* when get out of flowcontrol, send all queued packets in a loop
-	 *  but need to check tx_flowctl every iteration and stop if we got flowcontrolled again
-	 */
-	while (!rpc_th->tx_flowctl && !pktq_empty(rpc_th->tx_flowctlq)) {
-
-		b = pktdeq(rpc_th->tx_flowctlq);
-		if (b == NULL) break;
-
-		rpc_th->tx_q_flowctl_segcnt -= pktsegcnt(rpc_th->osh, b);
-
-		bcm_rpc_tp_buf_send_internal(rpc_th, b, USBDEV_BULK_IN_EP1);
-	}
-
-	/* bcm_rpc_tp_agg_set(rpc_th, BCM_RPC_TP_DNGL_AGG_FLOWCTL, state); */
-
-	/* if lowm is reached, release wldriver
-	 *   TODO, count more(average 3?) if agg is ON
-	 */
-	if (rpc_th->tx_q_flowctl_segcnt < rpc_th->tx_q_flowctl_lowm) {
-		RPC_TP_AGG(("bcm_rpc_tp_txflowctl, wm hit low!\n"));
-		rpc_th->txflowctl_cb(rpc_th->txflowctl_ctx, OFF);
-	}
-
-	return;
-}
-
-void
-bcm_rpc_tp_down(rpc_tp_info_t * rpc_th)
-{
-	bcm_rpc_tp_dngl_agg_flush(rpc_th);
-}
-
-static void
-bcm_rpc_tp_tx_encap(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	uint32 *tp_lenp;
-	uint32 rpc_len;
-
-	rpc_len = PKTLEN(rpcb->osh, b);
-	tp_lenp = (uint32*)PKTPUSH(rpcb->osh, b, BCM_RPC_TP_ENCAP_LEN);
-	*tp_lenp = rpc_len;
-}
-
-int
-bcm_rpc_tp_send_callreturn(rpc_tp_info_t * rpc_th, rpc_buf_t *b)
-{
-	int err, pktlen;
-	struct lbuf *lb;
-	hndrte_dev_t *chained = rpc_th->ctx->chained;
-
-	ASSERT(chained);
-
-	/* Add the TP encapsulation */
-	bcm_rpc_tp_tx_encap(rpc_th, b);
-
-	/* Pad if pkt size is a multiple of MPS */
-	pktlen = bcm_rpc_buf_totlen_get(rpc_th, b);
-		if (pktlen % BCM_RPC_TP_DNGL_CTRLEP_MPS == 0) {
-			RPC_TP_AGG(("%s, tp pkt is multiple of %d bytes, padding %d bytes\n",
-			__FUNCTION__, BCM_RPC_TP_DNGL_CTRLEP_MPS, BCM_RPC_TP_DNGL_ZLP_PAD));
-
-		bcm_rpc_tp_buf_pad(rpc_th, b, BCM_RPC_TP_DNGL_ZLP_PAD);
-	}
-
-	lb = PKTTONATIVE(rpc_th->osh, b);
-
-	if (rpc_th->has_2nd_bulk_in_ep) {
-		err = chained->funcs->xmit2(rpc_th->ctx, chained, lb, USBDEV_BULK_IN_EP2);
-	} else {
-		err = chained->funcs->xmit_ctl(rpc_th->ctx, chained, lb);
-	}
-	/* send through control endpoint */
-	if (err != 0) {
-		RPC_TP_ERR(("%s: xmit failed; free pkt %p\n", __FUNCTION__, lb));
-		rpc_th->txerr_cnt++;
-		lb_free(lb);
-	} else {
-		rpc_th->tx_cnt++;
-
-		/* give pkt ownership to usb driver, decrement the counter */
-		rpc_th->buf_cnt_inuse -= pktsegcnt(rpc_th->osh, b);
-	}
-
-	return err;
-
-}
-
-static void
-bcm_rpc_tp_buf_send_enq(rpc_tp_info_t * rpc_th, rpc_buf_t *b)
-{
-	pktenq(rpc_th->tx_flowctlq, (void*)b);
-	rpc_th->tx_q_flowctl_segcnt += pktsegcnt(rpc_th->osh, b);
-
-	/* if hiwm is reached, throttle wldriver
-	 *   TODO, count more(average 3?) if agg is ON
-	 */
-	if (rpc_th->tx_q_flowctl_segcnt > rpc_th->tx_q_flowctl_hiwm) {
-		rpc_th->tx_q_flowctl_highwm_cnt++;
-
-		RPC_TP_ERR(("bcm_rpc_tp_buf_send_enq, wm hit high!\n"));
-
-		rpc_th->txflowctl_cb(rpc_th->txflowctl_ctx, ON);
-	}
-
-	/* If tx_flowctlq gets full, set a bigger BCM_RPC_TP_Q_MAX */
-	ASSERT(!pktq_full(rpc_th->tx_flowctlq));
-}
-
-int
-bcm_rpc_tp_buf_send(rpc_tp_info_t * rpc_th, rpc_buf_t *b)
-{
-	int err;
-
-	/* Add the TP encapsulation */
-	bcm_rpc_tp_tx_encap(rpc_th, b);
-
-	/* if agg successful, done; otherwise, send it */
-	if (rpc_th->tp_dngl_aggregation) {
-		err = bcm_rpc_tp_dngl_agg(rpc_th, b);
-		return err;
-	}
-	rpc_th->tp_dngl_agg_cnt_pass++;
-
-	if (rpc_th->tx_flowctl) {
-		bcm_rpc_tp_buf_send_enq(rpc_th, b);
-		err = 0;
-	} else {
-		err = bcm_rpc_tp_buf_send_internal(rpc_th, b, USBDEV_BULK_IN_EP1);
-	}
-
-	return err;
-}
-
-static void
-bcm_rpc_tp_buf_pad(rpc_tp_info_t * rpcb, rpc_buf_t *bb, uint padbytes)
-{
-	uint32 *tp_lenp = (uint32 *)bcm_rpc_buf_data(rpcb, bb);
-	uint32 tp_len = ltoh32(*tp_lenp);
-	uint32 pktlen = bcm_rpc_buf_len_get(rpcb, bb);
-	ASSERT(tp_len + BCM_RPC_TP_ENCAP_LEN == pktlen);
-
-	tp_len += padbytes;
-	pktlen += padbytes;
-	*tp_lenp = htol32(tp_len);
-	bcm_rpc_buf_len_set(rpcb, bb, pktlen);
-}
-
-static int
-bcm_rpc_tp_buf_send_internal(rpc_tp_info_t * rpcb, rpc_buf_t *b, uint32 tx_ep_index)
-{
-	int err;
-	struct lbuf *lb = (struct lbuf *)b;
-	hndrte_dev_t *chained = rpcb->ctx->chained;
-	uint pktlen;
-
-	ASSERT(chained);
-
-		ASSERT(b != NULL);
-		pktlen = bcm_rpc_buf_totlen_get(rpcb, b);
-
-		if (pktlen == BCM_RPC_TP_DNGL_TOTLEN_BAD) {
-			RPC_TP_AGG(("%s, pkt is %d bytes, padding %d bytes\n", __FUNCTION__,
-				BCM_RPC_TP_DNGL_TOTLEN_BAD, BCM_RPC_TP_DNGL_TOTLEN_BAD_PAD));
-
-			bcm_rpc_tp_buf_pad(rpcb, b, BCM_RPC_TP_DNGL_TOTLEN_BAD_PAD);
-
-		} else if (pktlen % BCM_RPC_TP_DNGL_BULKEP_MPS == 0) {
-			RPC_TP_AGG(("%s, tp pkt is multiple of %d bytes, padding %d bytes\n",
-				__FUNCTION__,
-				BCM_RPC_TP_DNGL_BULKEP_MPS, BCM_RPC_TP_DNGL_ZLP_PAD));
-
-			bcm_rpc_tp_buf_pad(rpcb, b, BCM_RPC_TP_DNGL_ZLP_PAD);
-		}
-
-
-	lb = PKTTONATIVE(rpcb->osh, b);
-	/* send through data endpoint */
-	if ((err = chained->funcs->xmit(rpcb->ctx, chained, lb)) != 0) {
-		RPC_TP_ERR(("%s: xmit failed; free pkt %p\n", __FUNCTION__, lb));
-		rpcb->txerr_cnt++;
-		lb_free(lb);
-	} else {
-		rpcb->tx_cnt++;
-
-		/* give pkt ownership to usb driver, decrement the counter */
-		rpcb->buf_cnt_inuse -= pktsegcnt(rpcb->osh, b);
-	}
-
-	return err;
-}
-
-void
-bcm_rpc_tp_dump(rpc_tp_info_t *rpcb)
-{
-	printf("\nRPC_TP_RTE:\n");
-	printf("bufalloc %d(buf_cnt_inuse %d) tx %d(txerr %d) rx %d(rxdrop %d)\n",
-		rpcb->bufalloc, rpcb->buf_cnt_inuse, rpcb->tx_cnt, rpcb->txerr_cnt,
-		rpcb->rx_cnt, rpcb->rxdrop_cnt);
-
-	printf("tx_flowctrl_cnt %d tx_flowctrl_status %d hwm %d lwm %d hit_hiwm #%d segcnt %d\n",
-		rpcb->tx_flowctl_cnt, rpcb->tx_flowcontrolled,
-		rpcb->tx_q_flowctl_hiwm, rpcb->tx_q_flowctl_lowm, rpcb->tx_q_flowctl_highwm_cnt,
-		rpcb->tx_q_flowctl_segcnt);
-
-	printf("tp_dngl_agg sf_limit %d bytes_limit %d aggregation 0x%x lazy %d\n",
-		rpcb->tp_dngl_agg_sframes_limit, rpcb->tp_dngl_agg_bytes_max,
-		rpcb->tp_dngl_aggregation, rpcb->tp_dngl_agg_lazy);
-	printf("agg counter: chain %u, sf %u, bytes %u byte-per-chain %u, bypass %u noagg %u\n",
-		rpcb->tp_dngl_agg_cnt_chain, rpcb->tp_dngl_agg_cnt_sf,
-		rpcb->tp_dngl_agg_cnt_bytes,
-	        (rpcb->tp_dngl_agg_cnt_chain == 0) ?
-	        0 : CEIL(rpcb->tp_dngl_agg_cnt_bytes, (rpcb->tp_dngl_agg_cnt_chain)),
-		rpcb->tp_dngl_agg_cnt_pass, rpcb->tp_dngl_agg_cnt_noagg);
-
-	printf("\n");
-
-	printf("tp_dngl_deagg chain %u sf %u bytes %u clone %u badsflen %u badfmt %u\n",
-		rpcb->tp_dngl_deagg_cnt_chain, rpcb->tp_dngl_deagg_cnt_sf,
-		rpcb->tp_dngl_deagg_cnt_bytes, rpcb->tp_dngl_deagg_cnt_clone,
-		rpcb->tp_dngl_deagg_cnt_badsflen, rpcb->tp_dngl_deagg_cnt_badfmt);
-	printf("tp_dngl_deagg byte-per-chain %u passthrough %u\n",
-		(rpcb->tp_dngl_deagg_cnt_chain == 0) ?
-		0 : rpcb->tp_dngl_deagg_cnt_bytes/rpcb->tp_dngl_deagg_cnt_chain,
-		rpcb->tp_dngl_deagg_cnt_pass);
-}
-
-/* Buffer manipulation, LEN + RPC_header + body */
-uint
-bcm_rpc_buf_tp_header_len(rpc_tp_info_t * rpc_th)
-{
-	return BCM_RPC_TP_ENCAP_LEN;
-}
-
-rpc_buf_t *
-bcm_rpc_tp_buf_alloc(rpc_tp_info_t * rpc_th, int len)
-{
-	rpc_buf_t * b;
-	size_t tp_len = len + BCM_RPC_TP_ENCAP_LEN;
-	size_t padlen;
-
-#ifdef BCMUSBDEV
-	padlen = MAX(BCM_RPC_TP_DNGL_TOTLEN_BAD_PAD, BCM_RPC_TP_DNGL_ZLP_PAD);
-	padlen = ROUNDUP(padlen, sizeof(int));
-#else
-	padlen = 0;
-#endif /* BCMUSBDEV */
-
-	/* get larger packet with  padding which might be required due to USB ZLP */
-	b = (rpc_buf_t*)PKTGET(rpc_th->osh, tp_len + padlen, FALSE);
-
-	if (b != NULL) {
-		rpc_th->bufalloc++;
-		rpc_th->buf_cnt_inuse++;
-		/* set the len back to tp_len */
-		bcm_rpc_buf_len_set(rpc_th, b, tp_len);
-		PKTPULL(rpc_th->osh, b, BCM_RPC_TP_ENCAP_LEN);
-	}
-
-	return b;
-}
-
-void
-bcm_rpc_tp_buf_free(rpc_tp_info_t * rpc_th, rpc_buf_t *b)
-{
-	ASSERT(b);
-
-	rpc_th->buf_cnt_inuse -= pktsegcnt(rpc_th->osh, b);
-	PKTFREE(rpc_th->osh, b, FALSE);
-}
-
-int
-bcm_rpc_buf_len_get(rpc_tp_info_t * rpc_th, rpc_buf_t* b)
-{
-	return PKTLEN(rpc_th->osh, b);
-}
-
-int
-bcm_rpc_buf_totlen_get(rpc_tp_info_t * rpc_th, rpc_buf_t* b)
-{
-	int totlen = 0;
-	for (; b; b = (rpc_buf_t *) PKTNEXT(rpc_th->osh, b)) {
-		totlen += PKTLEN(rpc_th->osh, b);
-	}
-	return totlen;
-}
-
-int
-bcm_rpc_buf_len_set(rpc_tp_info_t * rpc_th, rpc_buf_t* b, uint len)
-{
-	PKTSETLEN(rpc_th->osh, b, len);
-	return 0;
-}
-
-unsigned char*
-bcm_rpc_buf_data(rpc_tp_info_t * rpc_th, rpc_buf_t* b)
-{
-	return PKTDATA(rpc_th->osh, b);
-}
-
-unsigned char*
-bcm_rpc_buf_push(rpc_tp_info_t * rpc_th, rpc_buf_t* b, uint bytes)
-{
-	return PKTPUSH(rpc_th->osh, b, bytes);
-}
-
-unsigned char*
-bcm_rpc_buf_pull(rpc_tp_info_t * rpc_th, rpc_buf_t* b, uint bytes)
-{
-	return PKTPULL(rpc_th->osh, b, bytes);
-}
-
-rpc_buf_t *
-bcm_rpc_buf_next_get(rpc_tp_info_t * rpcb, rpc_buf_t* b)
-{
-	return (rpc_buf_t *)PKTLINK(b);
-}
-
-void
-bcm_rpc_buf_next_set(rpc_tp_info_t * rpcb, rpc_buf_t* b, rpc_buf_t *nextb)
-{
-	PKTSETLINK(b, nextb);
-}
-
-void
-bcm_rpc_tp_buf_cnt_adjust(rpc_tp_info_t * rpcb, int adjust)
-{
-	rpcb->buf_cnt_inuse += adjust;
-}
-
-void
-bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t *rpc_th, void *ctx, rpc_txflowctl_cb_t cb)
-{
-	rpc_th->txflowctl_cb = cb;
-	rpc_th->txflowctl_ctx = ctx;
-}
-
-void
-bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t *rpc_th)
-{
-	rpc_th->txflowctl_cb = NULL;
-	rpc_th->txflowctl_ctx = NULL;
-}
-
-void
-bcm_rpc_tp_txq_wm_set(rpc_tp_info_t *rpc_th, uint8 hiwm, uint8 lowm)
-{
-	rpc_th->tx_q_flowctl_hiwm = hiwm;
-	rpc_th->tx_q_flowctl_lowm = lowm;
-}
-
-void
-bcm_rpc_tp_txq_wm_get(rpc_tp_info_t *rpc_th, uint8 *hiwm, uint8 *lowm)
-{
-	*hiwm = rpc_th->tx_q_flowctl_hiwm;
-	*lowm = rpc_th->tx_q_flowctl_lowm;
-}
-
-void
-bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, uint8 sf, uint16 bytes)
-{
-	rpc_th->tp_dngl_agg_sframes_limit = sf;
-	rpc_th->tp_dngl_agg_bytes_max = bytes;
-}
-
-void
-bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, uint8 *sf, uint16 *bytes)
-{
-	*sf = rpc_th->tp_dngl_agg_sframes_limit;
-	*bytes = rpc_th->tp_dngl_agg_bytes_max;
-}
-
-/* TP aggregation: set, init, agg, append, close, flush */
-static void
-bcm_rpc_tp_dngl_agg_initstate(rpc_tp_info_t * rpcb)
-{
-	rpcb->tp_dngl_agg_p = NULL;
-	rpcb->tp_dngl_agg_ptail = NULL;
-	rpcb->tp_dngl_agg_sframes = 0;
-	rpcb->tp_dngl_agg_bytes = 0;
-	rpcb->tp_dngl_agg_txpending = 0;
-}
-
-static int
-bcm_rpc_tp_dngl_agg(rpc_tp_info_t *rpcb, rpc_buf_t *b)
-{
-	uint totlen;
-	uint pktlen;
-	int err;
-
-	ASSERT(rpcb->tp_dngl_aggregation);
-
-	pktlen = bcm_rpc_buf_len_get(rpcb, b);
-
-	totlen = pktlen + rpcb->tp_dngl_agg_bytes;
-
-	if ((totlen > rpcb->tp_dngl_agg_bytes_max) ||
-		(rpcb->tp_dngl_agg_sframes + 1 > rpcb->tp_dngl_agg_sframes_limit)) {
-
-		RPC_TP_AGG(("bcm_rpc_tp_dngl_agg: terminte TP agg for tpbyte %d or txframe %d\n",
-			rpcb->tp_dngl_agg_bytes_max,	rpcb->tp_dngl_agg_sframes_limit));
-
-		/* release current agg, continue with new agg */
-		err = bcm_rpc_tp_dngl_agg_release(rpcb);
-	} else {
-		err = 0;
-	}
-
-	bcm_rpc_tp_dngl_agg_append(rpcb, b);
-
-	/* if the new frag is also already over the agg limit, release it */
-	if (pktlen >= rpcb->tp_dngl_agg_bytes_max) {
-		int new_err;
-		new_err = bcm_rpc_tp_dngl_agg_release(rpcb);
-		if (!err)
-			err = new_err;
-	}
-
-	return err;
-}
-
-/*
- *  tp_dngl_agg_p points to the header lbuf, tp_dngl_agg_ptail points to the tail lbuf
- *
- * The TP agg format typically will be below
- *   | TP header(len) | subframe1 rpc_header | subframe1 data |
- *     | TP header(len) | subframe2 rpc_header | subframe2 data |
- *          ...
- *           | TP header(len) | subframeN rpc_header | subframeN data |
- * no padding
-*/
-static void
-bcm_rpc_tp_dngl_agg_append(rpc_tp_info_t * rpcb, rpc_buf_t *b)
-{
-	uint tp_len = bcm_rpc_buf_len_get(rpcb, b);
-
-	if (rpcb->tp_dngl_agg_p == NULL) {
-
-		rpcb->tp_dngl_agg_p = rpcb->tp_dngl_agg_ptail = b;
-
-	} else {
-		/* chain the pkts at the end of current one */
-		ASSERT(rpcb->tp_dngl_agg_ptail != NULL);
-
-		PKTSETNEXT(rpcb->osh, rpcb->tp_dngl_agg_ptail, b);
-		rpcb->tp_dngl_agg_ptail = b;
-	}
-
-	rpcb->tp_dngl_agg_sframes++;
-	rpcb->tp_dngl_agg_bytes += tp_len;
-
-	RPC_TP_AGG(("%s, tp_len %d tot %d, sframe %d\n", __FUNCTION__, tp_len,
-		rpcb->tp_dngl_agg_bytes, rpcb->tp_dngl_agg_sframes));
-}
-
-static int
-bcm_rpc_tp_dngl_agg_release(rpc_tp_info_t * rpcb)
-{
-	int err;
-	rpc_buf_t *b;
-
-	if (rpcb->tp_dngl_agg_p == NULL) {	/* no aggregation formed */
-		return 0;
-	}
-
-	RPC_TP_AGG(("%s, send %d, sframe %d\n", __FUNCTION__,
-		rpcb->tp_dngl_agg_bytes, rpcb->tp_dngl_agg_sframes));
-
-	b = rpcb->tp_dngl_agg_p;
-	rpcb->tp_dngl_agg_cnt_chain++;
-	rpcb->tp_dngl_agg_cnt_sf += rpcb->tp_dngl_agg_sframes;
-	rpcb->tp_dngl_agg_cnt_bytes += rpcb->tp_dngl_agg_bytes;
-	if (rpcb->tp_dngl_agg_sframes == 1)
-		rpcb->tp_dngl_agg_cnt_noagg++;
-
-	bcm_rpc_tp_dngl_agg_initstate(rpcb);
-
-	rpcb->tp_dngl_agg_txpending++;
-
-	if (rpcb->tx_flowctl) {
-		bcm_rpc_tp_buf_send_enq(rpcb, b);
-		err = 0;
-	} else {
-		err = bcm_rpc_tp_buf_send_internal(rpcb, b, USBDEV_BULK_IN_EP1);
-	}
-
-	if (err != 0) {
-		RPC_TP_ERR(("bcm_rpc_tp_dngl_agg_release: send err!!!\n"));
-		/* ASSERT(0) */
-	}
-
-	return err;
-}
-
-static void
-bcm_rpc_tp_dngl_agg_flush(rpc_tp_info_t * rpcb)
-{
-	/* toss the chained buffer */
-	if (rpcb->tp_dngl_agg_p)
-		bcm_rpc_tp_buf_free(rpcb, rpcb->tp_dngl_agg_p);
-
-	bcm_rpc_tp_dngl_agg_initstate(rpcb);
-}
-
-void
-bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, uint32 reason, bool set)
-{
-	static int i = 0;
-
-	if (set) {
-		RPC_TP_AGG(("%s: agg start\n", __FUNCTION__));
-
-		mboolset(rpcb->tp_dngl_aggregation, reason);
-
-	} else if (rpcb->tp_dngl_aggregation) {
-
-		RPC_TP_AGG(("%s: agg end\n", __FUNCTION__));
-
-		if (i > 0) {
-			i--;
-			return;
-		} else {
-			i = rpcb->tp_dngl_agg_lazy;
-		}
-
-		mboolclr(rpcb->tp_dngl_aggregation, reason);
-		if (!rpcb->tp_dngl_aggregation)
-			bcm_rpc_tp_dngl_agg_release(rpcb);
-	}
-}
-
-void
-bcm_rpc_tp_msglevel_set(rpc_tp_info_t *rpc_th, uint8 msglevel, bool high_low)
-{
-	ASSERT(high_low == FALSE);
-	tp_level_bmac = msglevel;
-}
diff -Nuar merlin-bkp/shared/dbus.c merlin-new/shared/dbus.c
--- merlin-bkp/shared/dbus.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/dbus.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2401 +0,0 @@
-/*
- * Dongle BUS interface for USB, SDIO, SPI, etc.
- *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
- * 
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * $Id: dbus.c 422800 2013-09-10 01:12:42Z $
- */
-
-
-#include "osl.h"
-#include "dbus.h"
-#include <bcmutils.h>
-#if defined(BCM_DNGL_EMBEDIMAGE)
-#include <bcmsrom_fmt.h>
-#include <trxhdr.h>
-#include <usbrdl.h>
-#include <bcmendian.h>
-#include <zutil.h>
-#include <sbpcmcia.h>
-#include <bcmnvram.h>
-#include <bcmdevs.h>
-#elif defined(BCM_REQUEST_FW)
-#include <bcmsrom_fmt.h>
-#include <trxhdr.h>
-#include <usbrdl.h>
-#include <bcmendian.h>
-#include <sbpcmcia.h>
-#include <bcmnvram.h>
-#include <bcmdevs.h>
-#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) */
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-#include <linux/usb.h>
-#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
-
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-/* zlib file format field ids etc from gzio.c */
-#define Z_DEFLATED     8
-#define ASCII_FLAG     0x01 /* bit 0 set: file probably ascii text */
-#define HEAD_CRC       0x02 /* bit 1 set: header CRC present */
-#define EXTRA_FIELD    0x04 /* bit 2 set: extra field present */
-#define ORIG_NAME      0x08 /* bit 3 set: original file name present */
-#define COMMENT        0x10 /* bit 4 set: file comment present */
-#define RESERVED       0xE0 /* bits 5..7: reserved */
-
-#ifdef WL_FW_DECOMP
-#define UNZIP_ENAB(info)  1
-#else
-#define UNZIP_ENAB(info)  0
-
-#ifdef inflateInit2
-#undef inflateInit2
-#define inflateInit2(a, b)  Z_ERRNO
-#endif
-#define inflate(a, b)       Z_STREAM_ERROR
-#define inflateEnd(a)       do {} while (0)
-#define crc32(a, b, c)      -1
-#define free(a)             do {} while (0)
-#endif /* WL_FW_DECOMP */
-
-#elif defined(BCM_REQUEST_FW)
-#ifndef VARS_MAX
-#define VARS_MAX            8192
-#endif
-#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) */
-
-/* This private structure dbus_info_t is also declared in dbus_usb_linux.c.
- * All the fields must be consistent in both declarations.
- */
-typedef struct dbus_info {
-	dbus_pub_t   pub; /* MUST BE FIRST */
-
-	void        *cbarg;
-	dbus_callbacks_t *cbs;
-	void        *bus_info;
-	dbus_intf_t *drvintf;
-	uint8       *fw;
-	int         fwlen;
-	uint32      errmask;
-	int         rx_low_watermark;
-	int         tx_low_watermark;
-	bool        txoff;
-	bool        txoverride;
-	bool        rxoff;
-	bool        tx_timer_ticking;
-
-	dbus_irbq_t *rx_q;
-	dbus_irbq_t *tx_q;
-
-#ifdef BCMDBG
-	int         *txpend_q_hist;
-	int         *rxpend_q_hist;
-#endif /* BCMDBG */
-#ifdef EHCI_FASTPATH_RX
-	atomic_t    rx_outstanding;
-#endif
-	uint8        *nvram;
-	int          nvram_len;
-	uint8        *image;  /* buffer for combine fw and nvram */
-	int          image_len;
-	uint8        *orig_fw;
-	int          origfw_len;
-	int          decomp_memsize;
-	dbus_extdl_t extdl;
-	int          nvram_nontxt;
-#if defined(BCM_REQUEST_FW)
-	void         *firmware;
-	void         *nvfile;
-#endif
-} dbus_info_t;
-
-struct exec_parms {
-	union {
-		/* Can consolidate same params, if need be, but this shows
-		 * group of parameters per function
-		 */
-		struct {
-			dbus_irbq_t  *q;
-			dbus_irb_t   *b;
-		} qenq;
-
-		struct {
-			dbus_irbq_t  *q;
-		} qdeq;
-	};
-};
-
-#define EXEC_RXLOCK(info, fn, a) \
-	info->drvintf->exec_rxlock(dbus_info->bus_info, ((exec_cb_t)fn), ((struct exec_parms *) a))
-
-#define EXEC_TXLOCK(info, fn, a) \
-	info->drvintf->exec_txlock(dbus_info->bus_info, ((exec_cb_t)fn), ((struct exec_parms *) a))
-
-/*
- * Callbacks common for all BUS
- */
-static void dbus_if_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb);
-static void dbus_if_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status);
-static void dbus_if_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status);
-static void dbus_if_errhandler(void *handle, int err);
-static void dbus_if_ctl_complete(void *handle, int type, int status);
-static void dbus_if_state_change(void *handle, int state);
-static void *dbus_if_pktget(void *handle, uint len, bool send);
-static void dbus_if_pktfree(void *handle, void *p, bool send);
-static struct dbus_irb *dbus_if_getirb(void *cbarg, bool send);
-static void dbus_if_rxerr_indicate(void *handle, bool on);
-
-static dbus_intf_callbacks_t dbus_intf_cbs = {
-	dbus_if_send_irb_timeout,
-	dbus_if_send_irb_complete,
-	dbus_if_recv_irb_complete,
-	dbus_if_errhandler,
-	dbus_if_ctl_complete,
-	dbus_if_state_change,
-	NULL,   /* isr */
-	NULL,   /* dpc */
-	NULL,   /* watchdog */
-	dbus_if_pktget,
-	dbus_if_pktfree,
-	dbus_if_getirb,
-	dbus_if_rxerr_indicate
-};
-
-/*
- * Need global for probe() and disconnect() since
- * attach() is not called at probe and detach()
- * can be called inside disconnect()
- */
-static dbus_intf_t     *g_busintf = NULL;
-static probe_cb_t      probe_cb = NULL;
-static disconnect_cb_t disconnect_cb = NULL;
-static void            *probe_arg = NULL;
-static void            *disc_arg = NULL;
-
-#if defined(BCM_REQUEST_FW)
-int8 *nonfwnvram   = NULL; /* stand-alone multi-nvram given with driver load */
-int nonfwnvramlen  = 0;
-#endif /* #if defined(BCM_REQUEST_FW) */
-static void* q_enq(dbus_irbq_t *q, dbus_irb_t *b);
-static void* q_enq_exec(struct exec_parms *args);
-static dbus_irb_t*q_deq(dbus_irbq_t *q);
-static void* q_deq_exec(struct exec_parms *args);
-static int dbus_tx_timer_init(dbus_info_t *dbus_info);
-static int dbus_tx_timer_start(dbus_info_t *dbus_info, uint timeout);
-static int dbus_tx_timer_stop(dbus_info_t *dbus_info);
-static int dbus_irbq_init(dbus_info_t *dbus_info, dbus_irbq_t *q, int nq, int size_irb);
-static int dbus_irbq_deinit(dbus_info_t *dbus_info, dbus_irbq_t *q, int size_irb);
-static int dbus_rxirbs_fill(dbus_info_t *dbus_info);
-static int dbus_send_irb(dbus_pub_t *pub, uint8 *buf, int len, void *pkt, void *info);
-static void dbus_disconnect(void *handle);
-static void *dbus_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen);
-
-#if (defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW))
-#if defined(BCM_REQUEST_FW)
-extern char * dngl_firmware;
-extern unsigned int dngl_fwlen;
-#endif  /* #if defined(BCM_REQUEST_FW) */
-static int dbus_get_nvram(dbus_info_t *dbus_info);
-static int dbus_jumbo_nvram(dbus_info_t *dbus_info);
-static int dbus_otp(dbus_info_t *dbus_info, uint16 *boardtype, uint16 *boardrev);
-static int dbus_select_nvram(dbus_info_t *dbus_info, int8 *jumbonvram, int jumbolen,
-uint16 boardtype, uint16 boardrev, int8 **nvram, int *nvram_len);
-#ifndef BCM_REQUEST_FW
-static int dbus_zlib_decomp(dbus_info_t *dbus_info);
-extern void *dbus_zlib_calloc(int num, int size);
-extern void dbus_zlib_free(void *ptr);
-#endif
-#endif /* (defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)) */
-
-/* function */
-void
-dbus_flowctrl_tx(void *dbi, bool on)
-{
-	dbus_info_t *dbus_info = dbi;
-
-	if (dbus_info == NULL)
-		return;
-
-	DBUSTRACE(("%s on %d\n", __FUNCTION__, on));
-
-	if (dbus_info->txoff == on)
-		return;
-
-	dbus_info->txoff = on;
-
-	if (dbus_info->cbs && dbus_info->cbs->txflowcontrol)
-		dbus_info->cbs->txflowcontrol(dbus_info->cbarg, on);
-}
-
-static void
-dbus_if_rxerr_indicate(void *handle, bool on)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-
-	DBUSTRACE(("%s, on %d\n", __FUNCTION__, on));
-
-	if (dbus_info == NULL)
-		return;
-
-	if (dbus_info->txoverride == on)
-		return;
-
-	dbus_info->txoverride = on;
-
-	if (!on)
-		dbus_rxirbs_fill(dbus_info);
-
-}
-
-/*
- * q_enq()/q_deq() are executed with protection
- * via exec_rxlock()/exec_txlock()
- */
-static void*
-q_enq(dbus_irbq_t *q, dbus_irb_t *b)
-{
-	ASSERT(q->tail != b);
-	ASSERT(b->next == NULL);
-	b->next = NULL;
-	if (q->tail) {
-		q->tail->next = b;
-		q->tail = b;
-	} else
-		q->head = q->tail = b;
-
-	q->cnt++;
-
-	return b;
-}
-
-static void*
-q_enq_exec(struct exec_parms *args)
-{
-	return q_enq(args->qenq.q, args->qenq.b);
-}
-
-static dbus_irb_t*
-q_deq(dbus_irbq_t *q)
-{
-	dbus_irb_t *b;
-
-	b = q->head;
-	if (b) {
-		q->head = q->head->next;
-		b->next = NULL;
-
-		if (q->head == NULL)
-			q->tail = q->head;
-
-		q->cnt--;
-	}
-	return b;
-}
-
-static void*
-q_deq_exec(struct exec_parms *args)
-{
-	return q_deq(args->qdeq.q);
-}
-
-static int
-dbus_tx_timer_init(dbus_info_t *dbus_info)
-{
-	if (dbus_info && dbus_info->drvintf && dbus_info->drvintf->tx_timer_init)
-		return dbus_info->drvintf->tx_timer_init(dbus_info->bus_info);
-	else
-		return DBUS_ERR;
-}
-
-static int
-dbus_tx_timer_start(dbus_info_t *dbus_info, uint timeout)
-{
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (dbus_info->tx_timer_ticking)
-		return DBUS_OK;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->tx_timer_start) {
-		if (dbus_info->drvintf->tx_timer_start(dbus_info->bus_info, timeout) == DBUS_OK) {
-			dbus_info->tx_timer_ticking = TRUE;
-			return DBUS_OK;
-		}
-	}
-
-	return DBUS_ERR;
-}
-
-static int
-dbus_tx_timer_stop(dbus_info_t *dbus_info)
-{
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (!dbus_info->tx_timer_ticking)
-		return DBUS_OK;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->tx_timer_stop) {
-		if (dbus_info->drvintf->tx_timer_stop(dbus_info->bus_info) == DBUS_OK) {
-			dbus_info->tx_timer_ticking = FALSE;
-			return DBUS_OK;
-		}
-	}
-
-	return DBUS_ERR;
-}
-
-static int
-dbus_irbq_init(dbus_info_t *dbus_info, dbus_irbq_t *q, int nq, int size_irb)
-{
-	int i;
-	dbus_irb_t *irb;
-
-	ASSERT(q);
-	ASSERT(dbus_info);
-
-	for (i = 0; i < nq; i++) {
-		/* MALLOC dbus_irb_tx or dbus_irb_rx, but cast to simple dbus_irb_t linkedlist */
-		irb = (dbus_irb_t *) MALLOC(dbus_info->pub.osh, size_irb);
-		if (irb == NULL) {
-			ASSERT(irb);
-			return DBUS_ERR;
-		}
-		bzero(irb, size_irb);
-
-		/* q_enq() does not need to go through EXEC_xxLOCK() during init() */
-		q_enq(q, irb);
-	}
-
-	return DBUS_OK;
-}
-
-static int
-dbus_irbq_deinit(dbus_info_t *dbus_info, dbus_irbq_t *q, int size_irb)
-{
-	dbus_irb_t *irb;
-
-	ASSERT(q);
-	ASSERT(dbus_info);
-
-	/* q_deq() does not need to go through EXEC_xxLOCK()
-	 * during deinit(); all callbacks are stopped by this time
-	 */
-	while ((irb = q_deq(q)) != NULL) {
-		MFREE(dbus_info->pub.osh, irb, size_irb);
-	}
-
-	if (q->cnt)
-		DBUSERR(("deinit: q->cnt=%d > 0\n", q->cnt));
-	return DBUS_OK;
-}
-
-static int
-dbus_rxirbs_fill(dbus_info_t *dbus_info)
-{
-	int err = DBUS_OK;
-
-#ifdef EHCI_FASTPATH_RX
-	while (atomic_read(&dbus_info->rx_outstanding) < 100)
-	{
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-		/* NOCOPY force new packet allocation */
-		optimize_submit_rx_request(&dbus_info->pub, 1, NULL, NULL);
-#else
-		/* Copy mode - allocate own buffer to be reused */
-		void *buf = MALLOC(dbus_info->pub.osh, 4000); /* usbos_info->rxbuf_len */
-		optimize_submit_rx_request(&dbus_info->pub, 1, NULL, buf);
-#endif /* BCM_RPC_NOCOPY || BCM_RPC_RXNOCOPY */
-		atomic_inc(&dbus_info->rx_outstanding);
-	}
-#else /* EHCI_FASTPATH_RX */
-
-	dbus_irb_rx_t *rxirb;
-	struct exec_parms args;
-
-	ASSERT(dbus_info);
-	if (dbus_info->pub.busstate != DBUS_STATE_UP) {
-		DBUSERR(("dbus_rxirbs_fill: DBUS not up \n"));
-		return DBUS_ERR;
-	} else if (!dbus_info->drvintf || (dbus_info->drvintf->recv_irb == NULL)) {
-		/* Lower edge bus interface does not support recv_irb().
-		 * No need to pre-submit IRBs in this case.
-		 */
-		return DBUS_ERR;
-	}
-
-	/* The dongle recv callback is freerunning without lock. So multiple callbacks(and this
-	 *  refill) can run in parallel. While the rxoff condition is triggered outside,
-	 *  below while loop has to check and abort posting more to avoid RPC rxq overflow.
-	 */
-	args.qdeq.q = dbus_info->rx_q;
-	while ((!dbus_info->rxoff) &&
-	       (rxirb = (EXEC_RXLOCK(dbus_info, q_deq_exec, &args))) != NULL) {
-		err = dbus_info->drvintf->recv_irb(dbus_info->bus_info, rxirb);
-		if (err == DBUS_ERR_RXDROP) {
-			/* Add the the free rxirb back to the queue
-			 * and wait till later
-			 */
-			bzero(rxirb, sizeof(dbus_irb_rx_t));
-			args.qenq.q = dbus_info->rx_q;
-			args.qenq.b = (dbus_irb_t *) rxirb;
-			EXEC_RXLOCK(dbus_info, q_enq_exec, &args);
-			break;
-		}
-	}
-#endif /* EHCI_FASTPATH_RX */
-	return err;
-}
-
-void
-dbus_flowctrl_rx(dbus_pub_t *pub, bool on)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if (dbus_info == NULL)
-		return;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info->rxoff == on)
-		return;
-
-	dbus_info->rxoff = on;
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		if (!on) {
-			/* post more irbs, resume rx if necessary */
-			dbus_rxirbs_fill(dbus_info);
-			if (dbus_info && dbus_info->drvintf->recv_resume) {
-				dbus_info->drvintf->recv_resume(dbus_info->bus_info);
-			}
-		} else {
-			/* ??? cancell posted irbs first */
-
-			if (dbus_info && dbus_info->drvintf->recv_stop) {
-				dbus_info->drvintf->recv_stop(dbus_info->bus_info);
-			}
-		}
-	}
-
-}
-
-/* Handles both sending of a buffer or a pkt */
-static int
-dbus_send_irb(dbus_pub_t *pub, uint8 *buf, int len, void *pkt, void *info)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_OK;
-#ifndef EHCI_FASTPATH_TX
-	dbus_irb_tx_t *txirb = NULL;
-	int txirb_pending;
-	struct exec_parms args;
-#endif /* EHCI_FASTPATH_TX */
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-#ifdef EHCI_FASTPATH_TX
-		struct ehci_qtd *qtd;
-		int token = EHCI_QTD_SET_CERR(3);
-		int len;
-
-		ASSERT(buf == NULL); /* Not handled */
-		ASSERT(pkt != NULL);
-
-		qtd = optimize_ehci_qtd_alloc(GFP_KERNEL);
-
-		if (qtd == NULL)
-			return DBUS_ERR;
-
-		len = PKTLEN(pub->osh, pkt);
-
-		len = ROUNDUP(len, sizeof(uint32));
-
-#ifdef BCMDBG
-		/* The packet length is already padded to not to be multiple of 512 bytes
-		 * in bcm_rpc_tp_buf_send_internal(), so it should not be 512*N bytes here.
-		 */
-		if (len % EHCI_BULK_PACKET_SIZE == 0) {
-			DBUSERR(("%s: len = %d (multiple of 512 bytes)\n", __FUNCTION__, len));
-			return DBUS_ERR_TXDROP;
-		}
-#endif /* BCMDBG */
-
-		optimize_qtd_fill_with_rpc(pub, 0, qtd, pkt, token, len);
-		err = optimize_submit_async(qtd, 0);
-
-		if (err) {
-			optimize_ehci_qtd_free(qtd);
-			err = DBUS_ERR_TXDROP;
-		}
-
-#else
-		args.qdeq.q = dbus_info->tx_q;
-		if (dbus_info->drvintf)
-			txirb = EXEC_TXLOCK(dbus_info, q_deq_exec, &args);
-
-		if (txirb == NULL) {
-			DBUSERR(("Out of tx dbus_bufs\n"));
-			return DBUS_ERR;
-		}
-
-		if (pkt != NULL) {
-			txirb->pkt = pkt;
-			txirb->buf = NULL;
-			txirb->len = 0;
-		} else if (buf != NULL) {
-			txirb->pkt = NULL;
-			txirb->buf = buf;
-			txirb->len = len;
-		} else {
-			ASSERT(0); /* Should not happen */
-		}
-		txirb->info = info;
-		txirb->arg = NULL;
-		txirb->retry_count = 0;
-
-		if (dbus_info->drvintf && dbus_info->drvintf->send_irb) {
-			err = dbus_info->drvintf->send_irb(dbus_info->bus_info, txirb);
-			if (err == DBUS_ERR_TXDROP) {
-				/* tx fail and no completion routine to clean up, reclaim irb NOW */
-				DBUSERR(("%s: send_irb failed, status = %d\n", __FUNCTION__, err));
-				bzero(txirb, sizeof(dbus_irb_tx_t));
-				args.qenq.q = dbus_info->tx_q;
-				args.qenq.b = (dbus_irb_t *) txirb;
-				EXEC_TXLOCK(dbus_info, q_enq_exec, &args);
-			} else {
-				dbus_tx_timer_start(dbus_info, DBUS_TX_TIMEOUT_INTERVAL);
-				txirb_pending = dbus_info->pub.ntxq - dbus_info->tx_q->cnt;
-#ifdef BCMDBG
-				dbus_info->txpend_q_hist[txirb_pending]++;
-#endif /* BCMDBG */
-				if (txirb_pending > (dbus_info->tx_low_watermark * 3)) {
-					dbus_flowctrl_tx(dbus_info, TRUE);
-				}
-			}
-		}
-#endif /* EHCI_FASTPATH_TX */
-	} else {
-		err = DBUS_ERR_TXFAIL;
-		DBUSTRACE(("%s: bus down, send_irb failed\n", __FUNCTION__));
-	}
-
-	return err;
-}
-
-#if (defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW))
-static int
-check_file(osl_t *osh, unsigned char *headers)
-{
-	struct trx_header *trx;
-	int actual_len = -1;
-
-	/* Extract trx header */
-	trx = (struct trx_header *)headers;
-	if (ltoh32(trx->magic) != TRX_MAGIC) {
-		printf("Error: trx bad hdr %x\n", ltoh32(trx->magic));
-		return -1;
-	}
-
-	headers += SIZEOF_TRX(trx);
-
-	/* TRX V1: get firmwre len */
-	/* TRX V2: get firmwre len and DSG/CFG lengths */
-	if (ltoh32(trx->flag_version) & TRX_UNCOMP_IMAGE) {
-		actual_len = ltoh32(trx->offsets[TRX_OFFSETS_DLFWLEN_IDX]) +
-		                     SIZEOF_TRX(trx);
-#ifdef BCMTRXV2
-		if (ISTRX_V2(trx)) {
-			actual_len += ltoh32(trx->offsets[TRX_OFFSETS_DSG_LEN_IDX]) +
-				ltoh32(trx->offsets[TRX_OFFSETS_CFG_LEN_IDX]);
-		}
-#endif
-		return actual_len;
-	}  else {
-		printf("compressed image\n");
-	}
-	return -1;
-
-}
-
-static int
-dbus_jumbo_nvram(dbus_info_t *dbus_info)
-{
-	int8 *nvram = NULL;
-	int nvram_len = 0;
-	int ret = DBUS_OK;
-	uint16 boardrev = 0xFFFF;
-	uint16 boardtype = 0xFFFF;
-
-	/* read the otp for boardrev & boardtype
-	* if boardtype/rev are present in otp
-	* select nvram data for that boardtype/rev
-	*/
-	dbus_otp(dbus_info, &boardtype, &boardrev);
-
-	ret = dbus_select_nvram(dbus_info, dbus_info->extdl.vars, dbus_info->extdl.varslen,
-		boardtype, boardrev, &nvram, &nvram_len);
-
-	if (ret == DBUS_JUMBO_BAD_FORMAT)
-			return DBUS_ERR_NVRAM;
-	else if (ret == DBUS_JUMBO_NOMATCH &&
-		(boardtype != 0xFFFF || boardrev  != 0xFFFF)) {
-			DBUSERR(("No matching NVRAM for boardtype 0x%02x boardrev 0x%02x\n",
-				boardtype, boardrev));
-			return DBUS_ERR_NVRAM;
-	}
-	dbus_info->nvram = nvram;
-	dbus_info->nvram_len =  nvram_len;
-
-	return DBUS_OK;
-}
-
-static int
-dbus_get_nvram(dbus_info_t *dbus_info)
-{
-	int len, i;
-	struct trx_header *hdr;
-	int	actual_fwlen;
-	uint32 img_offset = 0;
-
-	dbus_info->nvram_len = 0;
-	if (dbus_info->extdl.varslen) {
-		if (DBUS_OK != dbus_jumbo_nvram(dbus_info))
-			return DBUS_ERR_NVRAM;
-		DBUSERR(("NVRAM %d bytes downloaded\n", dbus_info->nvram_len));
-	}
-#if defined(BCM_REQUEST_FW)
-	else if (nonfwnvram) {
-		dbus_info->nvram = nonfwnvram;
-		dbus_info->nvram_len = nonfwnvramlen;
-		DBUSERR(("NVRAM %d bytes downloaded\n", dbus_info->nvram_len));
-	}
-#endif
-	if (dbus_info->nvram) {
-		uint8 nvram_words_pad = 0;
-		/* Validate the format/length etc of the file */
-		if ((actual_fwlen = check_file(dbus_info->pub.osh, dbus_info->fw)) <= 0) {
-			DBUSERR(("%s: bad firmware format!\n", __FUNCTION__));
-			return DBUS_ERR_NVRAM;
-		}
-
-		if (!dbus_info->nvram_nontxt) {
-			/* host supplied nvram could be in .txt format
-			* with all the comments etc...
-			*/
-			dbus_info->nvram_len = process_nvram_vars(dbus_info->nvram,
-				dbus_info->nvram_len);
-		}
-		if (dbus_info->nvram_len % 4)
-			nvram_words_pad = 4 - dbus_info->nvram_len % 4;
-
-		len = actual_fwlen + dbus_info->nvram_len + nvram_words_pad;
-#ifdef USBAP
-		/* Allocate virtual memory otherwise it might fail on embedded systems */
-		dbus_info->image = VMALLOC(dbus_info->pub.osh, len);
-#else
-		dbus_info->image = MALLOC(dbus_info->pub.osh, len);
-#endif /* USBAP */
-		dbus_info->image_len = len;
-		if (dbus_info->image == NULL) {
-			DBUSERR(("%s: malloc failed!\n", __FUNCTION__));
-			return DBUS_ERR_NVRAM;
-		}
-		hdr = (struct trx_header *)dbus_info->fw;
-		/* Step1: Copy trx header + firmwre */
-		img_offset = SIZEOF_TRX(hdr) + hdr->offsets[TRX_OFFSETS_DLFWLEN_IDX];
-		bcopy(dbus_info->fw, dbus_info->image, img_offset);
-		/* Step2: Copy NVRAM + pad */
-		bcopy(dbus_info->nvram, (uint8 *)(dbus_info->image + img_offset),
-			dbus_info->nvram_len);
-		img_offset += dbus_info->nvram_len;
-		if (nvram_words_pad) {
-			bzero(&dbus_info->image[img_offset],
-				nvram_words_pad);
-			img_offset += nvram_words_pad;
-		}
-#ifdef BCMTRXV2
-		/* Step3: Copy DSG/CFG for V2 */
-		if (ISTRX_V2(hdr) &&
-			(hdr->offsets[TRX_OFFSETS_DSG_LEN_IDX] ||
-			hdr->offsets[TRX_OFFSETS_CFG_LEN_IDX])) {
-
-			bcopy(dbus_info->fw + SIZEOF_TRX(hdr) +
-				hdr->offsets[TRX_OFFSETS_DLFWLEN_IDX] +
-				hdr->offsets[TRX_OFFSETS_NVM_LEN_IDX],
-				dbus_info->image + img_offset,
-				hdr->offsets[TRX_OFFSETS_DSG_LEN_IDX] +
-				hdr->offsets[TRX_OFFSETS_CFG_LEN_IDX]);
-
-			img_offset += hdr->offsets[TRX_OFFSETS_DSG_LEN_IDX] +
-				hdr->offsets[TRX_OFFSETS_CFG_LEN_IDX];
-		}
-#endif /* BCMTRXV2 */
-		/* Step4: update TRX header for nvram size */
-		hdr = (struct trx_header *)dbus_info->image;
-		hdr->len = htol32(len);
-		/* Pass the actual fw len */
-		hdr->offsets[TRX_OFFSETS_NVM_LEN_IDX] =
-			htol32(dbus_info->nvram_len + nvram_words_pad);
-		/* Calculate CRC over header */
-		hdr->crc32 = hndcrc32((uint8 *)&hdr->flag_version,
-			SIZEOF_TRX(hdr) - OFFSETOF(struct trx_header, flag_version),
-			CRC32_INIT_VALUE);
-
-		/* Calculate CRC over data */
-		for (i = SIZEOF_TRX(hdr); i < len; ++i)
-				hdr->crc32 = hndcrc32((uint8 *)&dbus_info->image[i], 1, hdr->crc32);
-		hdr->crc32 = htol32(hdr->crc32);
-	} else {
-		dbus_info->image = dbus_info->fw;
-		dbus_info->image_len = (uint32)dbus_info->fwlen;
-	}
-	return DBUS_OK;
-}
-
-static int
-dbus_do_download(dbus_info_t *dbus_info)
-{
-	int err = DBUS_OK;
-#ifndef BCM_REQUEST_FW
-	int decomp_override = 0;
-#endif
-#ifdef BCM_REQUEST_FW
-	uint16 boardrev = 0xFFFF, boardtype = 0xFFFF;
-	int8 *temp_nvram;
-	int temp_len;
-#endif
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-	if (dbus_info->extdl.fw && (dbus_info->extdl.fwlen > 0)) {
-		dbus_info->fw = (uint8 *)dbus_info->extdl.fw;
-		dbus_info->fwlen = dbus_info->extdl.fwlen;
-		DBUSERR(("dbus_do_download: using override firmmware %d bytes\n",
-			dbus_info->fwlen));
-	} else
-		dbus_bus_fw_get(dbus_info->bus_info, &dbus_info->fw, &dbus_info->fwlen,
-			&decomp_override);
-
-	if (!dbus_info->fw) {
-		DBUSERR(("dbus_do_download: devid 0x%x / %d not supported\n",
-			dbus_info->pub.attrib.devid, dbus_info->pub.attrib.devid));
-		return DBUS_ERR;
-	}
-#elif defined(BCM_REQUEST_FW)
-	dbus_info->firmware = dbus_get_fw_nvfile(dbus_info->pub.attrib.devid,
-		&dbus_info->fw, &dbus_info->fwlen, DBUS_FIRMWARE, 0, 0);
-	if (!dbus_info->firmware)
-		return DBUS_ERR;
-#endif /* defined(BCM_DNGL_EMBEDIMAGE) */
-
-	dbus_info->image = dbus_info->fw;
-	dbus_info->image_len = (uint32)dbus_info->fwlen;
-
-#ifndef BCM_REQUEST_FW
-	if (UNZIP_ENAB(dbus_info) && !decomp_override) {
-		err = dbus_zlib_decomp(dbus_info);
-		if (err) {
-			DBUSERR(("dbus_attach: fw decompress fail %d\n", err));
-			return err;
-		}
-	}
-#endif
-
-#if defined(BCM_REQUEST_FW)
-	/* check if firmware is appended with nvram file */
-	err = dbus_otp(dbus_info, &boardtype, &boardrev);
-	/* check if nvram is provided as separte file */
-	nonfwnvram = NULL;
-	nonfwnvramlen = 0;
-	dbus_info->nvfile = dbus_get_fw_nvfile(dbus_info->pub.attrib.devid,
-		(void *)&temp_nvram, &temp_len, DBUS_NVFILE, boardtype, boardrev);
-	if (dbus_info->nvfile) {
-		int8 *tmp = MALLOC(dbus_info->pub.osh, temp_len);
-		if (tmp) {
-			bcopy(temp_nvram, tmp, temp_len);
-			nonfwnvram = tmp;
-			nonfwnvramlen = temp_len;
-		} else {
-			err = DBUS_ERR;
-			goto fail;
-		}
-	}
-#endif /* BCM_REQUEST_FW */
-
-	err = dbus_get_nvram(dbus_info);
-	if (err) {
-		DBUSERR(("dbus_do_download: fail to get nvram %d\n", err));
-		return err;
-	}
-
-	if (dbus_info->drvintf->dlstart && dbus_info->drvintf->dlrun) {
-		err = dbus_info->drvintf->dlstart(dbus_info->bus_info,
-			dbus_info->image, dbus_info->image_len);
-
-		if (err == DBUS_OK)
-			err = dbus_info->drvintf->dlrun(dbus_info->bus_info);
-	} else
-		err = DBUS_ERR;
-
-	if (dbus_info->nvram) {
-#ifdef USBAP
-		VFREE(dbus_info->pub.osh, dbus_info->image, dbus_info->image_len);
-#else
-		MFREE(dbus_info->pub.osh, dbus_info->image, dbus_info->image_len);
-#endif /* USBAP */
-		dbus_info->image = dbus_info->fw;
-		dbus_info->image_len = (uint32)dbus_info->fwlen;
-	}
-
-#ifndef BCM_REQUEST_FW
-	if (UNZIP_ENAB(dbus_info) && (!decomp_override) && dbus_info->orig_fw) {
-		MFREE(dbus_info->pub.osh, dbus_info->fw, dbus_info->decomp_memsize);
-		dbus_info->image = dbus_info->fw = dbus_info->orig_fw;
-		dbus_info->image_len = dbus_info->fwlen = dbus_info->origfw_len;
-	}
-#endif
-
-#if defined(BCM_REQUEST_FW)
-fail:
-	if (dbus_info->firmware)
-		dbus_release_fw_nvfile(dbus_info->firmware);
-	if (dbus_info->nvfile)
-		dbus_release_fw_nvfile(dbus_info->nvfile);
-	if (nonfwnvram) {
-		MFREE(dbus_info->pub.osh, nonfwnvram, nonfwnvramlen);
-		nonfwnvram = NULL;
-		nonfwnvramlen = 0;
-	}
-#endif
-	return err;
-}
-#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
-
-static void
-dbus_disconnect(void *handle)
-{
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (disconnect_cb)
-		disconnect_cb(disc_arg);
-}
-
-/*
- * This function is called when the sent irb timesout without a tx response status.
- * DBUS adds reliability by resending timedout irbs DBUS_TX_RETRY_LIMIT times.
- */
-static void
-dbus_if_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-
-	if ((dbus_info == NULL) || (dbus_info->drvintf == NULL) || (txirb == NULL)) {
-		return;
-	}
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	return;
-
-}
-
-static void BCMFASTPATH
-dbus_if_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-	int txirb_pending;
-	struct exec_parms args;
-	void *pktinfo;
-
-	if ((dbus_info == NULL) || (txirb == NULL)) {
-		return;
-	}
-
-	DBUSTRACE(("%s: status = %d\n", __FUNCTION__, status));
-
-	dbus_tx_timer_stop(dbus_info);
-
-	/* re-queue BEFORE calling send_complete which will assume that this irb
-	   is now available.
-	 */
-	pktinfo = txirb->info;
-	bzero(txirb, sizeof(dbus_irb_tx_t));
-	args.qenq.q = dbus_info->tx_q;
-	args.qenq.b = (dbus_irb_t *) txirb;
-	EXEC_TXLOCK(dbus_info, q_enq_exec, &args);
-
-	if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
-		if ((status == DBUS_OK) || (status == DBUS_ERR_NODEVICE)) {
-			if (dbus_info->cbs && dbus_info->cbs->send_complete)
-				dbus_info->cbs->send_complete(dbus_info->cbarg, pktinfo,
-					status);
-
-			if (status == DBUS_OK) {
-				txirb_pending = dbus_info->pub.ntxq - dbus_info->tx_q->cnt;
-				if (txirb_pending)
-					dbus_tx_timer_start(dbus_info, DBUS_TX_TIMEOUT_INTERVAL);
-				if ((txirb_pending < dbus_info->tx_low_watermark) &&
-					dbus_info->txoff && !dbus_info->txoverride) {
-					dbus_flowctrl_tx(dbus_info, OFF);
-				}
-			}
-		} else {
-			DBUSERR(("%s: %d WARNING freeing orphan pkt %p\n", __FUNCTION__, __LINE__,
-				pktinfo));
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC)
-			if (pktinfo)
-				if (dbus_info->cbs && dbus_info->cbs->send_complete)
-					dbus_info->cbs->send_complete(dbus_info->cbarg, pktinfo,
-						status);
-#else
-			dbus_if_pktfree(dbus_info, (void*)pktinfo, TRUE);
-#endif /* defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC) */
-		}
-	} else {
-		DBUSERR(("%s: %d WARNING freeing orphan pkt %p\n", __FUNCTION__, __LINE__,
-			pktinfo));
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC)
-		if (pktinfo)
-			if (dbus_info->cbs && dbus_info->cbs->send_complete)
-				dbus_info->cbs->send_complete(dbus_info->cbarg, pktinfo,
-					status);
-#else
-		dbus_if_pktfree(dbus_info, (void*)pktinfo, TRUE);
-#endif /* defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) defined(BCM_RPC_TOC) */
-	}
-}
-
-static void BCMFASTPATH
-dbus_if_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-	int rxirb_pending;
-	struct exec_parms args;
-
-	if ((dbus_info == NULL) || (rxirb == NULL)) {
-		return;
-	}
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
-		if (status == DBUS_OK) {
-			if ((rxirb->buf != NULL) && (rxirb->actual_len > 0)) {
-				if (dbus_info->cbs && dbus_info->cbs->recv_buf)
-					dbus_info->cbs->recv_buf(dbus_info->cbarg, rxirb->buf,
-					rxirb->actual_len);
-			} else if (rxirb->pkt != NULL) {
-				if (dbus_info->cbs && dbus_info->cbs->recv_pkt)
-					dbus_info->cbs->recv_pkt(dbus_info->cbarg, rxirb->pkt);
-			} else {
-				ASSERT(0); /* Should not happen */
-			}
-
-			rxirb_pending = dbus_info->pub.nrxq - dbus_info->rx_q->cnt - 1;
-#ifdef BCMDBG
-			dbus_info->rxpend_q_hist[rxirb_pending]++;
-#endif /* BCMDBG */
-			if ((rxirb_pending <= dbus_info->rx_low_watermark) &&
-				!dbus_info->rxoff) {
-				DBUSTRACE(("Low watermark so submit more %d <= %d \n",
-					dbus_info->rx_low_watermark, rxirb_pending));
-
-				dbus_rxirbs_fill(dbus_info);
-			} else if (dbus_info->rxoff)
-				DBUSTRACE(("rx flow controlled. not filling more. cut_rxq=%d\n",
-					dbus_info->rx_q->cnt));
-		} else if (status == DBUS_ERR_NODEVICE) {
-			DBUSERR(("%s: %d status = %d, buf %p\n", __FUNCTION__, __LINE__, status,
-				rxirb->buf));
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-			if (rxirb->buf) {
-				PKTFRMNATIVE(dbus_info->pub.osh, rxirb->buf);
-				PKTFREE(dbus_info->pub.osh, rxirb->buf, FALSE);
-			}
-#endif /* BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPY || BCM_RPC_TOC */
-		} else {
-			DBUSERR(("%s: %d status = %d, buf %p\n", __FUNCTION__, __LINE__, status,
-				rxirb->buf));
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-			if (rxirb->buf) {
-				PKTFRMNATIVE(dbus_info->pub.osh, rxirb->buf);
-				PKTFREE(dbus_info->pub.osh, rxirb->buf, FALSE);
-			}
-#endif /* BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPY || BCM_RPC_TOC */
-		}
-	} else {
-		DBUSTRACE(("%s: DBUS down, ignoring recv callback. buf %p\n", __FUNCTION__,
-			rxirb->buf));
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-		if (rxirb->buf) {
-			PKTFRMNATIVE(dbus_info->pub.osh, rxirb->buf);
-			PKTFREE(dbus_info->pub.osh, rxirb->buf, FALSE);
-		}
-#endif /* BCM_RPC_NOCOPY || BCM_RPC_TXNOCOPY || BCM_RPC_TOC */
-	}
-
-	bzero(rxirb, sizeof(dbus_irb_rx_t));
-	args.qenq.q = dbus_info->rx_q;
-	args.qenq.b = (dbus_irb_t *) rxirb;
-	EXEC_RXLOCK(dbus_info, q_enq_exec, &args);
-}
-
-static void
-dbus_if_errhandler(void *handle, int err)
-{
-	dbus_info_t *dbus_info = handle;
-	uint32 mask = 0;
-
-	if (dbus_info == NULL)
-		return;
-
-	switch (err) {
-		case DBUS_ERR_TXFAIL:
-			dbus_info->pub.stats.tx_errors++;
-			mask |= ERR_CBMASK_TXFAIL;
-			break;
-		case DBUS_ERR_TXDROP:
-			dbus_info->pub.stats.tx_dropped++;
-			mask |= ERR_CBMASK_TXFAIL;
-			break;
-		case DBUS_ERR_RXFAIL:
-			dbus_info->pub.stats.rx_errors++;
-			mask |= ERR_CBMASK_RXFAIL;
-			break;
-		case DBUS_ERR_RXDROP:
-			dbus_info->pub.stats.rx_dropped++;
-			mask |= ERR_CBMASK_RXFAIL;
-			break;
-		default:
-			break;
-	}
-
-	if (dbus_info->cbs && dbus_info->cbs->errhandler && (dbus_info->errmask & mask))
-		dbus_info->cbs->errhandler(dbus_info->cbarg, err);
-}
-
-static void
-dbus_if_ctl_complete(void *handle, int type, int status)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-
-	if (dbus_info == NULL)
-		return;
-
-	if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
-		if (dbus_info->cbs && dbus_info->cbs->ctl_complete)
-			dbus_info->cbs->ctl_complete(dbus_info->cbarg, type, status);
-	}
-}
-
-static void
-dbus_if_state_change(void *handle, int state)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-	int old_state;
-
-	if (dbus_info == NULL)
-		return;
-
-	if (dbus_info->pub.busstate == state)
-		return;
-	old_state = dbus_info->pub.busstate;
-	if (state == DBUS_STATE_DISCONNECT) {
-		DBUSERR(("DBUS disconnected\n"));
-	}
-
-	DBUSTRACE(("dbus state change from %d to to %d\n", old_state, state));
-
-	/* Don't update state if it's PnP firmware re-download */
-	if (state != DBUS_STATE_PNP_FWDL)
-		dbus_info->pub.busstate = state;
-	else
-		dbus_flowctrl_rx(handle, FALSE);
-	if (state == DBUS_STATE_SLEEP)
-		dbus_flowctrl_rx(handle, TRUE);
-	if ((old_state  == DBUS_STATE_SLEEP) && (state == DBUS_STATE_UP)) {
-		dbus_rxirbs_fill(dbus_info);
-		dbus_flowctrl_rx(handle, FALSE);
-	}
-
-	if (dbus_info->cbs && dbus_info->cbs->state_change)
-		dbus_info->cbs->state_change(dbus_info->cbarg, state);
-}
-
-static void *
-dbus_if_pktget(void *handle, uint len, bool send)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-	void *p = NULL;
-
-	if (dbus_info == NULL)
-		return NULL;
-
-	if (dbus_info->cbs && dbus_info->cbs->pktget)
-		p = dbus_info->cbs->pktget(dbus_info->cbarg, len, send);
-	else
-		ASSERT(0);
-
-	return p;
-}
-
-static void
-dbus_if_pktfree(void *handle, void *p, bool send)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) handle;
-
-	if (dbus_info == NULL)
-		return;
-
-	if (dbus_info->cbs && dbus_info->cbs->pktfree)
-		dbus_info->cbs->pktfree(dbus_info->cbarg, p, send);
-	else
-		ASSERT(0);
-}
-
-static struct dbus_irb*
-dbus_if_getirb(void *cbarg, bool send)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) cbarg;
-	struct exec_parms args;
-	struct dbus_irb *irb;
-
-	if ((dbus_info == NULL) || (dbus_info->pub.busstate != DBUS_STATE_UP))
-		return NULL;
-
-	if (send == TRUE) {
-		args.qdeq.q = dbus_info->tx_q;
-		irb = EXEC_TXLOCK(dbus_info, q_deq_exec, &args);
-	} else {
-		args.qdeq.q = dbus_info->rx_q;
-		irb = EXEC_RXLOCK(dbus_info, q_deq_exec, &args);
-	}
-
-	return irb;
-}
-
-static void *
-dbus_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen)
-{
-	if (probe_cb) {
-		disc_arg = probe_cb(probe_arg, desc, bustype, hdrlen);
-		return disc_arg;
-	}
-
-	return (void *)DBUS_ERR;
-}
-
-int
-dbus_register(int vid, int pid, probe_cb_t prcb,
-	disconnect_cb_t discb, void *prarg, void *param1, void *param2)
-{
-	int err;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	probe_cb = prcb;
-	disconnect_cb = discb;
-	probe_arg = prarg;
-
-	err = dbus_bus_register(vid, pid, dbus_probe,
-		dbus_disconnect, NULL, &g_busintf, param1, param2);
-
-	return err;
-}
-
-int
-dbus_deregister()
-{
-	int ret;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	ret = dbus_bus_deregister();
-	probe_cb = NULL;
-	disconnect_cb = NULL;
-	probe_arg = NULL;
-
-	return ret;
-
-}
-
-dbus_pub_t *
-dbus_attach(osl_t *osh, int rxsize, int nrxq, int ntxq, void *cbarg,
-	dbus_callbacks_t *cbs, dbus_extdl_t *extdl, struct shared_info *sh)
-{
-	dbus_info_t *dbus_info;
-	int err;
-
-	if ((g_busintf == NULL) || (g_busintf->attach == NULL) || (cbs == NULL) ||
-		(nrxq <= 0) || (ntxq <= 0))
-		return NULL;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	dbus_info = MALLOC(osh, sizeof(dbus_info_t));
-	if (dbus_info == NULL)
-		return NULL;
-
-	bzero(dbus_info, sizeof(dbus_info_t));
-
-	/* BUS-specific driver interface */
-	dbus_info->drvintf = g_busintf;
-	dbus_info->cbarg = cbarg;
-	dbus_info->cbs = cbs;
-
-	dbus_info->pub.sh = sh;
-	dbus_info->pub.osh = osh;
-	dbus_info->pub.rxsize = rxsize;
-
-#ifdef EHCI_FASTPATH_RX
-	atomic_set(&dbus_info->rx_outstanding, 0);
-#endif
-
-	dbus_info->pub.nrxq = nrxq;
-	dbus_info->rx_low_watermark = nrxq / 2;	/* keep enough posted rx urbs */
-	dbus_info->pub.ntxq = ntxq;
-	dbus_info->tx_low_watermark = ntxq / 4;	/* flow control when too many tx urbs posted */
-
-	dbus_info->tx_q = MALLOC(osh, sizeof(dbus_irbq_t));
-	if (dbus_info->tx_q == NULL)
-		goto error;
-	else {
-		bzero(dbus_info->tx_q, sizeof(dbus_irbq_t));
-		err = dbus_irbq_init(dbus_info, dbus_info->tx_q, ntxq, sizeof(dbus_irb_tx_t));
-		if (err != DBUS_OK)
-			goto error;
-	}
-
-	dbus_info->rx_q = MALLOC(osh, sizeof(dbus_irbq_t));
-	if (dbus_info->rx_q == NULL)
-		goto error;
-	else {
-		bzero(dbus_info->rx_q, sizeof(dbus_irbq_t));
-		err = dbus_irbq_init(dbus_info, dbus_info->rx_q, nrxq, sizeof(dbus_irb_rx_t));
-		if (err != DBUS_OK)
-			goto error;
-	}
-
-#ifdef BCMDBG
-	dbus_info->txpend_q_hist = MALLOC(osh, dbus_info->pub.ntxq * sizeof(int));
-	if (dbus_info->txpend_q_hist == NULL)
-		goto error;
-	bzero(dbus_info->txpend_q_hist, dbus_info->pub.ntxq * sizeof(int));
-
-	dbus_info->rxpend_q_hist = MALLOC(osh, dbus_info->pub.nrxq * sizeof(int));
-	if (dbus_info->rxpend_q_hist == NULL)
-		goto error;
-	bzero(dbus_info->rxpend_q_hist, dbus_info->pub.nrxq * sizeof(int));
-#endif /* BCMDBG */
-
-	dbus_info->bus_info = (void *)g_busintf->attach(&dbus_info->pub,
-		dbus_info, &dbus_intf_cbs);
-	if (dbus_info->bus_info == NULL)
-		goto error;
-
-	dbus_tx_timer_init(dbus_info);
-
-#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
-	/* Need to copy external image for re-download */
-	if (extdl && extdl->fw && (extdl->fwlen > 0)) {
-		dbus_info->extdl.fw = MALLOC(osh, extdl->fwlen);
-		if (dbus_info->extdl.fw) {
-			bcopy(extdl->fw, dbus_info->extdl.fw, extdl->fwlen);
-			dbus_info->extdl.fwlen = extdl->fwlen;
-		}
-	}
-
-	if (extdl && extdl->vars && (extdl->varslen > 0)) {
-		dbus_info->extdl.vars = MALLOC(osh, extdl->varslen);
-		if (dbus_info->extdl.vars) {
-			bcopy(extdl->vars, dbus_info->extdl.vars, extdl->varslen);
-			dbus_info->extdl.varslen = extdl->varslen;
-		}
-	}
-
-	if (dbus_info->drvintf->dlneeded) {
-		if (dbus_info->drvintf->dlneeded(dbus_info->bus_info)) {
-			err = dbus_do_download(dbus_info);
-			if (err == DBUS_ERR) {
-				DBUSERR(("attach: download failed=%d\n", err));
-				goto error;
-			}
-		}
-	}
-#endif /* defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
-
-	return (dbus_pub_t *)dbus_info;
-
-error:
-	dbus_detach((dbus_pub_t *)dbus_info);
-	return NULL;
-}
-
-void
-dbus_detach(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	osl_t *osh;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return;
-
-	dbus_tx_timer_stop(dbus_info);
-
-	osh = pub->osh;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->detach)
-		 dbus_info->drvintf->detach((dbus_pub_t *)dbus_info, dbus_info->bus_info);
-
-	if (dbus_info->tx_q) {
-		dbus_irbq_deinit(dbus_info, dbus_info->tx_q, sizeof(dbus_irb_tx_t));
-		MFREE(osh, dbus_info->tx_q, sizeof(dbus_irbq_t));
-		dbus_info->tx_q = NULL;
-	}
-
-	if (dbus_info->rx_q) {
-		dbus_irbq_deinit(dbus_info, dbus_info->rx_q, sizeof(dbus_irb_rx_t));
-		MFREE(osh, dbus_info->rx_q, sizeof(dbus_irbq_t));
-		dbus_info->rx_q = NULL;
-	}
-
-#ifdef BCMDBG
-	if (dbus_info->txpend_q_hist)
-		MFREE(osh, dbus_info->txpend_q_hist, dbus_info->pub.ntxq * sizeof(int));
-	if (dbus_info->rxpend_q_hist)
-		MFREE(osh, dbus_info->rxpend_q_hist, dbus_info->pub.nrxq * sizeof(int));
-#endif /* BCMDBG */
-
-	if (dbus_info->extdl.fw && (dbus_info->extdl.fwlen > 0)) {
-		MFREE(osh, dbus_info->extdl.fw, dbus_info->extdl.fwlen);
-		dbus_info->extdl.fw = NULL;
-		dbus_info->extdl.fwlen = 0;
-	}
-
-	if (dbus_info->extdl.vars && (dbus_info->extdl.varslen > 0)) {
-		MFREE(osh, dbus_info->extdl.vars, dbus_info->extdl.varslen);
-		dbus_info->extdl.vars = NULL;
-		dbus_info->extdl.varslen = 0;
-	}
-
-	MFREE(osh, dbus_info, sizeof(dbus_info_t));
-}
-
-int
-dbus_up(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_OK;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if ((dbus_info->pub.busstate == DBUS_STATE_DL_DONE) ||
-		(dbus_info->pub.busstate == DBUS_STATE_DOWN) ||
-		(dbus_info->pub.busstate == DBUS_STATE_SLEEP)) {
-		if (dbus_info->drvintf && dbus_info->drvintf->up) {
-			err = dbus_info->drvintf->up(dbus_info->bus_info);
-
-			if (err == DBUS_OK) {
-				dbus_rxirbs_fill(dbus_info);
-			}
-		}
-	} else
-		err = DBUS_ERR;
-
-	return err;
-}
-
-int
-dbus_down(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	dbus_tx_timer_stop(dbus_info);
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		if (dbus_info->drvintf && dbus_info->drvintf->down)
-			return dbus_info->drvintf->down(dbus_info->bus_info);
-	}
-
-	return DBUS_ERR;
-}
-
-int
-dbus_shutdown(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->shutdown)
-		return dbus_info->drvintf->shutdown(dbus_info->bus_info);
-
-	return DBUS_OK;
-}
-
-int
-dbus_stop(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		if (dbus_info->drvintf && dbus_info->drvintf->stop)
-			return dbus_info->drvintf->stop(dbus_info->bus_info);
-	}
-
-	return DBUS_ERR;
-}
-
-int
-dbus_send_buf(dbus_pub_t *pub, uint8 *buf, int len, void *info)
-{
-	return dbus_send_irb(pub, buf, len, NULL, info);
-}
-
-int
-dbus_send_pkt(dbus_pub_t *pub, void *pkt, void *info)
-{
-	return dbus_send_irb(pub, NULL, 0, pkt, info);
-}
-
-int
-dbus_send_ctl(dbus_pub_t *pub, uint8 *buf, int len)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		if (dbus_info->drvintf && dbus_info->drvintf->send_ctl)
-			return dbus_info->drvintf->send_ctl(dbus_info->bus_info, buf, len);
-	}
-
-	return DBUS_ERR;
-}
-
-int
-dbus_recv_ctl(dbus_pub_t *pub, uint8 *buf, int len)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if ((dbus_info == NULL) || (buf == NULL))
-		return DBUS_ERR;
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		if (dbus_info->drvintf && dbus_info->drvintf->recv_ctl)
-			return dbus_info->drvintf->recv_ctl(dbus_info->bus_info, buf, len);
-	}
-
-	return DBUS_ERR;
-}
-
-int
-dbus_recv_bulk(dbus_pub_t *pub, uint32 ep_idx)
-{
-#ifdef EHCI_FASTPATH_RX
-	/* 2nd bulk in not supported for EHCI_FASTPATH_RX */
-	ASSERT(0);
-#else
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	dbus_irb_rx_t *rxirb;
-	struct exec_parms args;
-	int status;
-
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	args.qdeq.q = dbus_info->rx_q;
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		if (dbus_info->drvintf && dbus_info->drvintf->recv_irb_from_ep) {
-			if ((rxirb = (EXEC_RXLOCK(dbus_info, q_deq_exec, &args))) != NULL) {
-				status = dbus_info->drvintf->recv_irb_from_ep(dbus_info->bus_info,
-					rxirb, ep_idx);
-				if (status == DBUS_ERR_RXDROP) {
-					bzero(rxirb, sizeof(dbus_irb_rx_t));
-					args.qenq.q = dbus_info->rx_q;
-					args.qenq.b = (dbus_irb_t *) rxirb;
-					EXEC_RXLOCK(dbus_info, q_enq_exec, &args);
-				}
-			}
-		}
-	}
-#endif /* EHCI_FASTPATH_RX */
-	return DBUS_ERR;
-}
-
-void *
-dbus_pktget(dbus_pub_t *pub, int len)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if ((dbus_info == NULL) || (len < 0))
-		return NULL;
-
-	return PKTGET(dbus_info->pub.osh, len, TRUE);
-}
-
-void
-dbus_pktfree(dbus_pub_t *pub, void* pkt)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if ((dbus_info == NULL) || (pkt == NULL))
-		return;
-
-	PKTFREE(dbus_info->pub.osh, pkt, TRUE);
-}
-
-int
-dbus_get_stats(dbus_pub_t *pub, dbus_stats_t *stats)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if ((dbus_info == NULL) || (stats == NULL))
-		return DBUS_ERR;
-
-	bcopy(&dbus_info->pub.stats, stats, sizeof(dbus_stats_t));
-
-	return DBUS_OK;
-}
-
-int
-dbus_get_attrib(dbus_pub_t *pub, dbus_attrib_t *attrib)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-
-	if ((dbus_info == NULL) || (attrib == NULL))
-		return DBUS_ERR;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->get_attrib) {
-		err = dbus_info->drvintf->get_attrib(dbus_info->bus_info,
-		&dbus_info->pub.attrib);
-	}
-
-	bcopy(&dbus_info->pub.attrib, attrib, sizeof(dbus_attrib_t));
-	return err;
-}
-
-int
-dbus_get_device_speed(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	if (dbus_info == NULL)
-		return INVALID_SPEED;
-
-	return (dbus_info->pub.device_speed);
-}
-
-int
-dbus_set_config(dbus_pub_t *pub, dbus_config_t *config)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-
-	if ((dbus_info == NULL) || (config == NULL))
-		return DBUS_ERR;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->set_config) {
-		err = dbus_info->drvintf->set_config(dbus_info->bus_info,
-			config);
-
-		if ((config->config_id == DBUS_CONFIG_ID_TXRXQUEUE) &&
-			(!err) &&
-			(dbus_info->pub.busstate == DBUS_STATE_UP)) {
-			dbus_rxirbs_fill(dbus_info);
-		}
-	}
-
-	return err;
-}
-
-int
-dbus_get_config(dbus_pub_t *pub, dbus_config_t *config)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-
-	if ((dbus_info == NULL) || (config == NULL))
-		return DBUS_ERR;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->get_config) {
-		err = dbus_info->drvintf->get_config(dbus_info->bus_info,
-		config);
-	}
-
-	return err;
-}
-
-int
-dbus_set_errmask(dbus_pub_t *pub, uint32 mask)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_OK;
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	dbus_info->errmask = mask;
-	return err;
-}
-
-int
-dbus_pnp_resume(dbus_pub_t *pub, int *fw_reload)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-	bool fwdl = FALSE;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (dbus_info->pub.busstate == DBUS_STATE_UP) {
-		return DBUS_OK;
-	}
-
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-	if (dbus_info->drvintf->device_exists &&
-		dbus_info->drvintf->device_exists(dbus_info->bus_info)) {
-		if (dbus_info->drvintf->dlneeded) {
-			if (dbus_info->drvintf->dlneeded(dbus_info->bus_info)) {
-				err = dbus_do_download(dbus_info);
-				if (err == DBUS_OK) {
-					fwdl = TRUE;
-				}
-				if (dbus_info->pub.busstate == DBUS_STATE_DL_DONE)
-					dbus_up(&dbus_info->pub);
-			}
-		}
-	} else {
-		return DBUS_ERR;
-	}
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-	if (dbus_info->drvintf->pnp) {
-		err = dbus_info->drvintf->pnp(dbus_info->bus_info,
-			DBUS_PNP_RESUME);
-	}
-
-	if (dbus_info->drvintf->recv_needed) {
-		if (dbus_info->drvintf->recv_needed(dbus_info->bus_info)) {
-			/* Refill after sleep/hibernate */
-			dbus_rxirbs_fill(dbus_info);
-		}
-	}
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-	if (fwdl == TRUE) {
-		dbus_if_state_change(dbus_info, DBUS_STATE_PNP_FWDL);
-	}
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-	if (fw_reload)
-		*fw_reload = fwdl;
-
-	return err;
-}
-
-int
-dbus_pnp_sleep(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	dbus_tx_timer_stop(dbus_info);
-
-	if (dbus_info->drvintf && dbus_info->drvintf->pnp) {
-		err = dbus_info->drvintf->pnp(dbus_info->bus_info,
-			DBUS_PNP_SLEEP);
-	}
-
-	return err;
-}
-
-int
-dbus_pnp_disconnect(dbus_pub_t *pub)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	dbus_tx_timer_stop(dbus_info);
-
-	if (dbus_info->drvintf && dbus_info->drvintf->pnp) {
-		err = dbus_info->drvintf->pnp(dbus_info->bus_info,
-			DBUS_PNP_DISCONNECT);
-	}
-
-	return err;
-}
-
-int
-dbus_iovar_op(dbus_pub_t *pub, const char *name,
-	void *params, int plen, void *arg, int len, bool set)
-{
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-	int err = DBUS_ERR;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (dbus_info == NULL)
-		return DBUS_ERR;
-
-	if (dbus_info->drvintf && dbus_info->drvintf->iovar_op) {
-		err = dbus_info->drvintf->iovar_op(dbus_info->bus_info,
-			name, params, plen, arg, len, set);
-	}
-
-	return err;
-}
-
-#ifdef BCMDBG
-void
-dbus_hist_dump(dbus_pub_t *pub, struct bcmstrbuf *b)
-{
-	int i = 0, j = 0;
-	dbus_info_t *dbus_info = (dbus_info_t *) pub;
-
-	bcm_bprintf(b, "\nDBUS histogram\n");
-	bcm_bprintf(b, "txq\n");
-	for (i = 0; i < dbus_info->pub.ntxq; i++) {
-		if (dbus_info->txpend_q_hist[i]) {
-			bcm_bprintf(b, "%d: %d ", i, dbus_info->txpend_q_hist[i]);
-			j++;
-			if (j % 10 == 0) {
-				bcm_bprintf(b, "\n");
-			}
-		}
-	}
-
-	j = 0;
-	bcm_bprintf(b, "\nrxq\n");
-	for (i = 0; i < dbus_info->pub.nrxq; i++) {
-		if (dbus_info->rxpend_q_hist[i]) {
-			bcm_bprintf(b, "%d: %d ", i, dbus_info->rxpend_q_hist[i]);
-			j++;
-			if (j % 10 == 0) {
-				bcm_bprintf(b, "\n");
-			}
-		}
-	}
-	bcm_bprintf(b, "\n");
-
-	if (dbus_info->drvintf && dbus_info->drvintf->dump)
-		dbus_info->drvintf->dump(dbus_info->bus_info, b);
-}
-#endif /* BCMDBG */
-
-void *
-dhd_dbus_txq(const dbus_pub_t *pub)
-{
-	return NULL;
-}
-
-uint
-dhd_dbus_hdrlen(const dbus_pub_t *pub)
-{
-	return 0;
-}
-
-void *
-dbus_get_devinfo(dbus_pub_t *pub)
-{
-	return pub->dev_info;
-}
-
-#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
-
-static int
-dbus_otp(dbus_info_t *dbus_info, uint16 *boardtype, uint16 *boardrev)
-{
-	uint32 value = 0;
-	uint8 *cis;
-	uint16 *otpinfo;
-	uint32 i;
-	bool standard_cis = TRUE;
-	uint8 tup, tlen;
-	bool btype_present = FALSE;
-	bool brev_present = FALSE;
-	int ret;
-	int devid;
-	uint16 btype = 0;
-	uint16 brev = 0;
-	uint32 otp_size = 0, otp_addr = 0, otp_sw_rgn = 0;
-
-	if (dbus_info == NULL || dbus_info->drvintf == NULL ||
-		dbus_info->drvintf->readreg == NULL)
-		return DBUS_ERR;
-
-	devid = dbus_info->pub.attrib.devid;
-
-	if ((devid == BCM43234_CHIP_ID) || (devid == BCM43235_CHIP_ID) ||
-		(devid == BCM43236_CHIP_ID)) {
-
-		otp_size = BCM_OTP_SIZE_43236;
-		otp_sw_rgn = BCM_OTP_SW_RGN_43236;
-		otp_addr = BCM_OTP_ADDR_43236;
-
-	} else {
-		return DBUS_ERR_NVRAM;
-	}
-
-	cis = MALLOC(dbus_info->pub.osh, otp_size * 2);
-	if (cis == NULL)
-		return DBUS_ERR;
-
-	otpinfo = (uint16 *) cis;
-
-	for (i = 0; i < otp_size; i++) {
-
-		ret = dbus_info->drvintf->readreg(dbus_info->bus_info,
-			otp_addr + ((otp_sw_rgn + i) << 1), 2, &value);
-
-		if (ret != DBUS_OK) {
-			MFREE(dbus_info->pub.osh, cis, otp_size * 2);
-			return ret;
-		}
-		otpinfo[i] = (uint16) value;
-	}
-
-	for (i = 0; i < (otp_size << 1); ) {
-
-		if (standard_cis) {
-			tup = cis[i++];
-			if (tup == CISTPL_NULL || tup == CISTPL_END)
-				tlen = 0;
-			else
-				tlen = cis[i++];
-		} else {
-			if (cis[i] == CISTPL_NULL || cis[i] == CISTPL_END) {
-				tlen = 0;
-				tup = cis[i];
-			} else {
-				tlen = cis[i];
-				tup = CISTPL_BRCM_HNBU;
-			}
-			++i;
-		}
-
-		if (tup == CISTPL_END || (i + tlen) >= (otp_size << 1)) {
-			break;
-		}
-
-		switch (tup) {
-
-		case CISTPL_BRCM_HNBU:
-
-			switch (cis[i]) {
-
-			case HNBU_BOARDTYPE:
-
-				btype = (uint16) ((cis[i + 2] << 8) + cis[i + 1]);
-				btype_present = TRUE;
-				DBUSTRACE(("%s: HNBU_BOARDTYPE = 0x%2x\n", __FUNCTION__,
-					(uint32)btype));
-				break;
-
-			case HNBU_BOARDREV:
-
-				if (tlen == 2)
-					brev = (uint16) cis[i + 1];
-				else
-					brev = (uint16) ((cis[i + 2] << 8) + cis[i + 1]);
-				brev_present = TRUE;
-				DBUSTRACE(("%s: HNBU_BOARDREV =  0x%2x\n", __FUNCTION__,
-					(uint32)*boardrev));
-				break;
-
-			case HNBU_HNBUCIS:
-				DBUSTRACE(("%s: HNBU_HNBUCIS\n", __FUNCTION__));
-				tlen++;
-				standard_cis = FALSE;
-				break;
-			}
-			break;
-		}
-
-		i += tlen;
-	}
-
-	MFREE(dbus_info->pub.osh, cis, otp_size * 2);
-
-	if (btype_present == TRUE && brev_present == TRUE) {
-		*boardtype = btype;
-		*boardrev = brev;
-		DBUSERR(("otp boardtype = 0x%2x boardrev = 0x%2x\n",
-			*boardtype, *boardrev));
-
-		return DBUS_OK;
-	}
-	else
-		return DBUS_ERR;
-}
-
-static int
-dbus_select_nvram(dbus_info_t *dbus_info, int8 *jumbonvram, int jumbolen,
-uint16 boardtype, uint16 boardrev, int8 **nvram, int *nvram_len)
-{
-	/* Multi board nvram file format is contenation of nvram info with \r
-	*  The file format for two contatenated set is
-	*  \nBroadcom Jumbo Nvram file\nfirst_set\nsecond_set\nthird_set\n
-	*/
-	uint8 *nvram_start = NULL, *nvram_end = NULL;
-	uint8 *nvram_start_prev = NULL, *nvram_end_prev = NULL;
-	uint16 btype = 0, brev = 0;
-	int len  = 0;
-	char *field;
-
-	*nvram = NULL;
-	*nvram_len = 0;
-
-	if (strncmp(BCM_JUMBO_START, jumbonvram, strlen(BCM_JUMBO_START))) {
-		/* single nvram file in the native format */
-		DBUSTRACE(("%s: Non-Jumbo NVRAM File \n", __FUNCTION__));
-		*nvram = jumbonvram;
-		*nvram_len = jumbolen;
-		return DBUS_OK;
-	} else {
-		DBUSTRACE(("%s: Jumbo NVRAM File \n", __FUNCTION__));
-	}
-
-	/* sanity test the end of the config sets for proper ending */
-	if (jumbonvram[jumbolen - 1] != BCM_JUMBO_NVRAM_DELIMIT ||
-		jumbonvram[jumbolen - 2] != '\0') {
-		DBUSERR(("%s: Bad Jumbo NVRAM file format\n", __FUNCTION__));
-		return DBUS_JUMBO_BAD_FORMAT;
-	}
-
-	dbus_info->nvram_nontxt = DBUS_NVRAM_NONTXT;
-
-	nvram_start = jumbonvram;
-
-	while (*nvram_start != BCM_JUMBO_NVRAM_DELIMIT && len < jumbolen) {
-
-		/* consume the  first file info line
-		* \nBroadcom Jumbo Nvram file\nfile1\n ...
-		*/
-		len ++;
-		nvram_start ++;
-	}
-
-	nvram_end = nvram_start;
-
-	/* search for "boardrev=0xabcd" and "boardtype=0x1234" information in
-	* the concatenated nvram config files /sets
-	*/
-
-	while (len < jumbolen) {
-
-		if (*nvram_end == '\0') {
-			/* end of a config set is marked by multiple null characters */
-			len ++;
-			nvram_end ++;
-			DBUSTRACE(("%s: NULL chr len = %d char = 0x%x\n", __FUNCTION__,
-				len, *nvram_end));
-			continue;
-
-		} else if (*nvram_end == BCM_JUMBO_NVRAM_DELIMIT) {
-
-			/* config set delimiter is reached */
-			/* check if next config set is present or not
-			*  return  if next config is not present
-			*/
-
-			/* start search the next config set */
-			nvram_start_prev = nvram_start;
-			nvram_end_prev = nvram_end;
-
-			nvram_end ++;
-			nvram_start = nvram_end;
-			btype = brev = 0;
-			DBUSTRACE(("%s: going to next record len = %d "
-					"char = 0x%x \n", __FUNCTION__, len, *nvram_end));
-			len ++;
-			if (len >= jumbolen) {
-
-				*nvram = nvram_start_prev;
-				*nvram_len = (int)(nvram_end_prev - nvram_start_prev);
-
-				DBUSTRACE(("%s: no more len = %d nvram_end = 0x%p",
-					__FUNCTION__, len, nvram_end));
-
-				return DBUS_JUMBO_NOMATCH;
-
-			} else {
-				continue;
-			}
-
-		} else {
-
-			DBUSTRACE(("%s: config str = %s\n", __FUNCTION__, nvram_end));
-
-			if (bcmp(nvram_end, "boardtype", strlen("boardtype")) == 0) {
-
-				field = strchr(nvram_end, '=');
-				field++;
-				btype = (uint16)bcm_strtoul(field, NULL, 0);
-
-				DBUSTRACE(("%s: btype = 0x%x boardtype = 0x%x \n", __FUNCTION__,
-					btype, boardtype));
-			}
-
-			if (bcmp(nvram_end, "boardrev", strlen("boardrev")) == 0) {
-
-				field = strchr(nvram_end, '=');
-				field++;
-				brev = (uint16)bcm_strtoul(field, NULL, 0);
-
-				DBUSTRACE(("%s: brev = 0x%x boardrev = 0x%x \n", __FUNCTION__,
-					brev, boardrev));
-			}
-			if (btype == boardtype && brev == boardrev) {
-				/* locate nvram config set end - ie.find '\r' char */
-				while (*nvram_end != BCM_JUMBO_NVRAM_DELIMIT)
-					nvram_end ++;
-				*nvram = nvram_start;
-				*nvram_len = (int) (nvram_end - nvram_start);
-				DBUSTRACE(("found len = %d nvram_start = 0x%p "
-					"nvram_end = 0x%p\n", *nvram_len, nvram_start, nvram_end));
-				return DBUS_OK;
-			}
-
-			len += (strlen(nvram_end) + 1);
-			nvram_end += (strlen(nvram_end) + 1);
-		}
-	}
-	return DBUS_JUMBO_NOMATCH;
-}
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-/* store the global osh handle */
-static osl_t *osl_handle = NULL;
-
-/* this function is a combination of trx.c and bcmdl.c plus dbus adaptation */
-static int
-dbus_zlib_decomp(dbus_info_t *dbus_info)
-{
-
-	int method, flags, len, status;
-	unsigned int uncmp_len, uncmp_crc, dec_crc, crc_init;
-	struct trx_header *trx, *newtrx;
-	unsigned char *file = NULL;
-	unsigned char gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
-	z_stream d_stream;
-	unsigned char unused;
-	int actual_len = -1;
-	unsigned char *headers;
-	unsigned int trxhdrsize, nvramsize, decomp_memsize, i;
-
-	(void)actual_len;
-	(void)unused;
-	(void)crc_init;
-
-	osl_handle = dbus_info->pub.osh;
-	dbus_info->orig_fw = NULL;
-
-	headers = dbus_info->fw;
-	/* Extract trx header */
-	trx = (struct trx_header *)headers;
-	trxhdrsize = sizeof(struct trx_header);
-
-	if (ltoh32(trx->magic) != TRX_MAGIC) {
-		DBUSERR(("%s: Error: trx bad hdr %x\n", __FUNCTION__,
-			ltoh32(trx->magic)));
-		return -1;
-	}
-
-	headers += sizeof(struct trx_header);
-
-	if (ltoh32(trx->flag_version) & TRX_UNCOMP_IMAGE) {
-		actual_len = ltoh32(trx->offsets[TRX_OFFSETS_DLFWLEN_IDX]) +
-		                     sizeof(struct trx_header);
-		DBUSERR(("%s: not a compressed image\n", __FUNCTION__));
-		return 0;
-	} else {
-		/* Extract the gzip header info */
-		if ((*headers++ != gz_magic[0]) || (*headers++ != gz_magic[1])) {
-			DBUSERR(("%s: Error: gzip bad hdr\n", __FUNCTION__));
-			return -1;
-		}
-
-		method = (int) *headers++;
-		flags = (int) *headers++;
-
-		if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
-			DBUSERR(("%s: Error: gzip bad hdr not a Z_DEFLATED file\n", __FUNCTION__));
-			return -1;
-		}
-	}
-
-	/* Discard time, xflags and OS code: */
-	for (len = 0; len < 6; len++)
-		unused = *headers++;
-
-	if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
-		len = (uint32) *headers++;
-		len += ((uint32)*headers++)<<8;
-		/* len is garbage if EOF but the loop below will quit anyway */
-		while (len-- != 0) unused = *headers++;
-	}
-
-	if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
-		while (*headers++ && (*headers != 0));
-	}
-
-	if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
-		while (*headers++ && (*headers != 0));
-	}
-
-	if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
-		for (len = 0; len < 2; len++) unused = *headers++;
-	}
-
-	headers++;
-
-
-	/* create space for the uncompressed file */
-	/* the space is for trx header, uncompressed image  and nvram file */
-	/* with typical compression of 0.6, space double of firmware should be ok */
-
-	decomp_memsize = dbus_info->fwlen * 2;
-	dbus_info->decomp_memsize = decomp_memsize;
-	if (!(file = MALLOC(osl_handle, decomp_memsize))) {
-		DBUSERR(("%s: check_file : failed malloc\n", __FUNCTION__));
-		goto err;
-	}
-
-	bzero(file, decomp_memsize);
-
-	/* Initialise the decompression struct */
-	d_stream.next_in = NULL;
-	d_stream.avail_in = 0;
-	d_stream.next_out = NULL;
-	d_stream.avail_out = decomp_memsize - trxhdrsize;
-	d_stream.zalloc = (alloc_func)0;
-	d_stream.zfree = (free_func)0;
-	if (inflateInit2(&d_stream, -15) != Z_OK) {
-		DBUSERR(("%s: Err: inflateInit2\n", __FUNCTION__));
-		goto err;
-	}
-
-	/* Inflate the code */
-	d_stream.next_in = headers;
-	d_stream.avail_in = ltoh32(trx->len);
-	d_stream.next_out = (unsigned char*)(file + trxhdrsize);
-
-	status = inflate(&d_stream, Z_SYNC_FLUSH);
-
-	if (status != Z_STREAM_END)	{
-		DBUSERR(("%s: Error: decompression failed\n", __FUNCTION__));
-		goto err;
-	}
-
-	uncmp_crc = *d_stream.next_in++;
-	uncmp_crc |= *d_stream.next_in++<<8;
-	uncmp_crc |= *d_stream.next_in++<<16;
-	uncmp_crc |= *d_stream.next_in++<<24;
-
-	uncmp_len = *d_stream.next_in++;
-	uncmp_len |= *d_stream.next_in++<<8;
-	uncmp_len |= *d_stream.next_in++<<16;
-	uncmp_len |= *d_stream.next_in++<<24;
-
-	actual_len = (int) (d_stream.next_in - (unsigned char *)trx);
-
-	inflateEnd(&d_stream);
-
-	/* Do a CRC32 on the uncompressed data */
-	crc_init = crc32(0L, Z_NULL, 0);
-	dec_crc = crc32(crc_init, file + trxhdrsize, uncmp_len);
-
-	if (dec_crc != uncmp_crc) {
-		DBUSERR(("%s: decompression: bad crc check \n", __FUNCTION__));
-		goto err;
-	}
-	else {
-		DBUSTRACE(("%s: decompression: good crc check \n", __FUNCTION__));
-	}
-
-	/* rebuild the new trx header and calculate crc */
-	newtrx = (struct trx_header *)file;
-	newtrx->magic = trx->magic;
-	/* add the uncompressed image flag */
-	newtrx->flag_version = trx->flag_version;
-	newtrx->flag_version  |= htol32(TRX_UNCOMP_IMAGE);
-	newtrx->offsets[TRX_OFFSETS_DLFWLEN_IDX] = htol32(uncmp_len);
-	newtrx->offsets[TRX_OFFSETS_JUMPTO_IDX] = trx->offsets[TRX_OFFSETS_JUMPTO_IDX];
-	newtrx->offsets[TRX_OFFSETS_NVM_LEN_IDX] = trx->offsets[TRX_OFFSETS_NVM_LEN_IDX];
-
-	nvramsize = ltoh32(trx->offsets[TRX_OFFSETS_NVM_LEN_IDX]);
-
-	/* the original firmware has nvram file appended */
-	/* copy the nvram file to uncompressed firmware */
-
-	if (nvramsize) {
-		if (nvramsize + uncmp_len > decomp_memsize) {
-			DBUSERR(("%s: nvram cannot be accomodated\n", __FUNCTION__));
-			goto err;
-		}
-		bcopy(d_stream.next_in, &file[uncmp_len], nvramsize);
-		uncmp_len += nvramsize;
-	}
-
-	/* add trx header size to uncmp_len */
-	uncmp_len += trxhdrsize;
-	uncmp_len = ROUNDUP(uncmp_len, 4096);
-	newtrx->len	= htol32(uncmp_len);
-
-	/* Calculate CRC over header */
-	newtrx->crc32 = hndcrc32((uint8 *)&newtrx->flag_version,
-	sizeof(struct trx_header) - OFFSETOF(struct trx_header, flag_version),
-	CRC32_INIT_VALUE);
-
-	/* Calculate CRC over data */
-	for (i = trxhdrsize; i < (uncmp_len); ++i)
-				newtrx->crc32 = hndcrc32((uint8 *)&file[i], 1, newtrx->crc32);
-	newtrx->crc32 = htol32(newtrx->crc32);
-
-	dbus_info->orig_fw = dbus_info->fw;
-	dbus_info->origfw_len = dbus_info->fwlen;
-	dbus_info->image = dbus_info->fw = file;
-	dbus_info->image_len = dbus_info->fwlen = uncmp_len;
-
-	return 0;
-
-err:
-	if (file)
-		free(file);
-	return -1;
-}
-
-void *
-dbus_zlib_calloc(int num, int size)
-{
-	uint *ptr;
-	uint totalsize;
-
-	if (osl_handle == NULL)
-		return NULL;
-
-	totalsize = (num * (size + 1));
-
-	ptr  = MALLOC(osl_handle, totalsize);
-
-	if (ptr == NULL)
-		return NULL;
-	bzero(ptr, totalsize);
-
-	/* store the size in the first integer space */
-
-	ptr[0] = totalsize;
-
-	return ((void *) &ptr[1]);
-}
-
-void
-dbus_zlib_free(void *ptr)
-{
-	uint totalsize;
-	uchar *memptr = (uchar *)ptr;
-
-	if (ptr && osl_handle) {
-		memptr -= sizeof(uint);
-		totalsize = *(uint *) memptr;
-		MFREE(osl_handle, memptr, totalsize);
-	}
-}
-#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) */
-#endif /* #if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW) */
-
-
-#ifdef LINUX_EXTERNAL_MODULE_DBUS
-
-static int __init
-bcm_dbus_module_init(void)
-{
-	printf("Inserting bcm_dbus module \n");
-	return 0;
-}
-
-static void __exit
-bcm_dbus_module_exit(void)
-{
-	printf("Removing bcm_dbus module \n");
-	return;
-}
-
-EXPORT_SYMBOL(dbus_pnp_sleep);
-EXPORT_SYMBOL(dbus_register);
-EXPORT_SYMBOL(dbus_get_devinfo);
-#ifdef BCMDBG
-EXPORT_SYMBOL(dbus_hist_dump);
-#endif
-EXPORT_SYMBOL(dbus_detach);
-EXPORT_SYMBOL(dbus_get_attrib);
-EXPORT_SYMBOL(dbus_down);
-EXPORT_SYMBOL(dbus_pnp_resume);
-EXPORT_SYMBOL(dbus_set_config);
-EXPORT_SYMBOL(dbus_flowctrl_rx);
-EXPORT_SYMBOL(dbus_up);
-EXPORT_SYMBOL(dbus_get_device_speed);
-EXPORT_SYMBOL(dbus_send_pkt);
-EXPORT_SYMBOL(dbus_recv_ctl);
-EXPORT_SYMBOL(dbus_attach);
-EXPORT_SYMBOL(dbus_deregister);
-
-MODULE_LICENSE("GPL");
-
-module_init(bcm_dbus_module_init);
-module_exit(bcm_dbus_module_exit);
-
-#endif  /* #ifdef LINUX_EXTERNAL_MODULE_DBUS */
diff -Nuar merlin-bkp/shared/dbus_sdh.c merlin-new/shared/dbus_sdh.c
--- merlin-bkp/shared/dbus_sdh.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/dbus_sdh.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,6036 +0,0 @@
-/*
- * Dongle BUS interface
- * Common to all SDIO interface
- *
- * Copyright (C) 2013, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: dbus_sdh.c 419467 2013-08-21 09:19:48Z $
- */
-
-#include <typedefs.h>
-#include <osl.h>
-
-#include <bcmsdh.h>
-#include <bcmdefs.h>
-#include <bcmutils.h>
-#include <bcmendian.h>
-#include <bcmdevs.h>
-
-#include <siutils.h>
-#include <hndpmu.h>
-#include <hndsoc.h>
-#include <sbchipc.h>
-#include <sbhnddma.h>
-#include <bcmsrom.h>
-
-#include <sdio.h>
-#include <spid.h>
-#include <sbsdio.h>
-#include <sbsdpcmdev.h>
-#include <bcmsdpcm.h>
-
-#include <proto/ethernet.h>
-#include <proto/802.1d.h>
-#include <proto/802.11.h>
-#include <sdiovar.h>
-#include "dbus.h"
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-#ifdef EMBED_IMAGE_4325sd
-#include "rtecdc_4325sd.h"
-#endif /* EMBED_IMAGE_4325sd */
-#ifdef EMBED_IMAGE_4319sd
-#include "rtecdc_4319sd.h"
-#endif /* EMBED_IMAGE_4319sd */
-#ifdef EMBED_IMAGE_GENERIC
-#include "rtecdc.h"
-#endif
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-/* FIX: Some of these are brought in from dhdioctl.h.  We'll move
- * DHD-specific features/test code out of DBUS, but for now just don't
- * include dhdioctl.h.
- */
-#define DHD_IOCTL_MAXLEN	8192
-#ifdef SDTEST
-/* For pktgen iovar */
-typedef struct dhd_pktgen {
-	uint version;		/* To allow structure change tracking */
-	uint freq;		/* Max ticks between tx/rx attempts */
-	uint count;		/* Test packets to send/rcv each attempt */
-	uint print;		/* Print counts every <print> attempts */
-	uint total;		/* Total packets (or bursts) */
-	uint minlen;		/* Minimum length of packets to send */
-	uint maxlen;		/* Maximum length of packets to send */
-	uint numsent;		/* Count of test packets sent */
-	uint numrcvd;		/* Count of test packets received */
-	uint numfail;		/* Count of test send failures */
-	uint mode;		/* Test mode (type of test packets) */
-	uint stop;		/* Stop after this many tx failures */
-} dhd_pktgen_t;
-
-/* Version in case structure changes */
-#define DHD_PKTGEN_VERSION 2
-
-/* Type of test packets to use */
-#define DHD_PKTGEN_ECHO		1	/* Send echo requests */
-#define DHD_PKTGEN_SEND		2	/* Send discard packets */
-#define DHD_PKTGEN_RXBURST	3	/* Request dongle send N packets */
-#define DHD_PKTGEN_RECV		4	/* Continuous rx from continuous tx dongle */
-#endif /* SDTEST */
-
-#define IDLE_IMMEDIATE	(-1)	/* Enter idle immediately (no timeout) */
-/* Values for idleclock iovar: other values are the sd_divisor to use when idle */
-#define IDLE_ACTIVE	0	/* Do not request any SD clock change when idle */
-#define IDLE_STOP	(-1)	/* Request SD clock be stopped (and use SD1 mode) */
-
-#define PRIOMASK	7
-
-#define TXRETRIES	2	/* # of retries for tx frames */
-
-#define DHD_RXBOUND	50	/* Default for max rx frames in one scheduling */
-
-#define DHD_TXBOUND	20	/* Default for max tx frames in one scheduling */
-#define DHD_TXMINMAX	1	/* Max tx frames if rx still pending */
-
-#define MEMBLOCK    2048 /* Block size used for downloading of dongle image */
-#define MAX_DATA_BUF (32 * 1024)	/* which should be more than
-						* and to hold biggest glom possible
-						*/
-
-/* Packet alignment for most efficient SDIO (can change based on platform) */
-#ifndef SDALIGN
-#define SDALIGN	32
-#endif
-#if !ISPOWEROF2(SDALIGN)
-#error SDALIGN is not a power of 2!
-#endif
-
-/* Total length of frame header for dongle protocol */
-#define SDPCM_HDRLEN	(SDPCM_FRAMETAG_LEN + SDPCM_SWHEADER_LEN)
-#ifdef SDTEST
-#define SDPCM_RESERVE	(SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + SDALIGN)
-#else
-#define SDPCM_RESERVE	(SDPCM_HDRLEN + SDALIGN)
-#endif
-
-/* Space for header read, limit for data packets */
-#undef MAX_HDR_READ
-#define MAX_HDR_READ	32
-#define MAX_RX_DATASZ	2048
-
-/* Maximum milliseconds to wait for F2 to come up */
-#define DHD_WAIT_F2RDY	4000
-
-/* Value for ChipClockCSR during initial setup */
-#define DHD_INIT_CLKCTL1	(SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ)
-#define DHD_INIT_CLKCTL2	(SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_FORCE_ALP)
-
-/* Flags for SDH calls */
-#define F2SYNC	(SDIO_REQ_4BYTE | SDIO_REQ_FIXED)
-
-/* Packet free applicable unconditionally for sdio and sdspi.  Contional if
- * bufpool was present for gspi bus.
- */
-#define PKTFREE2()		if ((sdio_info->bus != SPI_BUS) || sdio_info->usebufpool) \
-					dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-
-typedef struct {
-	bool pending;
-	bool is_iovar;
-
-	union {
-		struct {
-			uint8 *buf;
-			int len;
-		} ctl;
-		struct {
-			const char *name;
-			void *params;
-			int plen;
-			void *arg;
-			int len;
-			bool set;
-		} iovar;
-	};
-} sdctl_info_t;
-
-typedef struct {
-	dbus_pub_t *pub; /* Must be first */
-
-	void *cbarg;
-	dbus_intf_callbacks_t *cbs;
-	dbus_intf_t *drvintf;
-	void *sdos_info;
-
-	/* FIX: Ported from dhd_info_t */
-	uint maxctl;            /* Max size rxctl request from proto to bus */
-	ulong rx_readahead_cnt; /* Number of packets where header read-ahead was used. */
-	ulong tx_realloc;       /* Number of tx packets we had to realloc for headroom */
-	uint32 tx_ctlerrs;
-	uint32 tx_ctlpkts;
-	uint32 rx_ctlerrs;
-	uint32 rx_ctlpkts;
-	bool up;                /* Driver up/down (to OS) */
-	bool dongle_reset;  /* TRUE = DEVRESET put dongle into reset */
-	uint8 wme_dp;   /* wme discard priority */
-
-	sdctl_info_t rxctl_req;
-	sdctl_info_t txctl_req;
-	bool sdlocked;
-
-	/* FIX: Ported from dhd_bus_t */
-	bcmsdh_info_t	*sdh;	/* Handle for BCMSDH calls */
-	si_t		*sih;	/* Handle for SI calls */
-	char		*vars;	/* Variables (from CIS and/or other) */
-	uint		varsz;	/* Size of variables buffer */
-
-	sdpcmd_regs_t	*regs;    /* Registers for SDIO core */
-	uint		sdpcmrev; /* SDIO core revision */
-	uint		armrev;	  /* CPU core revision */
-	uint		ramrev;	  /* SOCRAM core revision */
-	uint32		ramsize;  /* Size of RAM in SOCRAM (bytes) */
-	uint32		orig_ramsize;  /* Size of RAM in SOCRAM (bytes) */
-
-	uint32		bus;      /* gSPI or SDIO bus */
-	uint32		hostintmask;  /* Copy of Host Interrupt Mask */
-	uint32		intstatus; /* Intstatus bits (events) pending */
-	bool		dpc_sched; /* Indicates DPC schedule (intrpt rcvd) */
-	bool		fcstate;   /* State of dongle flow-control */
-
-	char		*firmware_path; /* module_param: path to firmware image */
-	char		*nvram_path; /* module_param: path to nvram vars file */
-
-	uint		blocksize; /* Block size of SDIO transfers */
-	uint		roundup; /* Max roundup limit */
-
-	struct pktq	txq;	/* Queue length used for flow-control */
-	uint8		flowcontrol;	/* per prio flow control bitmask */
-	uint8		tx_seq;	/* Transmit sequence number (next) */
-	uint8		tx_max;	/* Maximum transmit sequence allowed */
-
-	uint8		hdrbuf[MAX_HDR_READ + SDALIGN];
-	uint8		*rxhdr; /* Header of current rx frame (in hdrbuf) */
-	uint16		nextlen; /* Next Read Len from last header */
-	uint8		rx_seq;	/* Receive sequence number (expected) */
-	bool		rxskip;	/* Skip receive (awaiting NAK ACK) */
-
-	void		*glomd;	/* Packet containing glomming descriptor */
-	void		*glom;	/* Packet chain for glommed superframe */
-	uint		glomerr; /* Glom packet read errors */
-
-	uint8		*rxbuf; /* Buffer for receiving control packets */
-	uint		rxblen;	/* Allocated length of rxbuf */
-	uint8		*rxctl;	/* Aligned pointer into rxbuf */
-	uint8		*databuf; /* Buffer for receiving big glom packet */
-	uint8		*dataptr; /* Aligned pointer into databuf */
-	uint		rxlen;	/* Length of valid data in buffer */
-
-	uint8		sdpcm_ver; /* Bus protocol reported by dongle */
-
-	bool		intr;	/* Use interrupts */
-	bool		poll;	/* Use polling */
-	bool		ipend;	/* Device interrupt is pending */
-	bool		intdis;	/* Interrupts disabled by isr */
-	uint 		intrcount; /* Count of device interrupt callbacks */
-	uint		lastintrs; /* Count as of last watchdog timer */
-	uint		spurious; /* Count of spurious interrupts */
-	uint		pollrate; /* Ticks between device polls */
-	uint		polltick; /* Tick counter */
-	uint		pollcnt; /* Count of active polls */
-
-	uint		regfails; /* Count of R_REG/W_REG failures */
-
-	uint		clkstate; /* State of sd and backplane clock(s) */
-	bool		activity; /* Activity flag for clock down */
-	int32		idletime; /* Control for activity timeout */
-	uint32		idlecount; /* Activity timeout counter */
-	int32		idleclock; /* How to set bus driver when idle */
-	uint32		sd_divisor; /* Speed control to bus driver */
-	uint32		sd_mode; /* Mode control to bus driver */
-	uint32		sd_rxchain; /* If bcmsdh api accepts PKT chains */
-	bool		use_rxchain; /* If dhd should use PKT chains */
-	bool		sleeping; /* Is SDIO bus sleeping? */
-	/* Field to decide if rx of control frames happen in rxbuf or lb-pool */
-	bool		usebufpool;
-
-#ifdef SDTEST
-	/* external loopback */
-	bool	ext_loop;
-	uint8	loopid;
-
-	/* pktgen configuration */
-	uint	pktgen_freq;	/* Ticks between bursts */
-	uint	pktgen_count;	/* Packets to send each burst */
-	uint	pktgen_print;	/* Bursts between count displays */
-	uint	pktgen_total;	/* Stop after this many */
-	uint	pktgen_minlen;	/* Minimum packet data len */
-	uint	pktgen_maxlen;	/* Maximum packet data len */
-	uint	pktgen_mode;	/* Configured mode: tx, rx, or echo */
-	uint	pktgen_stop;	/* Number of tx failures causing stop */
-
-	/* active pktgen fields */
-	uint	pktgen_tick;	/* Tick counter for bursts */
-	uint	pktgen_ptick;	/* Burst counter for printing */
-	uint	pktgen_sent;	/* Number of test packets generated */
-	uint	pktgen_rcvd;	/* Number of test packets received */
-	uint	pktgen_fail;	/* Number of failed send attempts */
-	uint16	pktgen_len;	/* Length of next packet to send */
-#endif /* SDTEST */
-
-	/* Some additional counters */
-	uint	tx_sderrs;	/* Count of tx attempts with sd errors */
-	uint	fcqueued;	/* Tx packets that got queued */
-	uint	rxrtx;		/* Count of rtx requests (NAK to dongle) */
-	uint	rx_toolong;	/* Receive frames too long to receive */
-	uint	rxc_errors;	/* SDIO errors when reading control frames */
-	uint	rx_hdrfail;	/* SDIO errors on header reads */
-	uint	rx_badhdr;	/* Bad received headers (roosync?) */
-	uint	rx_badseq;	/* Mismatched rx sequence number */
-	uint	fc_rcvd;	/* Number of flow-control events received */
-	uint	fc_xoff;	/* Number which turned on flow-control */
-	uint	fc_xon;		/* Number which turned off flow-control */
-	uint	rxglomfail;	/* Failed deglom attempts */
-	uint	rxglomframes;	/* Number of glom frames (superframes) */
-	uint	rxglompkts;	/* Number of packets from glom frames */
-	uint	f2rxhdrs;	/* Number of header reads */
-	uint	f2rxdata;	/* Number of frame data reads */
-	uint	f2txdata;	/* Number of f2 frame writes */
-	uint	f1regdata;	/* Number of f1 register accesses */
-
-} sdio_info_t;
-
-typedef struct {
-	sdio_info_t *sdio_info;
-	dbus_irb_tx_t *txirb;
-} pkttag_t;
-
-struct exec_parms {
-union {
-	struct {
-		sdio_info_t *sdio_info;
-		int tx_prec_map;
-		int *prec_out;
-	} pdeq;
-
-	struct {
-		sdio_info_t *sdio_info;
-		void *pkt;
-		int prec;
-	} penq;
-};
-};
-
-/* clkstate */
-#define CLK_NONE	0
-#define CLK_SDONLY	1
-#define CLK_PENDING	2	/* Not used yet */
-#define CLK_AVAIL	3
-
-#define DHD_NOPMU(dhd)	(FALSE)
-
-#ifdef BCMDBG
-static int qcount[NUMPRIO];
-#endif /* BCMDBG */
-
-/* Tx/Rx bounds */
-uint dhd_txbound = DHD_TXBOUND;
-uint dhd_rxbound = DHD_RXBOUND;
-/* static uint dhd_txminmax = DHD_TXMINMAX; */
-
-/* overrride the RAM size if possible */
-#define DONGLE_MIN_MEMSIZE (128 *1024)
-int dhd_dongle_memsize = 0;
-
-
-static bool dhd_alignctl = TRUE;
-
-static bool sd1idle = TRUE;
-
-static bool retrydata = FALSE;
-#define RETRYCHAN(chan) (((chan) == SDPCM_EVENT_CHANNEL) || retrydata)
-
-#ifdef BCMSPI
-/* At a watermark around 8 the spid hits underflow error. */
-static const uint watermark = 32;
-#else
-static const uint watermark = 8;
-#endif /* BCMSPI */
-static const uint firstread = 32;
-
-#ifdef SDTEST
-/* Echo packet generator (SDIO), pkts/s */
-extern uint dhd_pktgen;
-
-/* Echo packet len (0 => sawtooth, max 1800) */
-extern uint dhd_pktgen_len;
-#define MAX_PKTGEN_LEN 1800
-#endif
-extern uint dhd_watchdog_ms;
-
-/* optionally set by a module_param_string() */
-#define MOD_PARAM_PATHLEN       2048
-char firmware_path[MOD_PARAM_PATHLEN];
-char nvram_path[MOD_PARAM_PATHLEN];
-
-/* Use interrupts */
-extern uint dhd_intr;
-
-/* Use polling */
-extern uint dhd_poll;
-
-/* Initial idletime behavior (immediate, never, or ticks) */
-extern int dhd_idletime;
-#define DHD_IDLETIME_TICKS 1;
-
-/* SDIO Drive Strength */
-extern uint dhd_sdiod_drive_strength;
-
-/* Override to force tx queueing all the time */
-extern uint dhd_force_tx_queueing;
-
-#define HDATLEN (firstread - (SDPCM_HDRLEN))
-
-/* Retry count for register access failures */
-static uint retry_limit = 2;
-
-/* Force even SD lengths (some host controllers mess up on odd bytes) */
-#ifdef BCMSPI
-static bool forcealign = FALSE;
-#else
-static bool forcealign = TRUE;
-#endif /* !BCMSPI */
-
-/*
- * Default is to bring up eth1 immediately.
- */
-uint delay_eth = 0;
-
-#define ALIGNMENT  4
-
-#define PKTALIGN(osh, p, len, align) \
-	do {                                                        \
-		uintptr datalign;                                   \
-								    \
-		datalign = (uintptr)PKTDATA((osh), (p));            \
-		datalign = ROUNDUP(datalign, (align)) - datalign;   \
-		ASSERT(datalign < (align));                         \
-		ASSERT(PKTLEN((osh), (p)) >= ((len) + datalign));   \
-		if (datalign)                                       \
-			PKTPULL((osh), (p), (uint)datalign);        \
-		PKTSETLEN((osh), (p), (len));                       \
-	} while (0)
-
-/* Limit on rounding up frames */
-static uint max_roundup = 512;
-
-/* Try doing readahead */
-static bool dhd_readahead = TRUE;
-
-/* To check if there's window offered */
-#define DATAOK(bus) \
-	(((uint8)(sdio_info->tx_max - sdio_info->tx_seq) != 0) && \
-	(((uint8)(sdio_info->tx_max - sdio_info->tx_seq) & 0x80) == 0))
-
-/* Macros to get register read/write status */
-/* NOTE: these assume a local dbus_sdio_bus_t *bus! */
-
-#define R_SDREG(regvar, regaddr, retryvar) \
-do { \
-	retryvar = 0; \
-	do { \
-		regvar = R_REG(sdio_info->pub->osh, regaddr); \
-	} while (bcmsdh_regfail(sdio_info->sdh) && (++retryvar <= retry_limit)); \
-	if (retryvar) { \
-		sdio_info->regfails += (retryvar-1); \
-		if (retryvar > retry_limit) { \
-			DBUSERR(("%s: FAILED" #regvar "READ, LINE %d\n", \
-			           __FUNCTION__, __LINE__)); \
-			regvar = 0; \
-		} \
-	} \
-} while (0)
-
-#define W_SDREG(regval, regaddr, retryvar) \
-do { \
-	retryvar = 0; \
-	do { \
-		W_REG(sdio_info->pub->osh, regaddr, regval); \
-	} while (bcmsdh_regfail(sdio_info->sdh) && (++retryvar <= retry_limit)); \
-	if (retryvar) { \
-		sdio_info->regfails += (retryvar-1); \
-		if (retryvar > retry_limit) \
-			DBUSERR(("%s: FAILED REGISTER WRITE, LINE %d\n", \
-			           __FUNCTION__, __LINE__)); \
-	} \
-} while (0)
-
-#ifdef BCMSPI
-
-#define SD_BUSTYPE			SPI_BUS
-
-/* check packet-available-interrupt in piggybacked dstatus */
-#define PKT_AVAILABLE()	(bcmsdh_get_dstatus(sdio_info->sdh) & STATUS_F2_PKT_AVAILABLE)
-
-#define HOSTINTMASK		(I_HMB_FC_CHANGE | I_HMB_HOST_INT)
-
-#define GSPI_PR55150_BAILOUT									\
-do {												\
-	uint32 dstatussw = bcmsdh_get_dstatus((void *)sdio_info->sdh);				\
-	uint32 dstatushw = bcmsdh_cfg_read_word(sdio_info->sdh, \
-			SDIO_FUNC_0, SPID_STATUS_REG, NULL);	\
-	uint32 intstatuserr = 0;								\
-	uint retries = 0;									\
-												\
-	R_SDREG(intstatuserr, &sdio_info->regs->intstatus, retries);				\
-	printf("dstatussw = 0x%x, dstatushw = 0x%x, intstatus = 0x%x\n",			\
-	        dstatussw, dstatushw, intstatuserr); 						\
-												\
-	sdio_info->nextlen = 0;									\
-	*finished = TRUE;									\
-} while (0)
-
-#else /* BCMSDIO */
-
-#define SD_BUSTYPE			SDIO_BUS
-
-#define PKT_AVAILABLE()		(intstatus & I_HMB_FRAME_IND)
-
-#define HOSTINTMASK		(I_TOHOSTMAIL | I_CHIPACTIVE)
-
-#define GSPI_PR55150_BAILOUT
-
-#endif /* BCMSPI */
-
-#define BUS_WAKE(sdio_info) \
-	do { \
-		if ((sdio_info)->sleeping) \
-			dbus_sdio_bussleep((sdio_info), FALSE); \
-	} while (0);
-
-/* Debug */
-#define DBUSINTR DBUSTRACE
-#define DBUSTIMER DBUSTRACE
-#define DBUSGLOM DBUSTRACE
-#define DBUSDATA DBUSTRACE
-#define DBUSCTL DBUSTRACE
-#define DBUSGLOM_ON() 0
-
-/* IOVar table */
-enum {
-	IOV_INTR = 1,
-	IOV_POLLRATE,
-	IOV_SDREG,
-	IOV_SBREG,
-	IOV_SDCIS,
-	IOV_MEMBYTES,
-	IOV_MEMSIZE,
-	IOV_SET_DOWNLOAD_STATE,
-	IOV_FORCEEVEN,
-	IOV_SDIOD_DRIVE,
-	IOV_READAHEAD,
-	IOV_SDRXCHAIN,
-	IOV_ALIGNCTL,
-	IOV_SDALIGN,
-	IOV_DEVRESET,
-#ifdef SDTEST
-	IOV_PKTGEN,
-	IOV_EXTLOOP,
-#endif /* SDTEST */
-	IOV_SPROM,
-	IOV_TXBOUND,
-	IOV_RXBOUND,
-	IOV_IDLETIME,
-	IOV_IDLECLOCK,
-	IOV_SD1IDLE,
-	IOV_SLEEP,
-	IOV_VARS
-};
-
-static const bcm_iovar_t dbus_sdio_iovars[] = {
-	{"intr",	IOV_INTR,	0,	IOVT_BOOL,	0 },
-	{"sleep",	IOV_SLEEP,	0,	IOVT_BOOL,	0 },
-	{"pollrate",	IOV_POLLRATE,	0,	IOVT_UINT32,	0 },
-	{"idletime",	IOV_IDLETIME,	0,	IOVT_INT32,	0 },
-	{"idleclock",	IOV_IDLECLOCK,	0,	IOVT_INT32,	0 },
-	{"sd1idle",	IOV_SD1IDLE,	0,	IOVT_BOOL,	0 },
-	{"membytes",	IOV_MEMBYTES,	0,	IOVT_BUFFER,	2 * sizeof(int) },
-	{"memsize",	IOV_MEMSIZE,	0,	IOVT_UINT32,	0 },
-	{"dwnldstate",	IOV_SET_DOWNLOAD_STATE,	0,	IOVT_BOOL,	0 },
-	{"vars",	IOV_VARS,	0,	IOVT_BUFFER,	0 },
-	{"sdiod_drive",	IOV_SDIOD_DRIVE, 0,	IOVT_UINT32,	0 },
-	{"readahead",	IOV_READAHEAD,	0,	IOVT_BOOL,	0 },
-	{"sdrxchain",	IOV_SDRXCHAIN,	0,	IOVT_BOOL,	0 },
-	{"alignctl",	IOV_ALIGNCTL,	0,	IOVT_BOOL,	0 },
-	{"sdalign",	IOV_SDALIGN,	0,	IOVT_BOOL,	0 },
-	{"devreset",	IOV_DEVRESET,	0,	IOVT_BOOL,	0 },
-#ifdef BCMDBG
-	{"sdreg",	IOV_SDREG,	0,	IOVT_BUFFER,	sizeof(sdreg_t) },
-	{"sbreg",	IOV_SBREG,	0,	IOVT_BUFFER,	sizeof(sdreg_t) },
-	{"sd_cis",	IOV_SDCIS,	0,	IOVT_BUFFER,	DHD_IOCTL_MAXLEN },
-	{"forcealign",	IOV_FORCEEVEN,	0,	IOVT_BOOL,	0 },
-	{"txbound",	IOV_TXBOUND,	0,	IOVT_UINT32,	0 },
-	{"rxbound",	IOV_RXBOUND,	0,	IOVT_UINT32,	0 },
-#endif /* BCMDBG */
-#if defined(BCMDBG) || defined(DHD_SPROM)
-	{"sprom",	IOV_SPROM,	0,	IOVT_BUFFER,	2 * sizeof(int) },
-#endif 
-#ifdef SDTEST
-	{"extloop",	IOV_EXTLOOP,	0,	IOVT_BOOL,	0 },
-	{"pktgen",	IOV_PKTGEN,	0,	IOVT_BUFFER,	sizeof(dhd_pktgen_t) },
-#endif /* SDTEST */
-
-	{NULL, 0, 0, 0, 0 }
-};
-
-typedef struct {
-	chipcregs_t	*ccregs;
-	sdpcmd_regs_t	*sdregs;
-	uint32		socram_size;
-} chipinfo_t;
-
-/* This stores SD Host info during probe callback
- * since attach() is not called yet at this point
- */
-typedef struct {
-	uint16 venid;
-	uint16 devid;
-	uint16 bus_no;
-	uint16 slot;
-	uint16 func;
-	uint bustype;
-	void *regsva;
-	osl_t *osh;	/* Comes from SD Host */
-	bool free_probe_osh;
-
-	bcmsdh_info_t	*sdh;	/* Handle for BCMSDH calls */
-	si_t		*sih;	/* Handle for SI calls */
-
-	uint32		ramsize;  /* Size of RAM in SOCRAM (bytes) */
-	uint32		orig_ramsize;  /* Size of RAM in SOCRAM (bytes) */
-	char		*vars;	/* Variables (from CIS and/or other) */
-	uint		varsz;	/* Size of variables buffer */
-	bool alp_only; /* Don't use HT clock (ALP only) */
-
-	char *firmware_file;
-	char *nvram_file;
-	bool devready;
-
-	uint32 dl_addr;
-	const chipinfo_t *chinfo;
-} probe_sdh_info_t;
-
-static probe_sdh_info_t g_probe_info;
-
-/*
- * FIX: Basic information needed to prep dongle for download.
- * The goal is to simplify probe setup before a valid
- * image has been downloaded.  Also, can we avoid si_attach() during
- * probe setup since it brings in a lot of unnecessary dependencies?
- */
-
-/* 4325 and 4315 have the same address map */
-static const chipinfo_t chipinfo_4325_15 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18002000,
-	(384 * 1024)
-};
-
-static const chipinfo_t chipinfo_4329 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18011000,
-	(288 * 1024)
-};
-
-static const chipinfo_t chipinfo_4336 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18002000,
-	(240 * 1024)
-};
-
-static const chipinfo_t chipinfo_4330 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18002000,
-	(240 * 1024)
-};
-
-static const chipinfo_t chipinfo_43237 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18002000,
-	(320 * 1024)
-};
-
-static const chipinfo_t chipinfo_4314 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18003000,
-	(256 * 1024)
-};
-
-static const chipinfo_t chipinfo_4334 = {
-	(chipcregs_t *) 0x18000000,
-	(sdpcmd_regs_t *) 0x18002000,
-	(512 * 1024)
-};
-
-/*
- * SDH registration callbacks
- */
-static void * dbus_sdh_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
-	uint16 func, uint bustype, void *regsva, osl_t * osh,
-	void *sdh);
-static void dbus_sdh_disconnect(void *ptr);
-static void dbus_sdh_isr(void *handle);
-
-/*
- * Local function prototypes
- */
-static void *dbus_sdio_probe_cb(void *handle, const char *desc, uint32 bustype, uint32 hdrlen);
-static void dbus_sdio_disconnect_cb(void *handle);
-
-#ifdef SDTEST
-static void dbus_sdio_sdtest_set(sdio_info_t *sdio_info, bool start);
-static void dbus_sdio_testrcv(sdio_info_t *sdio_info, void *pkt, uint seq);
-#endif
-static bool dbus_sdio_attach_init(sdio_info_t *sdio_info, void *sdh,
-	char *firmware_path, char * nvram_path);
-static void dbus_sdio_release(sdio_info_t *sdio_info, osl_t *osh);
-static void dbus_sdio_release_dongle(sdio_info_t *sdio_info, osl_t *osh);
-static int dbus_sdio_rxctl(sdio_info_t *sdio_info, uchar *msg, uint msglen);
-static uint dbus_sdio_sendfromq(sdio_info_t *sdio_info, uint maxframes);
-static int dbus_sdio_txctl(sdio_info_t *sdio_info, uchar *msg, uint msglen);
-static void dbus_sdio_txq_flush(sdio_info_t *sdio_info);
-
-/*
- * NOTE: These functions can also be called before attach() occurs
- * so do not access sdio_info from them.  This is to support DBUS
- * async probe callback to upper layer such as DHD/BMAC/etc.  Another
- * alternative was to modify SDH to do async probe callback only
- * when a valid image is downloaded to the dongle.
- */
-static bool dbus_sdio_probe_init(probe_sdh_info_t *pinfo);
-static void dbus_sdio_probe_deinit(probe_sdh_info_t *pinfo);
-static int dbus_sdio_download_state(probe_sdh_info_t *pinfo, bool enter);
-static int dbus_sdio_membytes(probe_sdh_info_t *pinfo, bool write,
-	uint32 address, uint8 *data, uint size);
-static int dbus_sdio_write_vars(probe_sdh_info_t *pinfo);
-static int dbus_sdio_downloadvars(probe_sdh_info_t *pinfo, void *arg, int len);
-#ifdef BCM_DNGL_EMBEDIMAGE
-static int dhd_bus_download_nvram_file(probe_sdh_info_t *pinfo, char * nvram_path);
-static int dhd_bus_download_image_array(probe_sdh_info_t *pinfo,
-	char * nvram_path, uint8 *fw, int len);
-#endif
-
-/*
- * Wrappers to interface functions in dbus_sdio_os.c
- */
-static void dbus_sdos_lock(sdio_info_t *sdio_info);
-static void dbus_sdos_unlock(sdio_info_t *sdio_info);
-static void * dbus_sdos_exec_txlock(sdio_info_t *sdio_info, exec_cb_t cb, struct exec_parms *args);
-static int dbus_sdos_sched_dpc(sdio_info_t *sdio_info);
-#ifndef BCM_DNGL_EMBEDIMAGE
-static int dbus_sdos_sched_probe_cb(void);
-#endif
-
-/*
- * Wrappers to callback functions in dbus.c
- */
-static void *dbus_sdcb_pktget(sdio_info_t *sdio_info, uint len, bool send);
-static void dbus_sdcb_pktfree(sdio_info_t *sdio_info, void *p, bool send);
-static dbus_irb_t *dbus_sdcb_getirb(sdio_info_t *sdio_info, bool send);
-
-/*
- * Callbacks common to all SDIO
- */
-static void dbus_sdio_disconnect_cb(void *handle);
-static void dbus_sdio_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb);
-static void dbus_sdio_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status);
-static void dbus_sdio_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status);
-static void dbus_sdio_errhandler(void *handle, int err);
-static void dbus_sdio_ctl_complete(void *handle, int type, int status);
-static void dbus_sdio_state_change(void *handle, int state);
-static bool dbus_sdio_isr(void *handle, bool *wantdpc);
-static bool dbus_sdio_dpc(void *handle, bool bounded);
-static void dbus_sdio_watchdog(void *handle);
-
-static dbus_intf_callbacks_t dbus_sdio_intf_cbs = {
-	dbus_sdio_send_irb_timeout,
-	dbus_sdio_send_irb_complete,
-	dbus_sdio_recv_irb_complete,
-	dbus_sdio_errhandler,
-	dbus_sdio_ctl_complete,
-	dbus_sdio_state_change,
-	dbus_sdio_isr,
-	dbus_sdio_dpc,
-	dbus_sdio_watchdog
-};
-
-/*
- * Need global for probe() and disconnect() since
- * attach() is not called at probe and detach()
- * can be called inside disconnect()
- */
-static probe_cb_t probe_cb = NULL;
-static disconnect_cb_t disconnect_cb = NULL;
-static void *probe_arg = NULL;
-static void *disc_arg = NULL;
-
-/*
- * dbus_intf_t common to all SDIO
- * These functions override dbus_sdio_os.c.
- */
-static void *dbus_sdif_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs);
-static void dbus_sdif_detach(dbus_pub_t *pub, void *info);
-static int dbus_sdif_send_irb(void *bus, dbus_irb_tx_t *txirb);
-static int dbus_sdif_send_ctl(void *bus, uint8 *buf, int len);
-static int dbus_sdif_recv_ctl(void *bus, uint8 *buf, int len);
-static int dbus_sdif_up(void *bus);
-static int dbus_sdif_iovar_op(void *bus, const char *name,
-	void *params, int plen, void *arg, int len, bool set);
-static bool dbus_sdif_device_exists(void *bus);
-static bool dbus_sdif_dlneeded(void *bus);
-static int dbus_sdif_dlstart(void *bus, uint8 *fw, int len);
-static int dbus_sdif_dlrun(void *bus);
-static int dbus_sdif_stop(void *bus);
-static int dbus_sdif_down(void *bus);
-static int dbus_sdif_get_attrib(void *bus, dbus_attrib_t *attrib);
-
-static dbus_intf_t dbus_sdio_intf;
-static dbus_intf_t *g_dbusintf = NULL;
-
-/* Register/Unregister functions are called by the main DHD entry
- * point (e.g. module insertion) to link with the bus driver, in
- * order to look for or await the device.
- */
-
-bcmsdh_driver_t sdh_driver = {
-	dbus_sdh_probe,
-	dbus_sdh_disconnect
-};
-
-/* Functions shared between dbus_sdio.c/dbus_sdio_os.c */
-extern int dbus_sdio_txq_sched(void *bus);
-extern int dbus_sdio_txq_stop(void *bus);
-extern int dbus_sdio_txq_process(void *bus);
-extern int probe_dlstart(void);
-extern int probe_dlstop(void);
-extern int probe_dlwrite(uint8 *buf, int count, bool isvars);
-extern int probe_iovar(const char *name, void *params, int plen, void *arg, int len, bool set,
-	void **val, int *val_len);
-
-
-
-static int
-dbus_sdio_alpclk(bcmsdh_info_t *sdh)
-{
-	int err;
-#ifndef BCMSPI
-	uint8 clkctl = 0;
-#endif /* !BCMSPI */
-
-	/*
-	 * Request ALP clock; ALP is required before starting a download
-	 */
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, SBSDIO_ALP_AVAIL_REQ, &err);
-	if (err) {
-		DBUSERR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
-		return DBUS_ERR;
-	}
-
-#ifndef BCMSPI
-	/* Check current status */
-	clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (err) {
-		DBUSERR(("%s: HT Avail read error: %d\n", __FUNCTION__, err));
-		return DBUS_ERR;
-	}
-
-	if (!SBSDIO_CLKAV(clkctl, TRUE)) {
-		SPINWAIT(((clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-			SBSDIO_FUNC1_CHIPCLKCSR, &err)),
-			!SBSDIO_CLKAV(clkctl, TRUE)), PMU_MAX_TRANSITION_DLY);
-	}
-#endif
-
-	return DBUS_OK;
-}
-
-/* Turn backplane clock on or off */
-static int
-dbus_sdio_htclk(sdio_info_t *sdio_info, bool on, bool pendok)
-{
-	int err;
-	uint8 clkctl, clkreq, devctl;
-	bcmsdh_info_t *sdh;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	clkctl = 0;
-	sdh = sdio_info->sdh;
-
-
-	if (on) {
-		/* Request HT Avail */
-		clkreq = g_probe_info.alp_only ? SBSDIO_ALP_AVAIL_REQ : SBSDIO_HT_AVAIL_REQ;
-
-
-		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, clkreq, &err);
-		if (err) {
-			DBUSERR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
-			return BCME_ERROR;
-		}
-
-		if (pendok &&
-		    ((sdio_info->sih->buscoretype == PCMCIA_CORE_ID) &&
-			(sdio_info->sih->buscorerev == 9))) {
-			uint32 dummy, retries;
-			R_SDREG(dummy, &sdio_info->regs->clockctlstatus, retries);
-		}
-
-		/* Check current status */
-		clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-		if (err) {
-			DBUSERR(("%s: HT Avail read error: %d\n", __FUNCTION__, err));
-			return BCME_ERROR;
-		}
-
-		/* Go to pending and await interrupt if appropriate */
-		if (!SBSDIO_CLKAV(clkctl, g_probe_info.alp_only) && pendok) {
-			DBUSINFO(("CLKCTL: set PENDING\n"));
-			sdio_info->clkstate = CLK_PENDING;
-
-			/* Allow only clock-available interrupt */
-			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-			if (err) {
-				DBUSERR(("%s: Devctl access error setting CA: %d\n",
-				           __FUNCTION__, err));
-				return BCME_ERROR;
-			}
-
-			devctl |= SBSDIO_DEVCTL_CA_INT_ONLY;
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
-			return BCME_OK;
-		} else if (sdio_info->clkstate == CLK_PENDING) {
-			/* Cancel CA-only interrupt filter */
-			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
-		}
-
-		/* Otherwise, wait here (polling) for HT Avail */
-		if (!SBSDIO_CLKAV(clkctl, g_probe_info.alp_only)) {
-			SPINWAIT(((clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				SBSDIO_FUNC1_CHIPCLKCSR, &err)),
-				!SBSDIO_CLKAV(clkctl, g_probe_info.alp_only)),
-				PMU_MAX_TRANSITION_DLY);
-		}
-		if (err) {
-			DBUSERR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
-			return BCME_ERROR;
-		}
-		if (!SBSDIO_CLKAV(clkctl, g_probe_info.alp_only)) {
-			DBUSERR(("%s: HT Avail timeout (%d): clkctl 0x%02x\n",
-			           __FUNCTION__, PMU_MAX_TRANSITION_DLY, clkctl));
-			return BCME_ERROR;
-		}
-
-		/* Mark clock available */
-		sdio_info->clkstate = CLK_AVAIL;
-		DBUSINFO(("CLKCTL: turned ON\n"));
-
-#if defined(BCMDBG)
-		if (g_probe_info.alp_only == TRUE) {
-			if (!SBSDIO_ALPONLY(clkctl)) {
-				DBUSERR(("%s: HT Clock, when ALP Only\n", __FUNCTION__));
-			}
-		} else {
-			if (SBSDIO_ALPONLY(clkctl)) {
-				DBUSERR(("%s: HT Clock should be on.\n", __FUNCTION__));
-			}
-		}
-#endif /* defined (BCMDBG) */
-
-		sdio_info->activity = TRUE;
-	} else {
-		clkreq = 0;
-
-		if (sdio_info->clkstate == CLK_PENDING) {
-			/* Cancel CA-only interrupt filter */
-			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
-		}
-
-		sdio_info->clkstate = CLK_SDONLY;
-		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, clkreq, &err);
-		DBUSINFO(("CLKCTL: turned OFF\n"));
-		if (err) {
-			DBUSERR(("%s: Failed access turning clock off: %d\n",
-			           __FUNCTION__, err));
-			return BCME_ERROR;
-		}
-	}
-	return BCME_OK;
-}
-
-/* Change idle/active SD state */
-static int
-dbus_sdio_sdclk(sdio_info_t *sdio_info, bool on)
-{
-	int err;
-	int32 iovalue;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (on) {
-		if (sdio_info->idleclock == IDLE_STOP) {
-			/* Turn on clock and restore mode */
-			iovalue = 1;
-			err = bcmsdh_iovar_op(sdio_info->sdh, "sd_clock", NULL, 0,
-			                      &iovalue, sizeof(iovalue), TRUE);
-			if (err) {
-				DBUSERR(("%s: error enabling sd_clock: %d\n",
-				           __FUNCTION__, err));
-				return BCME_ERROR;
-			}
-
-			iovalue = sdio_info->sd_mode;
-			err = bcmsdh_iovar_op(sdio_info->sdh, "sd_mode", NULL, 0,
-			                      &iovalue, sizeof(iovalue), TRUE);
-			if (err) {
-				DBUSERR(("%s: error changing sd_mode: %d\n",
-				           __FUNCTION__, err));
-				return BCME_ERROR;
-			}
-		} else if (sdio_info->idleclock != IDLE_ACTIVE) {
-			/* Restore clock speed */
-			iovalue = sdio_info->sd_divisor;
-			err = bcmsdh_iovar_op(sdio_info->sdh, "sd_divisor", NULL, 0,
-			                      &iovalue, sizeof(iovalue), TRUE);
-			if (err) {
-				DBUSERR(("%s: error restoring sd_divisor: %d\n",
-				           __FUNCTION__, err));
-				return BCME_ERROR;
-			}
-		}
-		sdio_info->clkstate = CLK_SDONLY;
-	} else {
-		/* Stop or slow the SD clock itself */
-		if ((sdio_info->sd_divisor == -1) || (sdio_info->sd_mode == -1)) {
-			DBUSTRACE(("%s: can't idle clock, divisor %d mode %d\n",
-			           __FUNCTION__, sdio_info->sd_divisor, sdio_info->sd_mode));
-			return BCME_ERROR;
-		}
-		if (sdio_info->idleclock == IDLE_STOP) {
-			if (sd1idle) {
-				/* Change to SD1 mode and turn off clock */
-				iovalue = 1;
-				err = bcmsdh_iovar_op(sdio_info->sdh, "sd_mode", NULL, 0,
-				                      &iovalue, sizeof(iovalue), TRUE);
-				if (err) {
-					DBUSERR(("%s: error changing sd_clock: %d\n",
-					           __FUNCTION__, err));
-					return BCME_ERROR;
-				}
-			}
-
-			iovalue = 0;
-			err = bcmsdh_iovar_op(sdio_info->sdh, "sd_clock", NULL, 0,
-			                      &iovalue, sizeof(iovalue), TRUE);
-			if (err) {
-				DBUSERR(("%s: error disabling sd_clock: %d\n",
-				           __FUNCTION__, err));
-				return BCME_ERROR;
-			}
-		} else if (sdio_info->idleclock != IDLE_ACTIVE) {
-			/* Set divisor to idle value */
-			iovalue = sdio_info->idleclock;
-			err = bcmsdh_iovar_op(sdio_info->sdh, "sd_divisor", NULL, 0,
-			                      &iovalue, sizeof(iovalue), TRUE);
-			if (err) {
-				DBUSERR(("%s: error changing sd_divisor: %d\n",
-				           __FUNCTION__, err));
-				return BCME_ERROR;
-			}
-		}
-		sdio_info->clkstate = CLK_NONE;
-	}
-
-	return BCME_OK;
-}
-
-/* Transition SD and backplane clock readiness */
-static int
-dbus_sdio_clkctl(sdio_info_t *sdio_info, uint target, bool pendok)
-{
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	/* Early exit if we're already there */
-	if (sdio_info->clkstate == target) {
-		if (target == CLK_AVAIL)
-			sdio_info->activity = TRUE;
-		return BCME_OK;
-	}
-
-	switch (target) {
-	case CLK_AVAIL:
-		/* Make sure SD clock is available */
-		if (sdio_info->clkstate == CLK_NONE)
-			dbus_sdio_sdclk(sdio_info, TRUE);
-		/* Now request HT Avail on the backplane */
-		dbus_sdio_htclk(sdio_info, TRUE, pendok);
-		sdio_info->activity = TRUE;
-		break;
-
-	case CLK_SDONLY:
-		/* Remove HT request, or bring up SD clock */
-		if (sdio_info->clkstate == CLK_NONE)
-			dbus_sdio_sdclk(sdio_info, TRUE);
-		else if (sdio_info->clkstate == CLK_AVAIL)
-			dbus_sdio_htclk(sdio_info, FALSE, FALSE);
-		else
-			DBUSERR(("dbus_sdio_clkctl: request for %d -> %d\n",
-			           sdio_info->clkstate, target));
-		break;
-
-	case CLK_NONE:
-		/* Make sure to remove HT request */
-		if (sdio_info->clkstate == CLK_AVAIL)
-			dbus_sdio_htclk(sdio_info, FALSE, FALSE);
-		/* Now remove the SD clock */
-		dbus_sdio_sdclk(sdio_info, FALSE);
-		break;
-	}
-	DBUSINFO(("dbus_sdio_clkctl: %d -> %d\n", oldstate, sdio_info->clkstate));
-
-	return BCME_OK;
-}
-
-static int
-dbus_sdio_bussleep(sdio_info_t *sdio_info, bool sleep)
-{
-	bcmsdh_info_t *sdh = sdio_info->sdh;
-	sdpcmd_regs_t *regs = sdio_info->regs;
-	uint retries = 0;
-
-	DBUSINFO(("dbus_sdio_bussleep: request %s (currently %s)\n",
-	          (sleep ? "SLEEP" : "WAKE"),
-	          (sdio_info->sleeping ? "SLEEP" : "WAKE")));
-
-	/* Done if we're already in the requested state */
-	if (sleep == sdio_info->sleeping)
-		return BCME_OK;
-
-	/* Going to sleep: set the alarm and turn off the lights... */
-	if (sleep) {
-		/* Don't sleep if something is pending */
-		if (sdio_info->dpc_sched || sdio_info->rxskip || pktq_len(&sdio_info->txq))
-			return BCME_BUSY;
-
-
-		/* Disable SDIO interrupts (no longer interested) */
-		bcmsdh_intr_disable(sdio_info->sdh);
-
-		/* Make sure the controller has the bus up */
-		dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-
-		/* Tell device to start using OOB wakeup */
-		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
-		if (retries > retry_limit)
-			DBUSERR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
-
-		/* Turn off our contribution to the HT clock request */
-		dbus_sdio_clkctl(sdio_info, CLK_SDONLY, FALSE);
-
-		/* Isolate the bus */
-		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
-		                 SBSDIO_DEVCTL_PADS_ISO, NULL);
-
-		/* Change state */
-		sdio_info->sleeping = TRUE;
-
-	} else {
-		/* Waking up: bus power up is ok, set local state */
-
-		/* Force pad isolation off if possible (in case power never toggled) */
-		if ((sdio_info->sih->buscoretype == PCMCIA_CORE_ID) &&
-			(sdio_info->sih->buscorerev >= 10))
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, 0, NULL);
-
-
-		/* Make sure we have SD bus access */
-		if (sdio_info->clkstate == CLK_NONE)
-			dbus_sdio_clkctl(sdio_info, CLK_SDONLY, FALSE);
-
-		/* Send misc interrupt to indicate OOB not needed */
-		W_SDREG(0, &regs->tosbmailboxdata, retries);
-		if (retries <= retry_limit)
-			W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
-
-		if (retries > retry_limit)
-			DBUSERR(("CANNOT SIGNAL CHIP TO CLEAR OOB!!\n"));
-
-		/* Change state */
-		sdio_info->sleeping = FALSE;
-
-		/* Enable interrupts again */
-		if (sdio_info->intr && (sdio_info->pub->busstate == DBUS_STATE_UP)) {
-			sdio_info->intdis = FALSE;
-			bcmsdh_intr_enable(sdio_info->sdh);
-		}
-	}
-
-	return BCME_OK;
-}
-
-/* Writes a HW/SW header into the packet and sends it. */
-/* Assumes: (a) header space already there, (b) caller holds lock */
-static int
-dbus_sdio_txpkt(sdio_info_t *sdio_info, void *pkt, uint chan)
-{
-	int ret;
-	osl_t *osh;
-	uint8 *frame;
-	uint16 len, pad;
-	uint32 swheader;
-	uint retries = 0;
-	bcmsdh_info_t *sdh;
-	void *new;
-	pkttag_t *ptag;
-	int i;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	sdh = sdio_info->sdh;
-	osh = sdio_info->pub->osh;
-
-	if (sdio_info->dongle_reset) {
-		ret = BCME_NOTREADY;
-		goto done;
-	}
-
-	frame = (uint8*)PKTDATA(osh, pkt);
-
-	/* Add alignment padding, allocate new packet if needed */
-	if ((pad = ((uintptr)frame % SDALIGN))) {
-		if (PKTHEADROOM(osh, pkt) < pad) {
-			DBUSINFO(("%s: insufficient headroom %d for %d pad\n",
-			          __FUNCTION__, (int)PKTHEADROOM(osh, pkt), pad));
-			sdio_info->tx_realloc++;
-			new = dbus_sdcb_pktget(sdio_info, (PKTLEN(osh, pkt) + SDALIGN), TRUE);
-			if (!new) {
-				DBUSERR(("%s: couldn't allocate new %d-byte packet\n",
-				           __FUNCTION__, PKTLEN(osh, pkt) + SDALIGN));
-				ret = BCME_NOMEM;
-				goto done;
-			}
-
-			PKTALIGN(osh, new, PKTLEN(osh, pkt), SDALIGN);
-			bcopy(PKTDATA(osh, pkt), PKTDATA(osh, new), PKTLEN(osh, pkt));
-
-			*((pkttag_t *)PKTTAG(new)) = *((pkttag_t *)PKTTAG(pkt));
-			((pkttag_t *)PKTTAG(new))->txirb->pkt = new;
-			((pkttag_t *)PKTTAG(new))->txirb->info = new;
-
-			dbus_sdcb_pktfree(sdio_info, pkt, TRUE);
-			pkt = new;
-			frame = (uint8*)PKTDATA(osh, pkt);
-			ASSERT(((uintptr)frame % SDALIGN) == 0);
-			pad = 0;
-		} else {
-			PKTPUSH(osh, pkt, pad);
-			frame = (uint8*)PKTDATA(osh, pkt);
-			bzero(frame, pad + SDPCM_HDRLEN);
-		}
-	}
-	ASSERT(pad < SDALIGN);
-
-	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
-	len = (uint16)PKTLEN(osh, pkt);
-	*(uint16*)frame = htol16(len);
-	*(((uint16*)frame) + 1) = htol16(~len);
-
-	/* Software tag: channel, sequence number, data offset */
-	swheader = ((chan << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK) | sdio_info->tx_seq |
-	        (((pad + SDPCM_HDRLEN) << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
-	htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN);
-	htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN + sizeof(swheader));
-	sdio_info->tx_seq = (sdio_info->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
-
-	/* Raise len to next SDIO block to eliminate tail command */
-	if (sdio_info->roundup && sdio_info->blocksize && (len > sdio_info->blocksize)) {
-		pad = sdio_info->blocksize - (len % sdio_info->blocksize);
-		if ((pad <= sdio_info->roundup) && (pad < sdio_info->blocksize))
-#ifdef NOTUSED
-			if (pad <= PKTTAILROOM(osh, pkt))
-#endif
-				len += pad;
-	}
-
-	/* Some controllers have trouble with odd bytes -- round to even */
-	if (forcealign && (len & (ALIGNMENT - 1))) {
-#ifdef NOTUSED
-		if (PKTTAILROOM(osh, pkt))
-#endif
-			len = ROUNDUP(len, ALIGNMENT);
-#ifdef NOTUSED
-		else
-			DBUSERR(("%s: sending unrounded %d-byte packet\n", __FUNCTION__, len));
-#endif
-	}
-
-	do {
-		ret = bcmsdh_send_buf(sdh, SI_ENUM_BASE, SDIO_FUNC_2, F2SYNC,
-		                      frame, len, pkt, NULL, NULL);
-		sdio_info->f2txdata++;
-		ASSERT(ret != BCME_PENDING);
-
-		if (ret < 0) {
-			/* On failure, abort the command and terminate the frame */
-			DBUSINFO(("%s: sdio error %d, abort command and terminate frame.\n",
-			          __FUNCTION__, ret));
-			sdio_info->tx_sderrs++;
-
-			ret = bcmsdh_abort(sdh, SDIO_FUNC_2);
-			if (ret == BCME_NODEVICE) {
-				dbus_sdio_state_change(sdio_info, DBUS_STATE_DISCONNECT);
-				break;
-			}
-#ifdef BCMSPI
-			DBUSERR(("%s: gSPI transmit error.  Check Overflow or F2-fifo-not-ready"
-			           " counters.\n", __FUNCTION__));
-#endif /* BCMSPI */
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL,
-			                 SFC_WF_TERM, NULL);
-			sdio_info->f1regdata++;
-
-			for (i = 0; i < 3; i++) {
-				uint8 hi, lo;
-				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				                     SBSDIO_FUNC1_WFRAMEBCHI, NULL);
-				lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				                     SBSDIO_FUNC1_WFRAMEBCLO, NULL);
-				sdio_info->f1regdata += 2;
-				if ((hi == 0) && (lo == 0))
-					break;
-			}
-		}
-	} while ((ret < 0) && retrydata && retries++ < TXRETRIES);
-
-done:
-	ASSERT(OSL_PKTTAG_SZ >= sizeof(pkttag_t));
-	ptag = (pkttag_t *) PKTTAG(pkt);
-	ASSERT(ptag);
-	dbus_sdio_send_irb_complete(sdio_info, ptag->txirb, (ret ? DBUS_ERR_TXFAIL : DBUS_OK));
-
-	dbus_sdcb_pktfree(sdio_info, pkt, TRUE);
-	return ret;
-}
-
-static void *
-dbus_prec_pkt_deq(sdio_info_t *sdio_info, int tx_prec_map, int *prec_out)
-{
-	return pktq_mdeq(&sdio_info->txq, tx_prec_map, prec_out);
-}
-
-static void *
-dbus_prec_pkt_deq_exec(struct exec_parms *args)
-{
-	return dbus_prec_pkt_deq(args->pdeq.sdio_info, args->pdeq.tx_prec_map,
-		args->pdeq.prec_out);
-}
-
-/*
- * FIX: Move WMM pkt prioritization out of DBUS/SDIO to DHD so
- * USB can leverage the same logic
- */
-static bool
-dbus_prec_pkt_enq(sdio_info_t *sdio_info, void *pkt, int prec)
-{
-	void *p;
-	int eprec = -1;		/* precedence to evict from */
-	bool discard_oldest;
-	struct pktq *q = &sdio_info->txq;
-
-	/* Fast case, precedence queue is not full and we are also not
-	 * exceeding total queue length
-	 */
-	if (!pktq_pfull(q, prec) && !pktq_full(q)) {
-		pktq_penq(q, prec, pkt);
-		return TRUE;
-	}
-
-	/* Determine precedence from which to evict packet, if any */
-	if (pktq_pfull(q, prec))
-		eprec = prec;
-	else if (pktq_full(q)) {
-		p = pktq_peek_tail(q, &eprec);
-		ASSERT(p);
-		if (eprec > prec)
-			goto err;
-	}
-
-	/* Evict if needed */
-	if (eprec >= 0) {
-		/* Detect queueing to unconfigured precedence */
-		ASSERT(!pktq_pempty(q, eprec));
-		discard_oldest = AC_BITMAP_TST(sdio_info->wme_dp, eprec);
-		if (eprec == prec && !discard_oldest)
-			goto err; /* refuse newer (incoming) packet */
-		/* Evict packet according to discard policy */
-		p = discard_oldest ? pktq_pdeq(q, eprec) : pktq_pdeq_tail(q, eprec);
-		ASSERT(p);
-
-		dbus_sdcb_pktfree(sdio_info, p, TRUE);
-	}
-
-	/* Enqueue */
-	p = pktq_penq(q, prec, pkt);
-	ASSERT(p);
-
-	return TRUE;
-err:
-	return FALSE;
-}
-
-static void *
-dbus_prec_pkt_enq_exec(struct exec_parms *args)
-{
-	return (void *) (uintptr) dbus_prec_pkt_enq(args->penq.sdio_info, args->penq.pkt,
-		args->penq.prec);
-}
-
-static int
-dbus_sdio_txbuf_submit(sdio_info_t *sdio_info, dbus_irb_tx_t *txirb)
-{
-	int ret = 0;
-	void *berr;
-	osl_t *osh;
-	uint datalen, prec;
-	void *pkt;
-	pkttag_t *ptag;
-	struct exec_parms exec_args;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	osh = sdio_info->pub->osh;
-	pkt = txirb->pkt;
-	if (pkt == NULL) {
-		/*
-		 * For BMAC sdio high driver that uses send_buf,
-		 * we need to convert the buf into pkt for dbus.
-		 */
-		datalen = txirb->len;
-		DBUSTRACE(("%s: Converting buf(%d bytes) to pkt.\n", __FUNCTION__, datalen));
-		pkt = dbus_sdcb_pktget(sdio_info, datalen, TRUE);
-		if (pkt == NULL) {
-			DBUSERR(("%s: Out of Tx buf.\n", __FUNCTION__));
-			return DBUS_ERR_TXDROP;
-		}
-
-		txirb->pkt = pkt;
-		bcopy(txirb->buf, PKTDATA(osh, pkt), datalen);
-		PKTLEN(osh, pkt) = datalen;
-	} else
-		datalen = PKTLEN(osh, pkt);
-
-	ASSERT(OSL_PKTTAG_SZ >= sizeof(pkttag_t));
-	ptag = (pkttag_t *) PKTTAG(pkt);
-	ptag->sdio_info = sdio_info;
-	ptag->txirb = txirb;
-
-#ifdef SDTEST
-	/* Push the test header if doing loopback */
-	if (sdio_info->ext_loop) {
-		uint8* data;
-		PKTPUSH(osh, pkt, SDPCM_TEST_HDRLEN);
-		data = PKTDATA(osh, pkt);
-		*data++ = SDPCM_TEST_ECHOREQ;
-		*data++ = (uint8)sdio_info->loopid++;
-		*data++ = (datalen >> 0);
-		*data++ = (datalen >> 8);
-		datalen += SDPCM_TEST_HDRLEN;
-	}
-#endif /* SDTEST */
-
-	ASSERT(PKTHEADROOM(osh, pkt) >= SDPCM_HDRLEN);
-	/* Add space for the header */
-	PKTPUSH(osh, pkt, SDPCM_HDRLEN);
-	ASSERT(ISALIGNED(PKTDATA(osh, pkt), 2));
-
-	prec = PRIO2PREC((PKTPRIO(pkt) & PRIOMASK));
-
-	sdio_info->fcqueued++;
-
-	/* Priority based enq */
-	exec_args.penq.sdio_info = sdio_info;
-	exec_args.penq.pkt = pkt;
-	exec_args.penq.prec = prec;
-	berr = dbus_sdos_exec_txlock(sdio_info,
-		(exec_cb_t) dbus_prec_pkt_enq_exec, &exec_args);
-	if (berr == NULL) {
-		DBUSERR(("%s: Dropping pkt!\n", __FUNCTION__));
-		ASSERT(0); /* FIX: Should not be dropping pkts */
-		ret = DBUS_ERR_TXFAIL;
-		goto err;
-	}
-
-#ifdef BCMDBG
-	if (pktq_plen(&sdio_info->txq, prec) > qcount[prec])
-		qcount[prec] = pktq_plen(&sdio_info->txq, prec);
-#endif
-	dbus_sdio_txq_sched(sdio_info->sdos_info);
-
-err:
-	return ret;
-}
-
-static void
-dbus_bus_stop(sdio_info_t *sdio_info)
-{
-	uint8 saveclk;
-	uint retries;
-	int err;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	BUS_WAKE(sdio_info);
-
-	dbus_sdio_txq_stop(sdio_info->sdos_info);
-
-	/* Enable clock for device interrupts */
-	dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-
-	/* Disable and clear interrupts at the chip level also */
-	W_SDREG(0, &sdio_info->regs->hostintmask, retries);
-	W_SDREG(sdio_info->hostintmask, &sdio_info->regs->intstatus, retries);
-	sdio_info->hostintmask = 0;
-
-	/* Change our idea of bus state */
-	sdio_info->pub->busstate = DBUS_STATE_DOWN;
-
-	/* Force clocks on backplane to be sure F2 interrupt propagates */
-	saveclk = bcmsdh_cfg_read(sdio_info->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (!err) {
-		bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
-		                 (saveclk | SBSDIO_FORCE_HT), &err);
-	}
-	if (err) {
-		DBUSERR(("%s: Failed to force clock for F2: err %d\n", __FUNCTION__, err));
-	}
-
-	/* Turn off the bus (F2), free any pending packets */
-	DBUSINTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
-	bcmsdh_intr_disable(sdio_info->sdh);
-#ifndef BCMSPI
-	bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
-#endif /* !BCMSPI */
-
-	/* Turn off the backplane clock (only) */
-	dbus_sdio_clkctl(sdio_info, CLK_SDONLY, FALSE);
-
-	dbus_sdio_txq_flush(sdio_info);
-
-	/* Clear any held glomming stuff */
-	if (sdio_info->glomd) {
-		dbus_sdcb_pktfree(sdio_info, sdio_info->glomd, FALSE);
-		sdio_info->glomd = NULL;
-	}
-
-	if (sdio_info->glom) {
-		dbus_sdcb_pktfree(sdio_info, sdio_info->glom, FALSE);
-		sdio_info->glom = NULL;
-	}
-
-	/* Clear rx control and wake any waiters */
-	sdio_info->rxlen = 0;
-
-	/* Reset some F2 state stuff */
-	sdio_info->rxskip = FALSE;
-	sdio_info->tx_seq = sdio_info->rx_seq = 0;
-}
-
-static int
-dbus_sdio_init(sdio_info_t *sdio_info)
-{
-	uint retries = 0;
-
-	uint8 ready = 0, enable;
-	int err, ret = 0;
-#ifdef BCMSPI
-	uint32 dstatus = 0;	/* gSPI device status bits of */
-#else /* BCMSPI */
-	uint8 saveclk;
-#endif /* BCMSPI */
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	/* Make sure backplane clock is on, needed to generate F2 interrupt */
-	dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-	if (sdio_info->clkstate != CLK_AVAIL)
-		goto exit;
-
-#ifdef BCMSPI
-	/* fake "ready" for spi, wake-wlan would have already enabled F1 and F2 */
-	ready = (SDIO_FUNC_ENABLE_1 | SDIO_FUNC_ENABLE_2);
-
-	/* Give the dongle some time to do its thing and set IOR2 */
-	retries = WAIT_F2RXFIFORDY;
-	enable = 0;
-	while (retries-- && !enable) {
-		OSL_DELAY(WAIT_F2RXFIFORDY_DELAY * 1000);
-		dstatus = bcmsdh_cfg_read_word(sdio_info->sdh, SDIO_FUNC_0, SPID_STATUS_REG, NULL);
-		if (dstatus && STATUS_F2_RX_READY)
-			enable = TRUE;
-	}
-	if (enable) {
-		DBUSERR(("Took %d retries before dongle is ready with delay %d(ms) in between\n",
-			WAIT_F2RXFIFORDY - retries, WAIT_F2RXFIFORDY_DELAY));
-		enable = ready;
-	}
-	else {
-		DBUSERR(("dstatus when timed out on f2-fifo not ready = 0x%x\n", dstatus));
-		DBUSERR(("Waited %d retries, dongle is not ready with delay %d(ms) in between\n",
-			WAIT_F2RXFIFORDY, WAIT_F2RXFIFORDY_DELAY));
-		ret = -1;
-		goto exit;
-	}
-#else /* BCMSPI */
-	/* Force clocks on backplane to be sure F2 interrupt propagates */
-	saveclk = bcmsdh_cfg_read(sdio_info->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (!err) {
-		bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
-		                 (saveclk | SBSDIO_FORCE_HT), &err);
-	}
-	if (err) {
-		DBUSERR(("%s: Failed to force clock for F2: err %d\n", __FUNCTION__, err));
-		goto exit;
-	}
-
-	/* Enable function 2 (frame transfers) */
-	W_SDREG((SDPCM_PROT_VERSION << SMB_DATA_VERSION_SHIFT),
-	        &sdio_info->regs->tosbmailboxdata, retries);
-	enable = (SDIO_FUNC_ENABLE_1 | SDIO_FUNC_ENABLE_2);
-
-	bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, enable, NULL);
-
-
-	/* Give the dongle some time to do its thing and set IOR2 */
-	retries = DHD_WAIT_F2RDY;
-
-#ifdef BCMSLTGT
-	retries *= htclkratio;
-#endif /* BCMSLTGT */
-	while ((enable !=
-	        ((ready = bcmsdh_cfg_read(sdio_info->sdh, SDIO_FUNC_0, SDIOD_CCCR_IORDY, NULL)))) &&
-	       retries--) {
-		OSL_DELAY(1000);
-	}
-#endif /* !BCMSPI */
-
-	retries = 0;
-
-	DBUSERR(("%s: enable 0x%02x, ready 0x%02x\n", __FUNCTION__, enable, ready));
-
-
-	/* If F2 successfully enabled, set core and enable interrupts */
-	if (ready == enable) {
-		/* Make sure we're talking to the core. */
-		if (!(sdio_info->regs = si_setcore(sdio_info->sih, PCMCIA_CORE_ID, 0)))
-			sdio_info->regs = si_setcore(sdio_info->sih, SDIOD_CORE_ID, 0);
-
-		bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK,
-			(uint8)watermark, &err);
-
-		/* bcmsdh_intr_unmask(sdio_info->sdh); */
-
-		sdio_info->pub->busstate = DBUS_STATE_UP;
-		sdio_info->intdis = FALSE;
-		if (sdio_info->intr) {
-			DBUSINTR(("%s: enable SDIO device interrupts\n", __FUNCTION__));
-			bcmsdh_intr_enable(sdio_info->sdh);
-		} else {
-			DBUSINTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
-			bcmsdh_intr_disable(sdio_info->sdh);
-		}
-
-#ifdef DEBUG_LOST_INTERRUPTS
-		{
-			uint32 intstatus;
-			bool hostpending;
-			uint8 devena, devpend;
-			uint sdr_retries = 0;
-
-			hostpending = bcmsdh_intr_pending(sdio_info->sdh);
-			devena = bcmsdh_cfg_read(sdio_info->sdh, SDIO_FUNC_0,
-				SDIOD_CCCR_INTEN, NULL);
-			devpend = bcmsdh_cfg_read(sdio_info->sdh, SDIO_FUNC_0,
-				SDIOD_CCCR_INTPEND, NULL);
-
-			R_SDREG(intstatus, &sdio_info->regs->intstatus, sdr_retries);
-			intstatus &= sdio_info->hostintmask;
-
-			DBUSERR(("%s: interrupts -- host %s device ena/pend 0x%02x/0x%02x\n"
-			           "intstatus 0x%08x, hostmask 0x%08x\n", __FUNCTION__,
-			           (hostpending ? "PENDING" : "NOT PENDING"),
-			           devena, devpend, intstatus, sdio_info->hostintmask));
-		}
-#endif /* DEBUG_LOST_INTERRUPTS */
-	}
-
-#ifndef BCMSPI
-
-	else {
-		ret = DBUS_ERR;
-
-		/* Disable F2 again */
-		enable = SDIO_FUNC_ENABLE_1;
-		bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, enable, NULL);
-	}
-
-	/* Restore previous clock setting */
-	bcmsdh_cfg_write(sdio_info->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, saveclk, &err);
-
-#endif /* !BCMSPI */
-
-	/* If we didn't come up, turn off backplane clock */
-	if (sdio_info->pub->busstate != DBUS_STATE_UP) {
-		DBUSERR(("Error: Not up yet!\n"));
-		dbus_sdio_clkctl(sdio_info, CLK_NONE, FALSE);
-	}
-exit:
-	return ret;
-}
-
-static void
-dbus_sdio_rxfail(sdio_info_t *sdio_info, bool abort, bool rtx)
-{
-	bcmsdh_info_t *sdh = sdio_info->sdh;
-	sdpcmd_regs_t *regs = sdio_info->regs;
-	uint retries = 0;
-	uint16 lastrbc;
-	uint8 hi, lo;
-	int err;
-
-	DBUSERR(("%s: %sterminate frame%s\n", __FUNCTION__,
-	           (abort ? "abort command, " : ""), (rtx ? ", send NAK" : "")));
-
-	if (abort) {
-		err = bcmsdh_abort(sdh, SDIO_FUNC_2);
-		if (err == BCME_NODEVICE) {
-			dbus_sdio_state_change(sdio_info, DBUS_STATE_DISCONNECT);
-			return;
-		}
-	}
-
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL, SFC_RF_TERM, &err);
-	sdio_info->f1regdata++;
-
-	/* Wait until the packet has been flushed (device/FIFO stable) */
-	for (lastrbc = retries = 0xffff; retries > 0; retries--) {
-		hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCHI, NULL);
-		lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_RFRAMEBCLO, NULL);
-		sdio_info->f1regdata += 2;
-
-		if ((hi == 0) && (lo == 0))
-			break;
-
-		if ((hi > (lastrbc >> 8)) && (lo > (lastrbc & 0x00ff))) {
-			DBUSERR(("%s: count growing: last 0x%04x now 0x%04x\n",
-			           __FUNCTION__, lastrbc, ((hi << 8) + lo)));
-		}
-		lastrbc = (hi << 8) + lo;
-	}
-
-	if (!retries) {
-		DBUSERR(("%s: count never zeroed: last 0x%04x\n", __FUNCTION__, lastrbc));
-	} else {
-		DBUSINFO(("%s: flush took %d iterations\n", __FUNCTION__, (0xffff - retries)));
-	}
-
-	if (rtx) {
-		sdio_info->rxrtx++;
-		W_SDREG(SMB_NAK, &regs->tosbmailbox, retries);
-		sdio_info->f1regdata++;
-		if (retries <= retry_limit) {
-			sdio_info->rxskip = TRUE;
-		}
-	}
-
-	/* Clear partial in any case */
-	sdio_info->nextlen = 0;
-
-	/* If we can't reach the device, signal failure */
-	if (err || bcmsdh_regfail(sdh))
-		sdio_info->pub->busstate = DBUS_STATE_DOWN;
-}
-
-static void
-dbus_sdio_read_control(sdio_info_t *sdio_info, uint8 *hdr, uint len, uint doff)
-{
-	bcmsdh_info_t *sdh = sdio_info->sdh;
-	uint rdlen, pad;
-
-	int sdret;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	/* Control data already received in aligned rxctl */
-	if ((sdio_info->bus == SPI_BUS) && (!sdio_info->usebufpool))
-		goto gotpkt;
-
-	ASSERT(sdio_info->rxbuf);
-	/* Set rxctl for frame (w/optional alignment) */
-	sdio_info->rxctl = sdio_info->rxbuf;
-	if (dhd_alignctl) {
-		sdio_info->rxctl += firstread;
-		if ((pad = ((uintptr)sdio_info->rxctl % SDALIGN)))
-			sdio_info->rxctl += (SDALIGN - pad);
-		sdio_info->rxctl -= firstread;
-	}
-	ASSERT(sdio_info->rxctl >= sdio_info->rxbuf);
-
-	/* Copy the already-read portion over */
-	bcopy(hdr, sdio_info->rxctl, firstread);
-	if (len <= firstread)
-		goto gotpkt;
-
-	/* Copy the full data pkt in gSPI case and process ioctl. */
-	if (sdio_info->bus == SPI_BUS) {
-		bcopy(hdr, sdio_info->rxctl, len);
-		goto gotpkt;
-	}
-
-	/* Raise rdlen to next SDIO block to avoid tail command */
-	rdlen = len - firstread;
-	if (sdio_info->roundup && sdio_info->blocksize && (rdlen > sdio_info->blocksize)) {
-		pad = sdio_info->blocksize - (rdlen % sdio_info->blocksize);
-		if ((pad <= sdio_info->roundup) && (pad < sdio_info->blocksize) &&
-		    ((len + pad) < sdio_info->maxctl))
-			rdlen += pad;
-	}
-
-	/* Satisfy length-alignment requirements */
-	if (forcealign && (rdlen & (ALIGNMENT - 1)))
-		rdlen = ROUNDUP(rdlen, ALIGNMENT);
-
-	/* Drop if the read is too big or it exceeds our maximum */
-	if ((rdlen + firstread) > sdio_info->maxctl) {
-		DBUSERR(("%s: %d-byte control read exceeds %d-byte buffer\n",
-		           __FUNCTION__, rdlen, sdio_info->maxctl));
-		sdio_info->pub->stats.rx_errors++;
-		dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-		goto done;
-	}
-
-	if ((len - doff) > sdio_info->maxctl) {
-		DBUSERR(("%s: %d-byte ctl frame (%d-byte ctl data) exceeds %d-byte limit\n",
-		           __FUNCTION__, len, (len - doff), sdio_info->maxctl));
-		sdio_info->pub->stats.rx_errors++; sdio_info->rx_toolong++;
-		dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-		goto done;
-	}
-
-
-	/* Read remainder of frame body into the rxctl buffer */
-	sdret = bcmsdh_recv_buf(sdh, SI_ENUM_BASE, SDIO_FUNC_2, F2SYNC,
-	                        (sdio_info->rxctl + firstread), rdlen, NULL, NULL, NULL);
-	sdio_info->f2rxdata++;
-	ASSERT(sdret != BCME_PENDING);
-
-	/* Control frame failures need retransmission */
-	if (sdret < 0) {
-		DBUSERR(("%s: read %d control bytes failed: %d\n", __FUNCTION__, rdlen, sdret));
-		sdio_info->rxc_errors++; /* dhd.rx_ctlerrs is higher level */
-		dbus_sdio_rxfail(sdio_info, TRUE, TRUE);
-		goto done;
-	}
-
-gotpkt:
-	/* Point to valid data and indicate its length */
-	sdio_info->rxctl += doff;
-
-	if (sdio_info->rxlen != 0) {
-		DBUSERR(("dropping previous recv ctl pkt\n"));
-	}
-	sdio_info->rxlen = len - doff;
-
-	if (sdio_info->cbarg && sdio_info->cbs) {
-		if (sdio_info->rxctl_req.pending == TRUE) {
-			dbus_sdio_rxctl(sdio_info, sdio_info->rxctl_req.ctl.buf,
-				sdio_info->rxctl_req.ctl.len);
-			bzero(&sdio_info->rxctl_req, sizeof(sdio_info->rxctl_req));
-			dbus_sdio_ctl_complete(sdio_info, DBUS_CBCTL_READ, DBUS_OK);
-		}
-		/* If receive ctl pkt before user request, leave in cache
-		 * and retrieve it next time recv_ctl() is called.
-		 */
-	}
-done:
-	return;
-}
-
-static uint8
-dbus_sdio_rxglom(sdio_info_t *sdio_info, uint8 rxseq)
-{
-	uint16 dlen, totlen;
-	uint8 *dptr, num = 0;
-
-	uint16 sublen, check;
-	void *pfirst, *plast, *pnext, *save_pfirst;
-	osl_t *osh = sdio_info->pub->osh;
-
-	int errcode;
-	uint8 chan, seq, doff, sfdoff;
-	uint8 txmax;
-
-	bool usechain = sdio_info->use_rxchain;
-
-	/* If packets, issue read(s) and send up packet chain */
-	/* Return sequence numbers consumed? */
-
-	DBUSTRACE(("dbus_sdio_rxglom: start: glomd %p glom %p\n",
-		sdio_info->glomd, sdio_info->glom));
-
-	/* If there's a descriptor, generate the packet chain */
-	if (sdio_info->glomd) {
-		dlen = (uint16)PKTLEN(osh, sdio_info->glomd);
-		dptr = PKTDATA(osh, sdio_info->glomd);
-		if (!dlen || (dlen & 1)) {
-			DBUSERR(("%s: bad glomd len (%d), toss descriptor\n",
-			           __FUNCTION__, dlen));
-			dbus_sdcb_pktfree(sdio_info, sdio_info->glomd, FALSE);
-			sdio_info->glomd = NULL;
-			sdio_info->nextlen = 0;
-			return 0;
-		}
-
-		pfirst = plast = pnext = NULL;
-
-		for (totlen = num = 0; dlen; num++) {
-			/* Get (and move past) next length */
-			sublen = ltoh16_ua(dptr);
-			dlen -= sizeof(uint16);
-			dptr += sizeof(uint16);
-			if ((sublen < SDPCM_HDRLEN) ||
-			    ((num == 0) && (sublen < (2 * SDPCM_HDRLEN)))) {
-				DBUSERR(("%s: desciptor len %d bad: %d\n",
-				           __FUNCTION__, num, sublen));
-				pnext = NULL;
-				break;
-			}
-			if (sublen % SDALIGN) {
-				DBUSERR(("%s: sublen %d not a multiple of %d\n",
-				           __FUNCTION__, sublen, SDALIGN));
-				usechain = FALSE;
-			}
-			totlen += sublen;
-
-			/* For last frame, adjust read len so total is a block multiple */
-			if (!dlen) {
-				sublen += (ROUNDUP(totlen, sdio_info->blocksize) - totlen);
-				totlen = ROUNDUP(totlen, sdio_info->blocksize);
-			}
-
-			/* Allocate/chain packet for next subframe */
-			if ((pnext = dbus_sdcb_pktget(sdio_info,
-				sublen + SDALIGN, FALSE)) == NULL) {
-				DBUSERR(("%s: dbus_sdio_pktget failed, num %d len %d\n",
-				           __FUNCTION__, num, sublen));
-				break;
-			}
-			ASSERT(!PKTLINK(pnext));
-			if (!pfirst) {
-				ASSERT(!plast);
-				pfirst = plast = pnext;
-			} else {
-				ASSERT(plast);
-				PKTSETNEXT(osh, plast, pnext);
-				plast = pnext;
-			}
-
-			/* Adhere to start alignment requirements */
-			PKTALIGN(osh, pnext, sublen, SDALIGN);
-		}
-
-		/* If allocation failed, toss entirely and increment count */
-		if (!pnext) {
-			if (pfirst)
-				dbus_sdcb_pktfree(sdio_info, pfirst, FALSE);
-			dbus_sdcb_pktfree(sdio_info, sdio_info->glomd, FALSE);
-			sdio_info->glomd = NULL;
-			sdio_info->nextlen = 0;
-			return 0;
-		}
-
-		/* Ok, we have a packet chain, save in bus structure */
-		DBUSGLOM(("%s: allocated %d-byte packet chain for %d subframes\n",
-		          __FUNCTION__, totlen, num));
-		if (DBUSGLOM_ON() && sdio_info->nextlen) {
-			if (totlen != sdio_info->nextlen) {
-				DBUSGLOM(("%s: glomdesc mismatch: nextlen %d glomdesc %d "
-				          "rxseq %d\n", __FUNCTION__, sdio_info->nextlen,
-				          totlen, rxseq));
-			}
-		}
-		sdio_info->glom = pfirst;
-
-		/* Done with descriptor packet */
-		dbus_sdcb_pktfree(sdio_info, sdio_info->glomd, FALSE);
-		sdio_info->glomd = NULL;
-		sdio_info->nextlen = 0;
-	}
-
-	/* Ok -- either we just generated a packet chain, or had one from before */
-	if (sdio_info->glom) {
-		if (DBUSGLOM_ON()) {
-			DBUSGLOM(("%s: attempt superframe read, packet chain:\n", __FUNCTION__));
-			for (pnext = sdio_info->glom; pnext; pnext = PKTNEXT(osh, pnext)) {
-				DBUSGLOM(("    %p: %p len 0x%04x (%d)\n",
-				          pnext, (uint8*)PKTDATA(osh, pnext),
-				          PKTLEN(osh, pnext), PKTLEN(osh, pnext)));
-			}
-		}
-
-		pfirst = sdio_info->glom;
-		dlen = (uint16)pkttotlen(osh, pfirst);
-
-		/* Do an SDIO read for the superframe.  Configurable iovar to
-		 * read directly into the chained packet, or allocate a large
-		 * packet and and copy into the chain.
-		 */
-		if (usechain) {
-			errcode = bcmsdh_recv_buf(sdio_info->sdh, SI_ENUM_BASE, SDIO_FUNC_2,
-			                          F2SYNC, (uint8*)PKTDATA(osh, pfirst),
-			                          dlen, pfirst, NULL, NULL);
-		} else if (sdio_info->dataptr) {
-			errcode = bcmsdh_recv_buf(sdio_info->sdh, SI_ENUM_BASE, SDIO_FUNC_2,
-			                          F2SYNC, sdio_info->dataptr,
-			                          dlen, NULL, NULL, NULL);
-			sublen = (uint16)pktfrombuf(osh, pfirst, 0, dlen, sdio_info->dataptr);
-			if (sublen != dlen) {
-				DBUSERR(("%s: FAILED TO COPY, dlen %d sublen %d\n",
-				           __FUNCTION__, dlen, sublen));
-				errcode = -1;
-			}
-			pnext = NULL;
-		} else {
-			DBUSERR(("COULDN'T ALLOC %d-BYTE GLOM, FORCE FAILURE\n", dlen));
-			errcode = -1;
-		}
-		sdio_info->f2rxdata++;
-		ASSERT(errcode != BCME_PENDING);
-
-		/* On failure, kill the superframe, allow a couple retries */
-		if (errcode < 0) {
-			DBUSERR(("%s: glom read of %d bytes failed: %d\n",
-			           __FUNCTION__, dlen, errcode));
-			sdio_info->pub->stats.rx_errors++;
-
-			if (sdio_info->glomerr++ < 3) {
-				dbus_sdio_rxfail(sdio_info, TRUE, TRUE);
-			} else {
-				sdio_info->glomerr = 0;
-				dbus_sdio_rxfail(sdio_info, TRUE, FALSE);
-				dbus_sdcb_pktfree(sdio_info, sdio_info->glom, FALSE);
-				sdio_info->rxglomfail++;
-				sdio_info->glom = NULL;
-			}
-			OSL_DELAY(dlen/128);
-			return 0;
-		}
-
-#ifdef BCMDBG
-		if (DBUSGLOM_ON()) {
-			prhex("SUPERFRAME", PKTDATA(osh, pfirst),
-			      MIN(PKTLEN(osh, pfirst), 48));
-		}
-#endif
-
-
-		/* Validate the superframe header */
-		dptr = (uint8 *)PKTDATA(osh, pfirst);
-		sublen = ltoh16_ua(dptr);
-		check = ltoh16_ua(dptr + sizeof(uint16));
-
-		chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
-		seq = SDPCM_PACKET_SEQUENCE(&dptr[SDPCM_FRAMETAG_LEN]);
-		sdio_info->nextlen = dptr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
-		if ((sdio_info->nextlen << 4) > MAX_RX_DATASZ) {
-			DBUSINFO(("%s: got frame w/nextlen too large (%d) seq %d\n",
-			          __FUNCTION__, sdio_info->nextlen, seq));
-			sdio_info->nextlen = 0;
-		}
-		doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
-		txmax = SDPCM_WINDOW_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
-
-		errcode = 0;
-		if ((uint16)~(sublen^check)) {
-			DBUSERR(("%s (superframe): HW hdr error: len/check 0x%04x/0x%04x\n",
-			           __FUNCTION__, sublen, check));
-			errcode = -1;
-		} else if (ROUNDUP(sublen, sdio_info->blocksize) != dlen) {
-			DBUSERR(("%s (superframe): len 0x%04x, rounded 0x%04x, expect 0x%04x\n",
-				__FUNCTION__, sublen,
-				ROUNDUP(sublen, sdio_info->blocksize), dlen));
-			errcode = -1;
-		} else if (SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]) != SDPCM_GLOM_CHANNEL) {
-			DBUSERR(("%s (superframe): bad channel %d\n", __FUNCTION__,
-			           SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN])));
-			errcode = -1;
-		} else if (SDPCM_GLOMDESC(&dptr[SDPCM_FRAMETAG_LEN])) {
-			DBUSERR(("%s (superframe): got second descriptor?\n", __FUNCTION__));
-			errcode = -1;
-		} else if ((doff < SDPCM_HDRLEN) ||
-		           (doff > (PKTLEN(osh, pfirst) - SDPCM_HDRLEN))) {
-			DBUSERR(("%s (superframe): Bad data offset %d: HW %d pkt %d min %d\n",
-			           __FUNCTION__, doff, sublen, PKTLEN(osh, pfirst), SDPCM_HDRLEN));
-			errcode = -1;
-		}
-
-		/* Check sequence number of superframe SW header */
-		if (rxseq != seq) {
-			DBUSINFO(("%s: (superframe) rx_seq %d, expected %d\n",
-			          __FUNCTION__, seq, rxseq));
-			sdio_info->rx_badseq++;
-			rxseq = seq;
-		}
-
-		/* Check window for sanity */
-		if ((uint8)(txmax - sdio_info->tx_seq) > 0x40) {
-			DBUSERR(("%s: got unlikely tx max %d with tx_seq %d\n",
-			           __FUNCTION__, txmax, sdio_info->tx_seq));
-			txmax = sdio_info->tx_seq + 2;
-		}
-		sdio_info->tx_max = txmax;
-
-		/* Remove superframe header, remember offset */
-		PKTPULL(osh, pfirst, doff);
-		sfdoff = doff;
-
-		/* Validate all the subframe headers */
-		for (num = 0, pnext = pfirst; pnext && !errcode;
-		     num++, pnext = PKTNEXT(osh, pnext)) {
-			dptr = (uint8 *)PKTDATA(osh, pnext);
-			dlen = (uint16)PKTLEN(osh, pnext);
-			sublen = ltoh16_ua(dptr);
-			check = ltoh16_ua(dptr + sizeof(uint16));
-			chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
-			doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
-#ifdef BCMDBG
-			if (DBUSGLOM_ON()) {
-				prhex("subframe", dptr, 32);
-			}
-#endif
-
-			if ((uint16)~(sublen^check)) {
-				DBUSERR(("%s (subframe %d): HW hdr error: "
-				           "len/check 0x%04x/0x%04x\n",
-				           __FUNCTION__, num, sublen, check));
-				errcode = -1;
-			} else if ((sublen > dlen) || (sublen < SDPCM_HDRLEN)) {
-				DBUSERR(("%s (subframe %d): length mismatch: "
-				           "len 0x%04x, expect 0x%04x\n",
-				           __FUNCTION__, num, sublen, dlen));
-				errcode = -1;
-			} else if ((chan != SDPCM_DATA_CHANNEL) &&
-			           (chan != SDPCM_EVENT_CHANNEL)) {
-				DBUSERR(("%s (subframe %d): bad channel %d\n",
-				           __FUNCTION__, num, chan));
-				errcode = -1;
-			} else if ((doff < SDPCM_HDRLEN) || (doff > sublen)) {
-				DBUSERR(("%s (subframe %d): Bad data offset %d: HW %d min %d\n",
-				           __FUNCTION__, num, doff, sublen, SDPCM_HDRLEN));
-				errcode = -1;
-			}
-		}
-
-		if (errcode) {
-			/* Terminate frame on error, request a couple retries */
-			if (sdio_info->glomerr++ < 3) {
-				/* Restore superframe header space */
-				PKTPUSH(osh, pfirst, sfdoff);
-				dbus_sdio_rxfail(sdio_info, TRUE, TRUE);
-			} else {
-				sdio_info->glomerr = 0;
-				dbus_sdio_rxfail(sdio_info, TRUE, FALSE);
-				dbus_sdcb_pktfree(sdio_info, sdio_info->glom, FALSE);
-				sdio_info->rxglomfail++;
-				sdio_info->glom = NULL;
-			}
-			sdio_info->nextlen = 0;
-			return 0;
-		}
-
-		/* Basic SD framing looks ok - process each packet (header) */
-		save_pfirst = pfirst;
-		sdio_info->glom = NULL;
-		plast = NULL;
-
-		for (num = 0; pfirst; rxseq++, pfirst = pnext) {
-			pnext = PKTNEXT(osh, pfirst);
-			PKTSETNEXT(osh, pfirst, NULL);
-
-			dptr = (uint8 *)PKTDATA(osh, pfirst);
-			sublen = ltoh16_ua(dptr);
-			chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
-			seq = SDPCM_PACKET_SEQUENCE(&dptr[SDPCM_FRAMETAG_LEN]);
-			doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
-
-			DBUSGLOM(("%s: Get subframe %d, %p(%p/%d), sublen %d chan %d seq %d\n",
-			          __FUNCTION__, num, pfirst, PKTDATA(osh, pfirst),
-			          PKTLEN(osh, pfirst), sublen, chan, seq));
-
-			ASSERT((chan == SDPCM_DATA_CHANNEL) || (chan == SDPCM_EVENT_CHANNEL));
-
-			if (rxseq != seq) {
-				DBUSGLOM(("%s: rx_seq %d, expected %d\n",
-				          __FUNCTION__, seq, rxseq));
-				sdio_info->rx_badseq++;
-				rxseq = seq;
-			}
-
-			PKTSETLEN(osh, pfirst, sublen);
-			PKTPULL(osh, pfirst, doff);
-
-			if (PKTLEN(osh, pfirst) == 0) {
-				dbus_sdcb_pktfree(sdio_info, pfirst, FALSE);
-				if (plast) {
-					PKTSETNEXT(osh, plast, pnext);
-				} else {
-					ASSERT(save_pfirst == pfirst);
-					save_pfirst = pnext;
-				}
-				continue;
-			}
-
-			/* this packet will go up, link back into chain and count it */
-			PKTSETNEXT(osh, pfirst, pnext);
-			plast = pfirst;
-			num++;
-
-#ifdef BCMDBG
-			if (DBUSGLOM_ON()) {
-				DBUSGLOM(("%s subframe %d to stack, %p(%p/%d) nxt/lnk %p/%p\n",
-				          __FUNCTION__, num, pfirst,
-				          PKTDATA(osh, pfirst), PKTLEN(osh, pfirst),
-				          PKTNEXT(osh, pfirst), PKTLINK(pfirst)));
-				prhex("", (uint8 *)PKTDATA(osh, pfirst),
-				      MIN(PKTLEN(osh, pfirst), 32));
-			}
-#endif /* BCMDBG */
-		}
-
-		{
-			int i;
-			void *pnext;
-			void *plist;
-			dbus_irb_rx_t *rxirb;
-
-			plist = save_pfirst;
-			for (i = 0; plist && i < num; i++, plist = pnext) {
-				pnext = PKTNEXT(osh, plist);
-				PKTSETNEXT(osh, plist, NULL);
-
-				rxirb = (dbus_irb_rx_t *) dbus_sdcb_getirb(sdio_info, FALSE);
-				if (rxirb != NULL) {
-					rxirb->pkt = plist;
-					dbus_sdio_recv_irb_complete(sdio_info, rxirb, DBUS_OK);
-				} else {
-					ASSERT(0); /* FIX: Handle this case */
-				}
-			}
-		}
-
-		sdio_info->rxglomframes++;
-		sdio_info->rxglompkts += num;
-	}
-	return num;
-}
-
-/* Return TRUE if there may be more frames to read */
-static uint
-dbus_sdio_readframes(sdio_info_t *sdio_info, uint maxframes, bool *finished)
-{
-	bcmsdh_info_t *sdh = sdio_info->sdh;
-
-	uint16 len, check;	/* Extracted hardware header fields */
-	uint8 chan, seq, doff;	/* Extracted software header fields */
-	uint8 fcbits;		/* Extracted fcbits from software header */
-	uint8 delta;
-
-	void *pkt;	/* Packet for event or data frames */
-	uint16 pad;	/* Number of pad bytes to read */
-	uint16 rdlen;	/* Total number of bytes to read */
-	uint8 rxseq;	/* Next sequence number to expect */
-	uint rxleft = 0;	/* Remaining number of frames allowed */
-	int sdret;	/* Return code from bcmsdh calls */
-	uint8 txmax;	/* Maximum tx sequence offered */
-	uint32 dstatus = 0;	/* gSPI device status bits of */
-	bool len_consistent; /* Result of comparing readahead len and len from hw-hdr */
-	uint8 *rxbuf;
-	dbus_irb_rx_t *rxirb;
-
-#if defined(BCMDBG) || defined(SDTEST)
-	bool sdtest = FALSE;	/* To limit message spew from test mode */
-#endif
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	ASSERT(maxframes);
-
-#ifdef SDTEST
-	/* Allow pktgen to override maxframes */
-	if (sdio_info->pktgen_count && (sdio_info->pktgen_mode == DHD_PKTGEN_RECV)) {
-		maxframes = sdio_info->pktgen_count;
-		sdtest = TRUE;
-	}
-#endif
-
-	/* Not finished unless we encounter no more frames indication */
-	*finished = FALSE;
-
-#ifdef BCMSPI
-	/* Get pktlen from gSPI device F0 reg. */
-	if (sdio_info->bus == SPI_BUS) {
-		/* Peek in dstatus bits and find out size to do rx-read. */
-		dstatus = bcmsdh_get_dstatus(sdio_info->sdh);
-		DBUSTRACE(("Device status from regread = 0x%x\n", dstatus));
-		DBUSTRACE(("Device status from bit-reconstruction = 0x%x\n",
-		          bcmsdh_get_dstatus((void *)sdio_info->sdh)));
-
-		if ((dstatus & STATUS_F2_PKT_AVAILABLE) && (((dstatus & STATUS_UNDERFLOW)) == 0)) {
-			sdio_info->nextlen = (dstatus & STATUS_F2_PKT_LEN) >> STATUS_F2_PKT_SHIFT;
-			/* '0' size with pkt-available interrupt is eqvt to 2048 bytes */
-			sdio_info->nextlen =
-				(sdio_info->nextlen == 0) ? SPI_MAX_PKT_LEN : sdio_info->nextlen;
-			DBUSINFO(("Entering %s: length to be read from gSPI = %d\n",
-			          __FUNCTION__, sdio_info->nextlen));
-		} else {
-			if (dstatus & STATUS_F2_PKT_AVAILABLE)
-				DBUSERR(("Underflow during %s.\n", __FUNCTION__));
-			else
-				DBUSERR(("False pkt-available intr.\n"));
-			*finished = TRUE;
-			return (maxframes - rxleft);
-		}
-	}
-#endif /* BCMSPI */
-
-	for (rxseq = sdio_info->rx_seq, rxleft = maxframes;
-	     !sdio_info->rxskip && rxleft && sdio_info->pub->busstate != DBUS_STATE_DOWN;
-	     rxseq++, rxleft--) {
-
-		/* Handle glomming separately */
-		if (sdio_info->glom || sdio_info->glomd) {
-			uint8 cnt;
-			DBUSGLOM(("%s: calling rxglom: glomd %p, glom %p\n",
-			          __FUNCTION__, sdio_info->glomd, sdio_info->glom));
-
-			cnt = dbus_sdio_rxglom(sdio_info, rxseq);
-			DBUSGLOM(("%s: rxglom returned %d\n", __FUNCTION__, cnt));
-			rxseq += cnt - 1;
-			rxleft = (rxleft > cnt) ? (rxleft - cnt) : 1;
-			continue;
-		}
-
-		/* Try doing single read if we can */
-		if (dhd_readahead && sdio_info->nextlen) {
-			uint16 nextlen = sdio_info->nextlen;
-			sdio_info->nextlen = 0;
-
-			if (sdio_info->bus == SPI_BUS) {
-				rdlen = len = nextlen;
-			}
-			else {
-				rdlen = len = nextlen << 4;
-
-				/* Pad read to blocksize for efficiency */
-				if (sdio_info->roundup && sdio_info->blocksize &&
-					(rdlen > sdio_info->blocksize)) {
-					pad = sdio_info->blocksize - (rdlen % sdio_info->blocksize);
-					if ((pad <= sdio_info->roundup) &&
-						(pad < sdio_info->blocksize) &&
-						((rdlen + pad + firstread) < MAX_RX_DATASZ))
-						rdlen += pad;
-				}
-			}
-
-			/* We use sdio_info->rxctl buffer in WinXP for initial control pkt receives.
-			 * Later we use buffer-poll for data as well as control packets.
-			 * This is required becuase dhd receives full frame in gSPI unlike SDIO.
-			 * After the frame is received we have to distinguish whether it is data
-			 * or non-data frame.
-			 */
-			/* Allocate a packet buffer */
-			if (!(pkt = dbus_sdcb_pktget(sdio_info, rdlen + SDALIGN, FALSE))) {
-				if (sdio_info->bus == SPI_BUS) {
-					sdio_info->usebufpool = FALSE;
-					sdio_info->rxctl = sdio_info->rxbuf;
-					if (dhd_alignctl) {
-						sdio_info->rxctl += firstread;
-						if ((pad = ((uintptr)sdio_info->rxctl % SDALIGN)))
-							sdio_info->rxctl += (SDALIGN - pad);
-						sdio_info->rxctl -= firstread;
-					}
-					ASSERT(sdio_info->rxctl >= sdio_info->rxbuf);
-					rxbuf = sdio_info->rxctl;
-					/* Read the entire frame */
-					sdret = bcmsdh_recv_buf(sdh, SI_ENUM_BASE, SDIO_FUNC_2,
-					           F2SYNC, rxbuf, rdlen, NULL, NULL, NULL);
-					sdio_info->f2rxdata++;
-					ASSERT(sdret != BCME_PENDING);
-
-#ifdef BCMSPI
-					if (bcmsdh_get_dstatus((void *)sdio_info->sdh) &
-					                STATUS_UNDERFLOW) {
-						sdio_info->nextlen = 0;
-						*finished = TRUE;
-						DBUSERR(("%s: read %d control bytes failed "
-						           "due to spi underflow\n",
-						           __FUNCTION__, rdlen));
-						/* dhd.rx_ctlerrs is higher level */
-						sdio_info->rxc_errors++;
-						continue;
-					}
-#endif /* BCMSPI */
-
-					/* Control frame failures need retransmission */
-					if (sdret < 0) {
-						DBUSERR(("%s: read %d control bytes failed: %d\n",
-						   __FUNCTION__, rdlen, sdret));
-						/* dhd.rx_ctlerrs is higher level */
-						sdio_info->rxc_errors++;
-						dbus_sdio_rxfail(sdio_info, TRUE,
-						    (sdio_info->bus == SPI_BUS) ? FALSE : TRUE);
-						continue;
-					}
-				} else {
-				/* Give up on data, request rtx of events */
-				DBUSERR(("%s (nextlen): dbus_sdio_pktget failed: len %d rdlen %d "
-				           "expected rxseq %d\n",
-				           __FUNCTION__, len, rdlen, rxseq));
-				/* Just go try again w/normal header read */
-				continue;
-				}
-			} else {
-				if (sdio_info->bus == SPI_BUS)
-					sdio_info->usebufpool = TRUE;
-
-				ASSERT(!PKTLINK(pkt));
-				PKTALIGN(sdio_info->pub->osh, pkt, rdlen, SDALIGN);
-				rxbuf = (uint8 *)PKTDATA(sdio_info->pub->osh, pkt);
-				/* Read the entire frame */
-				sdret = bcmsdh_recv_buf(sdh, SI_ENUM_BASE, SDIO_FUNC_2, F2SYNC,
-				          rxbuf, rdlen, pkt, NULL, NULL);
-				sdio_info->f2rxdata++;
-				ASSERT(sdret != BCME_PENDING);
-
-				if (bcmsdh_get_dstatus((void *)sdio_info->sdh) & STATUS_UNDERFLOW) {
-					sdio_info->nextlen = 0;
-					*finished = TRUE;
-					DBUSERR(("%s (nextlen): read %d bytes failed due "
-					           "to spi underflow\n",
-					           __FUNCTION__, rdlen));
-					dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-					sdio_info->pub->stats.rx_errors++;
-					continue;
-				}
-
-				if (sdret < 0) {
-					DBUSERR(("%s (nextlen): read %d bytes failed: %d\n",
-					   __FUNCTION__, rdlen, sdret));
-					dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-					sdio_info->pub->stats.rx_errors++;
-					/* Force retry w/normal header read.  Don't attemp NAK for
-					 * gSPI
-					 */
-					dbus_sdio_rxfail(sdio_info, TRUE,
-					      (sdio_info->bus == SPI_BUS) ? FALSE : TRUE);
-					continue;
-				}
-			}
-
-			/* Now check the header */
-			bcopy(rxbuf, sdio_info->rxhdr, SDPCM_HDRLEN);
-
-			/* Extract hardware header fields */
-			len = ltoh16_ua(sdio_info->rxhdr);
-			check = ltoh16_ua(sdio_info->rxhdr + sizeof(uint16));
-
-			/* All zeros means readahead info was bad */
-			if (!(len|check)) {
-				DBUSINFO(("%s (nextlen): read zeros in HW header???\n",
-				           __FUNCTION__));
-				PKTFREE2();
-				GSPI_PR55150_BAILOUT;
-				continue;
-			}
-
-			/* Validate check bytes */
-			if ((uint16)~(len^check)) {
-				DBUSERR(("%s (nextlen): HW hdr error: nextlen/len/check"
-				           " 0x%04x/0x%04x/0x%04x\n", __FUNCTION__, nextlen,
-				           len, check));
-				PKTFREE2();
-				sdio_info->rx_badhdr++;
-				dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-				GSPI_PR55150_BAILOUT;
-				continue;
-			}
-
-			/* Validate frame length */
-			if (len < SDPCM_HDRLEN) {
-				DBUSERR(("%s (nextlen): HW hdr length invalid: %d\n",
-				           __FUNCTION__, len));
-				PKTFREE2();
-				GSPI_PR55150_BAILOUT;
-				continue;
-			}
-
-			/* Check for consistency with readahead info */
-			if (sdio_info->bus == SPI_BUS)
-				len_consistent = (nextlen != len);
-			else
-				len_consistent = (nextlen != (ROUNDUP(len, 16) >> 4));
-			if (len_consistent) {
-				/* Mismatch, force retry w/normal header (may be >4K) */
-				DBUSERR(("%s (nextlen): mismatch, nextlen %d len %d rnd %d; "
-				           "expected rxseq %d\n",
-				           __FUNCTION__, nextlen, len, ROUNDUP(len, 16), rxseq));
-				PKTFREE2();
-				dbus_sdio_rxfail(sdio_info, TRUE,
-					(sdio_info->bus == SPI_BUS) ? FALSE : TRUE);
-				GSPI_PR55150_BAILOUT;
-				continue;
-			}
-
-
-			/* Extract software header fields */
-			chan = SDPCM_PACKET_CHANNEL(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-			seq = SDPCM_PACKET_SEQUENCE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-			doff = SDPCM_DOFFSET_VALUE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-			txmax = SDPCM_WINDOW_VALUE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-
-#ifdef BCMSPI
-			/* Save the readahead length if there is one */
-			if (sdio_info->bus == SPI_BUS) {
-				/* Use reconstructed dstatus bits and find out readahead size */
-				dstatus = bcmsdh_get_dstatus((void *)sdio_info->sdh);
-				DBUSINFO(("Device status from bit-reconstruction = 0x%x\n",
-				bcmsdh_get_dstatus((void *)sdio_info->sdh)));
-				if (dstatus & STATUS_F2_PKT_AVAILABLE) {
-					sdio_info->nextlen = (dstatus & STATUS_F2_PKT_LEN) >>
-					           STATUS_F2_PKT_SHIFT;
-					sdio_info->nextlen = (sdio_info->nextlen == 0) ?
-					           SPI_MAX_PKT_LEN : sdio_info->nextlen;
-					DBUSINFO(("readahead len from gSPI = %d \n",
-					           sdio_info->nextlen));
-					sdio_info->rx_readahead_cnt ++;
-				} else {
-					sdio_info->nextlen = 0;
-					*finished = TRUE;
-				}
-			} else {
-#endif /* BCMSPI */
-				sdio_info->nextlen =
-				      sdio_info->rxhdr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
-				if ((sdio_info->nextlen << 4) > MAX_RX_DATASZ) {
-					DBUSINFO(("%s (nextlen): got frame w/nextlen too large"
-					      " (%d), seq %d\n", __FUNCTION__, sdio_info->nextlen,
-					      seq));
-					sdio_info->nextlen = 0;
-				}
-
-				sdio_info->rx_readahead_cnt ++;
-#ifdef BCMSPI
-			}
-#endif /* BCMSPI */
-
-			/* Handle Flow Control - Brett */
-			fcbits = SDPCM_FCMASK_VALUE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-
-			delta = 0;
-			if (~sdio_info->flowcontrol & fcbits) {
-				sdio_info->fc_xoff++;
-				delta = 1;
-			}
-			if (sdio_info->flowcontrol & ~fcbits) {
-				sdio_info->fc_xon++;
-				delta = 1;
-			}
-
-			if (delta) {
-				sdio_info->fc_rcvd++;
-				sdio_info->flowcontrol = fcbits;
-			}
-
-			/* Check and update sequence number */
-			if (rxseq != seq) {
-				DBUSINFO(("%s (nextlen): rx_seq %d, expected %d\n",
-				          __FUNCTION__, seq, rxseq));
-				sdio_info->rx_badseq++;
-				rxseq = seq;
-			}
-
-			/* Check window for sanity */
-			if ((uint8)(txmax - sdio_info->tx_seq) > 0x40) {
-				if ((sdio_info->bus == SPI_BUS) &&
-					!(dstatus & STATUS_F2_RX_READY)) {
-					DBUSERR(("%s: got unlikely tx max %d with tx_seq %d\n",
-						__FUNCTION__, txmax, sdio_info->tx_seq));
-					txmax = sdio_info->tx_seq + 2;
-				} else {
-					DBUSERR(("%s: got unlikely tx max %d with tx_seq %d\n",
-						__FUNCTION__, txmax, sdio_info->tx_seq));
-					txmax = sdio_info->tx_seq + 2;
-				}
-			}
-			sdio_info->tx_max = txmax;
-
-			if (chan == SDPCM_CONTROL_CHANNEL) {
-				if (sdio_info->bus == SPI_BUS) {
-					dbus_sdio_read_control(sdio_info, rxbuf, len, doff);
-					if (sdio_info->usebufpool) {
-						dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-					}
-					continue;
-				} else {
-					DBUSERR(("%s (nextlen): readahead on control"
-					           " packet %d?\n", __FUNCTION__, seq));
-					/* Force retry w/normal header read */
-					sdio_info->nextlen = 0;
-					dbus_sdio_rxfail(sdio_info, FALSE, TRUE);
-					PKTFREE2();
-					continue;
-				}
-			}
-
-			if ((sdio_info->bus == SPI_BUS) && !sdio_info->usebufpool) {
-				DBUSERR(("Received %d bytes on %d channel. Running out of "
-				           "rx pktbuf's or not yet malloced.\n", len, chan));
-				continue;
-			}
-
-			/* Validate data offset */
-			if ((doff < SDPCM_HDRLEN) || (doff > len)) {
-				DBUSERR(("%s (nextlen): bad data offset %d: HW len %d min %d\n",
-				           __FUNCTION__, doff, len, SDPCM_HDRLEN));
-				PKTFREE2();
-				ASSERT(0);
-				dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-				continue;
-			}
-
-			/* All done with this one -- now deliver the packet */
-			goto deliver;
-		}
-		/* gSPI frames should not be handled in fractions */
-		if (sdio_info->bus == SPI_BUS) {
-			break;
-		}
-
-		/* Read frame header (hardware and software) */
-		sdret = bcmsdh_recv_buf(sdio_info->sdh, SI_ENUM_BASE, SDIO_FUNC_2, F2SYNC,
-		                        sdio_info->rxhdr, firstread, NULL, NULL, NULL);
-		sdio_info->f2rxhdrs++;
-		ASSERT(sdret != BCME_PENDING);
-
-		if (sdret < 0) {
-			DBUSERR(("%s: RXHEADER FAILED: %d\n", __FUNCTION__, sdret));
-			sdio_info->rx_hdrfail++;
-			dbus_sdio_rxfail(sdio_info, TRUE, TRUE);
-			continue;
-		}
-
-		/* Extract hardware header fields */
-		len = ltoh16_ua(sdio_info->rxhdr);
-		check = ltoh16_ua(sdio_info->rxhdr + sizeof(uint16));
-
-		/* All zeros means no more frames */
-		if (!(len|check)) {
-			*finished = TRUE;
-			break;
-		}
-
-		/* Validate check bytes */
-		if ((uint16)~(len^check)) {
-			DBUSERR(("%s: HW hdr error: len/check 0x%04x/0x%04x\n",
-			           __FUNCTION__, len, check));
-			sdio_info->rx_badhdr++;
-			dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-			continue;
-		}
-
-		/* Validate frame length */
-		if (len < SDPCM_HDRLEN) {
-			DBUSERR(("%s: HW hdr length invalid: %d\n", __FUNCTION__, len));
-			continue;
-		}
-
-		/* Extract software header fields */
-		chan = SDPCM_PACKET_CHANNEL(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-		seq = SDPCM_PACKET_SEQUENCE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-		doff = SDPCM_DOFFSET_VALUE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-		txmax = SDPCM_WINDOW_VALUE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-
-		/* Validate data offset */
-		if ((doff < SDPCM_HDRLEN) || (doff > len)) {
-			DBUSERR(("%s: Bad data offset %d: HW len %d, min %d seq %d\n",
-			           __FUNCTION__, doff, len, SDPCM_HDRLEN, seq));
-			sdio_info->rx_badhdr++;
-			ASSERT(0);
-			dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-			continue;
-		}
-
-		/* Save the readahead length if there is one */
-		sdio_info->nextlen = sdio_info->rxhdr[SDPCM_FRAMETAG_LEN + SDPCM_NEXTLEN_OFFSET];
-		if ((sdio_info->nextlen << 4) > MAX_RX_DATASZ) {
-			DBUSINFO(("%s (nextlen): got frame w/nextlen too large (%d), seq %d\n",
-			          __FUNCTION__, sdio_info->nextlen, seq));
-			sdio_info->nextlen = 0;
-		}
-
-		/* Handle Flow Control */
-		fcbits = SDPCM_FCMASK_VALUE(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN]);
-
-		delta = 0;
-		if (~sdio_info->flowcontrol & fcbits) {
-			sdio_info->fc_xoff++;
-			delta = 1;
-		}
-		if (sdio_info->flowcontrol & ~fcbits) {
-			sdio_info->fc_xon++;
-			delta = 1;
-		}
-
-		if (delta) {
-			sdio_info->fc_rcvd++;
-			sdio_info->flowcontrol = fcbits;
-		}
-
-		/* Check and update sequence number */
-		if (rxseq != seq) {
-			DBUSINFO(("%s: rx_seq %d, expected %d\n", __FUNCTION__, seq, rxseq));
-			sdio_info->rx_badseq++;
-			rxseq = seq;
-		}
-
-		/* Check window for sanity */
-		if ((uint8)(txmax - sdio_info->tx_seq) > 0x40) {
-			DBUSERR(("%s: got unlikely tx max %d with tx_seq %d\n",
-			           __FUNCTION__, txmax, sdio_info->tx_seq));
-			txmax = sdio_info->tx_seq + 2;
-		}
-		sdio_info->tx_max = txmax;
-
-		/* Call a separate function for control frames */
-		if (chan == SDPCM_CONTROL_CHANNEL) {
-			dbus_sdio_read_control(sdio_info, sdio_info->rxhdr, len, doff);
-			continue;
-		}
-
-		ASSERT((chan == SDPCM_DATA_CHANNEL) || (chan == SDPCM_EVENT_CHANNEL) ||
-		       (chan == SDPCM_TEST_CHANNEL) || (chan == SDPCM_GLOM_CHANNEL));
-
-		/* Length to read */
-		rdlen = (len > firstread) ? (len - firstread) : 0;
-
-		/* May pad read to blocksize for efficiency */
-		if (sdio_info->roundup && sdio_info->blocksize && (rdlen > sdio_info->blocksize)) {
-			pad = sdio_info->blocksize - (rdlen % sdio_info->blocksize);
-			if ((pad <= sdio_info->roundup) && (pad < sdio_info->blocksize) &&
-			    ((rdlen + pad + firstread) < MAX_RX_DATASZ))
-				rdlen += pad;
-		}
-
-		/* Satisfy length-alignment requirements */
-		if (forcealign && (rdlen & (ALIGNMENT - 1)))
-			rdlen = ROUNDUP(rdlen, ALIGNMENT);
-
-		if ((rdlen + firstread) > MAX_RX_DATASZ) {
-			/* Too long -- skip this frame */
-			DBUSERR(("%s: too long: len %d rdlen %d\n", __FUNCTION__, len, rdlen));
-			sdio_info->pub->stats.rx_errors++; sdio_info->rx_toolong++;
-			dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-			continue;
-		}
-
-		if (!(pkt = dbus_sdcb_pktget(sdio_info, (rdlen + firstread + SDALIGN), FALSE))) {
-			/* Give up on data, request rtx of events */
-			DBUSERR(("%s: dbus_sdio_pktget failed: rdlen %d chan %d\n",
-			           __FUNCTION__, rdlen, chan));
-			sdio_info->pub->stats.rx_dropped++;
-			dbus_sdio_rxfail(sdio_info, FALSE, RETRYCHAN(chan));
-			continue;
-		}
-
-		ASSERT(!PKTLINK(pkt));
-
-		/* Leave room for what we already read, and align remainder */
-		ASSERT(firstread < (PKTLEN(sdio_info->pub->osh, pkt)));
-		PKTPULL(sdio_info->pub->osh, pkt, firstread);
-		PKTALIGN(sdio_info->pub->osh, pkt, rdlen, SDALIGN);
-
-		/* Read the remaining frame data */
-		sdret = bcmsdh_recv_buf(sdh, SI_ENUM_BASE, SDIO_FUNC_2, F2SYNC,
-		                        ((uint8 *)PKTDATA(osh, pkt)), rdlen, pkt, NULL, NULL);
-		sdio_info->f2rxdata++;
-		ASSERT(sdret != BCME_PENDING);
-
-		if (sdret < 0) {
-			DBUSERR(("%s: read %d %s bytes failed: %d\n", __FUNCTION__, rdlen,
-			           ((chan == SDPCM_EVENT_CHANNEL) ? "event" :
-			            ((chan == SDPCM_DATA_CHANNEL) ? "data" : "test")), sdret));
-			dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-			sdio_info->pub->stats.rx_errors++;
-			dbus_sdio_rxfail(sdio_info, TRUE, RETRYCHAN(chan));
-			continue;
-		}
-
-		/* Copy the already-read portion */
-		PKTPUSH(sdio_info->pub->osh, pkt, firstread);
-		bcopy(sdio_info->rxhdr, PKTDATA(sdio_info->pub->osh, pkt), firstread);
-
-deliver:
-		/* Save superframe descriptor and allocate packet frame */
-		if (chan == SDPCM_GLOM_CHANNEL) {
-			if (SDPCM_GLOMDESC(&sdio_info->rxhdr[SDPCM_FRAMETAG_LEN])) {
-				DBUSGLOM(("%s: got glom descriptor, %d bytes:\n",
-				          __FUNCTION__, len));
-#ifdef BCMDBG
-				if (DBUSGLOM_ON()) {
-					prhex("Glom Data", PKTDATA(sdio_info->pub->osh, pkt), len);
-				}
-#endif
-				PKTSETLEN(sdio_info->pub->osh, pkt, len);
-				ASSERT(doff == SDPCM_HDRLEN);
-				PKTPULL(sdio_info->pub->osh, pkt, SDPCM_HDRLEN);
-				sdio_info->glomd = pkt;
-			} else {
-				DBUSERR(("%s: glom superframe w/o descriptor!\n", __FUNCTION__));
-				dbus_sdio_rxfail(sdio_info, FALSE, FALSE);
-			}
-			continue;
-		}
-
-		/* Fill in packet len and prio, deliver upward */
-		PKTSETLEN(sdio_info->pub->osh, pkt, len);
-		PKTPULL(sdio_info->pub->osh, pkt, doff);
-
-#ifdef SDTEST
-		/* Test channel packets are processed separately */
-		if (chan == SDPCM_TEST_CHANNEL) {
-			dbus_sdio_testrcv(sdio_info, pkt, seq);
-			continue;
-		}
-#endif /* SDTEST */
-
-		if (PKTLEN(sdio_info->pub->osh, pkt) == 0) {
-			dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-			continue;
-		}
-
-		rxirb = (dbus_irb_rx_t *) dbus_sdcb_getirb(sdio_info, FALSE);
-		if (rxirb != NULL) {
-			rxirb->pkt = pkt;
-			dbus_sdio_recv_irb_complete(sdio_info, rxirb, DBUS_OK);
-		} else {
-			DBUSERR(("ERROR: failed to get rx irb\n"));
-			dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-		}
-	}
-
-#ifdef BCMDBG
-	/* Message if we hit the limit */
-	if (!rxleft && !sdtest)
-		DBUSERR(("%s: hit rx limit of %d frames\n", __FUNCTION__, maxframes));
-	else
-#endif /* BCMDBG */
-	DBUSDATA(("%s: processed %d frames\n", __FUNCTION__, (maxframes - rxleft)));
-
-	/* Back off rxseq if awaiting rtx, upate rx_seq */
-	if (sdio_info->rxskip)
-		rxseq--;
-	sdio_info->rx_seq = rxseq;
-
-	return (maxframes - rxleft);
-}
-
-static uint32
-dbus_sdio_hostmail(sdio_info_t *sdio_info)
-{
-	sdpcmd_regs_t *regs = sdio_info->regs;
-	uint32 intstatus = 0;
-	uint32 hmb_data;
-	uint8 fcbits;
-	uint retries = 0;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	/* Read mailbox data and ack that we did so */
-	R_SDREG(hmb_data, &regs->tohostmailboxdata, retries);
-	if (retries <= retry_limit)
-		W_SDREG(SMB_INT_ACK, &regs->tosbmailbox, retries);
-	sdio_info->f1regdata += 2;
-
-	/* Dongle recomposed rx frames, accept them again */
-	if (hmb_data & HMB_DATA_NAKHANDLED) {
-		DBUSINFO(("Dongle reports NAK handled, expect rtx of %d\n", sdio_info->rx_seq));
-		if (!sdio_info->rxskip) {
-			DBUSERR(("%s: unexpected NAKHANDLED!\n", __FUNCTION__));
-		}
-		sdio_info->rxskip = FALSE;
-		intstatus |= I_HMB_FRAME_IND;
-	}
-
-	/*
-	 * Not using DEVREADY or FWREADY at the moment; just print.
-	 * DEVREADY does not occur with gSPI.
-	 */
-	if (hmb_data & (HMB_DATA_DEVREADY | HMB_DATA_FWREADY)) {
-		sdio_info->sdpcm_ver = (hmb_data & HMB_DATA_VERSION_MASK) >> HMB_DATA_VERSION_SHIFT;
-		if (sdio_info->sdpcm_ver != SDPCM_PROT_VERSION)
-			DBUSERR(("Version mismatch, dongle reports %d, expecting %d\n",
-			           sdio_info->sdpcm_ver, SDPCM_PROT_VERSION));
-		else
-			DBUSINFO(("Dongle ready, protocol version %d\n", sdio_info->sdpcm_ver));
-	}
-
-	/*
-	 * Flow Control has been moved into the RX headers and this out of band
-	 * method isn't used any more.  Leae this here for possibly remaining backward
-	 * compatible with older dongles
-	 */
-	if (hmb_data & HMB_DATA_FC) {
-		fcbits = (hmb_data & HMB_DATA_FCDATA_MASK) >> HMB_DATA_FCDATA_SHIFT;
-
-		if (fcbits & ~sdio_info->flowcontrol)
-			sdio_info->fc_xoff++;
-		if (sdio_info->flowcontrol & ~fcbits)
-			sdio_info->fc_xon++;
-
-		sdio_info->fc_rcvd++;
-		sdio_info->flowcontrol = fcbits;
-	}
-
-	/* Shouldn't be any others */
-	if (hmb_data & ~(HMB_DATA_DEVREADY |
-	                 HMB_DATA_NAKHANDLED |
-	                 HMB_DATA_FC |
-	                 HMB_DATA_FWREADY |
-	                 HMB_DATA_FCDATA_MASK |
-	                 HMB_DATA_VERSION_MASK)) {
-		DBUSERR(("Unknown mailbox data content: 0x%02x\n", hmb_data));
-	}
-
-	return intstatus;
-}
-
-#ifndef BCM_DNGL_EMBEDIMAGE
-static void
-dbus_sdh_devrdy_isr(void *handle)
-{
-	probe_sdh_info_t *pinfo = handle;
-	bcmsdh_info_t *sdh = pinfo->sdh;
-	uint32 intstatus = 0, hmb_data = 0;
-
-	if (pinfo->devready == FALSE) {
-		intstatus = R_REG(pinfo->osh, &pinfo->chinfo->sdregs->intstatus);
-		if (intstatus & I_HMB_HOST_INT) {
-			hmb_data = R_REG(pinfo->osh, &pinfo->chinfo->sdregs->tohostmailboxdata);
-			if (hmb_data & (HMB_DATA_DEVREADY|HMB_DATA_FWREADY)) {
-				bcmsdh_intr_disable(sdh);
-				pinfo->devready = TRUE;
-				dbus_sdos_sched_probe_cb();
-
-			}
-		}
-	}
-}
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-static void
-dbus_sdh_isr(void *handle)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-	bool wantdpc;
-
-	ASSERT(sdio_info);
-	ASSERT(sdio_info->sdh);
-
-	if (dbus_sdio_isr(sdio_info, &wantdpc) == TRUE) {
-		bcmsdh_intr_disable(sdio_info->sdh);
-		sdio_info->intdis = TRUE;
-	}
-}
-
-static bool
-dbus_sdio_isr(void *handle, bool *wantdpc)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-	bool handle_int = FALSE;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-
-	/*
-	 * NOTE for NDIS:
-	 *
-	 * Do not use spinlock in isr() to share
-	 * resources with other lower priority functions
-	 * because isr() runs at DIRQL which can preempt
-	 * them and cause race condition/deadlock.
-	 * To share resources with isr() use NdisMSynchronizeWithInterrupt()
-	 * Functions that indirectly use spinlock bcmsdh_reg_read(),
-	 * bcmsdh_intr_disable(), etc.
-	 */
-
-	ASSERT(sdio_info);
-
-	*wantdpc = FALSE;
-
-	/* Count the interrupt call */
-	sdio_info->intrcount++;
-	sdio_info->ipend = TRUE;
-
-	/* Shouldn't get this interrupt if we're sleeping? */
-	if (sdio_info->sleeping) {
-		DBUSERR(("INTERRUPT WHILE SLEEPING??\n"));
-		handle_int = FALSE;
-		goto err;
-	}
-
-	/* Disable additional interrupts (is this needed now)? */
-	if (sdio_info->intr) {
-		DBUSINTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
-	} else {
-		DBUSERR(("dbus_sdio_isr() w/o interrupt configured!\n"));
-	}
-
-	sdio_info->intdis = TRUE;
-
-	dbus_sdos_sched_dpc(sdio_info);
-	sdio_info->dpc_sched = TRUE;
-	*wantdpc = TRUE;
-
-	handle_int = TRUE;
-err:
-	return handle_int;
-}
-
-#ifdef SDTEST
-static void
-dbus_sdio_pktgen_init(sdio_info_t *sdio_info)
-{
-	/* Default to specified length, or full range */
-	if (dhd_pktgen_len) {
-		sdio_info->pktgen_maxlen = MIN(dhd_pktgen_len, MAX_PKTGEN_LEN);
-		sdio_info->pktgen_minlen = sdio_info->pktgen_maxlen;
-	} else {
-		sdio_info->pktgen_maxlen = MAX_PKTGEN_LEN;
-		sdio_info->pktgen_minlen = 0;
-	}
-	sdio_info->pktgen_len = (uint16)sdio_info->pktgen_minlen;
-
-	/* Default to per-watchdog burst with 10s print time */
-	sdio_info->pktgen_freq = 1;
-	sdio_info->pktgen_print = 10000/dhd_watchdog_ms;
-	sdio_info->pktgen_count = (dhd_pktgen * dhd_watchdog_ms + 999) / 1000;
-
-	/* Default to echo mode */
-	sdio_info->pktgen_mode = DHD_PKTGEN_ECHO;
-	sdio_info->pktgen_stop = 1;
-}
-
-static void
-dbus_sdio_pktgen(sdio_info_t *sdio_info)
-{
-	void *pkt;
-	uint8 *data;
-	uint pktcount;
-	uint fillbyte;
-	uint16 len;
-
-	/* Display current count if appropriate */
-	if (sdio_info->pktgen_print && (++sdio_info->pktgen_ptick >= sdio_info->pktgen_print)) {
-		sdio_info->pktgen_ptick = 0;
-		printf("%s: send attempts %d rcvd %d\n",
-		       __FUNCTION__, sdio_info->pktgen_sent, sdio_info->pktgen_rcvd);
-	}
-
-	/* For recv mode, just make sure dongle has started sending */
-	if (sdio_info->pktgen_mode == DHD_PKTGEN_RECV) {
-		if (!sdio_info->pktgen_rcvd)
-			dbus_sdio_sdtest_set(sdio_info, TRUE);
-		return;
-	}
-
-	/* Otherwise, generate or request the specified number of packets */
-	for (pktcount = 0; pktcount < sdio_info->pktgen_count; pktcount++) {
-		/* Stop if total has been reached */
-		if (sdio_info->pktgen_total &&
-			(sdio_info->pktgen_sent >= sdio_info->pktgen_total)) {
-			sdio_info->pktgen_count = 0;
-			break;
-		}
-
-		/* Allocate an appropriate-sized packet */
-		len = sdio_info->pktgen_len;
-		if (!(pkt = dbus_sdcb_pktget(sdio_info,
-			(len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + SDALIGN), TRUE))) {
-			DBUSERR(("%s: dbus_sdio_pktget failed!\n", __FUNCTION__));
-			break;
-		}
-		PKTALIGN(sdio_info->pub->osh, pkt,
-			(len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN), SDALIGN);
-		data = (uint8*)PKTDATA(sdio_info->pub->osh, pkt) + SDPCM_HDRLEN;
-
-		/* Write test header cmd and extra based on mode */
-		switch (sdio_info->pktgen_mode) {
-		case DHD_PKTGEN_ECHO:
-			*data++ = SDPCM_TEST_ECHOREQ;
-			*data++ = (uint8)sdio_info->pktgen_sent;
-			break;
-
-		case DHD_PKTGEN_SEND:
-			*data++ = SDPCM_TEST_DISCARD;
-			*data++ = (uint8)sdio_info->pktgen_sent;
-			break;
-
-		case DHD_PKTGEN_RXBURST:
-			*data++ = SDPCM_TEST_BURST;
-			*data++ = (uint8)sdio_info->pktgen_count;
-			break;
-
-		default:
-			DBUSERR(("Unrecognized pktgen mode %d\n", sdio_info->pktgen_mode));
-			dbus_sdcb_pktfree(sdio_info, pkt, TRUE);
-			sdio_info->pktgen_count = 0;
-			return;
-		}
-
-		/* Write test header length field */
-		*data++ = (len >> 0);
-		*data++ = (len >> 8);
-
-		/* Then fill in the remainder -- N/A for burst, but who cares... */
-		for (fillbyte = 0; fillbyte < len; fillbyte++)
-			*data++ = SDPCM_TEST_FILL(fillbyte, (uint8)sdio_info->pktgen_sent);
-
-		/* Send it */
-		if (dbus_sdio_txpkt(sdio_info, pkt, SDPCM_TEST_CHANNEL)) {
-			sdio_info->pktgen_fail++;
-			if (sdio_info->pktgen_stop &&
-				sdio_info->pktgen_stop == sdio_info->pktgen_fail)
-				sdio_info->pktgen_count = 0;
-		}
-		sdio_info->pktgen_sent++;
-
-		/* Bump length if not fixed, wrap at max */
-		if (++sdio_info->pktgen_len > sdio_info->pktgen_maxlen)
-			sdio_info->pktgen_len = (uint16)sdio_info->pktgen_minlen;
-
-		/* Special case for burst mode: just send one request! */
-		if (sdio_info->pktgen_mode == DHD_PKTGEN_RXBURST)
-			break;
-	}
-}
-
-static void
-dbus_sdio_sdtest_set(sdio_info_t *sdio_info, bool start)
-{
-	void *pkt;
-	uint8 *data;
-
-	/* Allocate the packet */
-	if (!(pkt = dbus_sdcb_pktget(sdio_info,
-		SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + SDALIGN, TRUE))) {
-		DBUSERR(("%s: dbus_sdio_pktget failed!\n", __FUNCTION__));
-		return;
-	}
-	PKTALIGN(sdio_info->pub->osh, pkt, (SDPCM_HDRLEN + SDPCM_TEST_HDRLEN), SDALIGN);
-	data = (uint8*)PKTDATA(sdio_info->pub->osh, pkt) + SDPCM_HDRLEN;
-
-	/* Fill in the test header */
-	*data++ = SDPCM_TEST_SEND;
-	*data++ = start;
-	*data++ = (sdio_info->pktgen_maxlen >> 0);
-	*data++ = (sdio_info->pktgen_maxlen >> 8);
-
-	/* Send it */
-	if (dbus_sdio_txpkt(sdio_info, pkt, SDPCM_TEST_CHANNEL))
-		sdio_info->pktgen_fail++;
-}
-
-
-static void
-dbus_sdio_testrcv(sdio_info_t *sdio_info, void *pkt, uint seq)
-{
-	osl_t *osh;
-	uint8 *data;
-	uint pktlen;
-	uint8 cmd;
-	uint8 extra;
-	uint16 len;
-	uint16 offset;
-
-	osh = sdio_info->pub->osh;
-
-	/* Check for min length */
-	if ((pktlen = PKTLEN(sdio_info->pub->osh, pkt)) < SDPCM_TEST_HDRLEN) {
-		DBUSERR(("dbus_sdio_restrcv: toss runt frame, pktlen %d\n", pktlen));
-		dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-		return;
-	}
-
-	/* Extract header fields */
-	data = PKTDATA(sdio_info->pub->osh, pkt);
-	cmd = *data++;
-	extra = *data++;
-	len = *data++; len += *data++ << 8;
-
-	/* Check length for relevant commands */
-	if (cmd == SDPCM_TEST_DISCARD || cmd == SDPCM_TEST_ECHOREQ || cmd == SDPCM_TEST_ECHORSP) {
-		if (pktlen != len + SDPCM_TEST_HDRLEN) {
-			DBUSERR(("dbus_sdio_testrcv: frame length mismatch, pktlen %d seq %d"
-			           " cmd %d extra %d len %d\n", pktlen, seq, cmd, extra, len));
-			dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-			return;
-		}
-	}
-
-	/* Process as per command */
-	switch (cmd) {
-	case SDPCM_TEST_ECHOREQ:
-		/* Rx->Tx turnaround ok (even on NDIS w/current implementation) */
-		*(uint8 *)(PKTDATA(sdio_info->pub->osh, pkt)) = SDPCM_TEST_ECHORSP;
-		if (dbus_sdio_txpkt(sdio_info, pkt, SDPCM_TEST_CHANNEL) == 0) {
-			sdio_info->pktgen_sent++;
-		} else {
-			sdio_info->pktgen_fail++;
-			dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-		}
-		sdio_info->pktgen_rcvd++;
-		break;
-
-	case SDPCM_TEST_ECHORSP:
-		if (sdio_info->ext_loop) {
-			dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-			sdio_info->pktgen_rcvd++;
-			break;
-		}
-
-		for (offset = 0; offset < len; offset++, data++) {
-			if (*data != SDPCM_TEST_FILL(offset, extra)) {
-				DBUSERR(("dbus_sdio_testrcv: echo data mismatch: "
-				           "offset %d (len %d) expect 0x%02x rcvd 0x%02x\n",
-				           offset, len, SDPCM_TEST_FILL(offset, extra), *data));
-				break;
-			}
-		}
-		dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-		sdio_info->pktgen_rcvd++;
-		break;
-
-	case SDPCM_TEST_DISCARD:
-		dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-		sdio_info->pktgen_rcvd++;
-		break;
-
-	case SDPCM_TEST_BURST:
-	case SDPCM_TEST_SEND:
-	default:
-		DBUSINFO(("dbus_sdio_testrcv: unsupported or unknown command, pktlen %d seq %d"
-		          " cmd %d extra %d len %d\n", pktlen, seq, cmd, extra, len));
-		dbus_sdcb_pktfree(sdio_info, pkt, FALSE);
-		break;
-	}
-
-	/* For recv mode, stop at limie (and tell dongle to stop sending) */
-	if (sdio_info->pktgen_mode == DHD_PKTGEN_RECV) {
-		if (sdio_info->pktgen_total &&
-			(sdio_info->pktgen_rcvd >= sdio_info->pktgen_total)) {
-			sdio_info->pktgen_count = 0;
-			dbus_sdio_sdtest_set(sdio_info, FALSE);
-		}
-	}
-}
-#endif /* SDTEST */
-
-#ifdef SDTEST
-static int
-dbus_sdio_pktgen_get(sdio_info_t *sdio_info, uint8 *arg)
-{
-	dhd_pktgen_t pktgen;
-
-	pktgen.version = DHD_PKTGEN_VERSION;
-	pktgen.freq = sdio_info->pktgen_freq;
-	pktgen.count = sdio_info->pktgen_count;
-	pktgen.print = sdio_info->pktgen_print;
-	pktgen.total = sdio_info->pktgen_total;
-	pktgen.minlen = sdio_info->pktgen_minlen;
-	pktgen.maxlen = sdio_info->pktgen_maxlen;
-	pktgen.numsent = sdio_info->pktgen_sent;
-	pktgen.numrcvd = sdio_info->pktgen_rcvd;
-	pktgen.numfail = sdio_info->pktgen_fail;
-	pktgen.mode = sdio_info->pktgen_mode;
-	pktgen.stop = sdio_info->pktgen_stop;
-
-	bcopy(&pktgen, arg, sizeof(pktgen));
-
-	return 0;
-}
-
-static int
-dbus_sdio_pktgen_set(sdio_info_t *sdio_info, uint8 *arg)
-{
-	dhd_pktgen_t pktgen;
-	uint oldcnt, oldmode;
-
-	bcopy(arg, &pktgen, sizeof(pktgen));
-	if (pktgen.version != DHD_PKTGEN_VERSION)
-		return BCME_BADARG;
-
-	oldcnt = sdio_info->pktgen_count;
-	oldmode = sdio_info->pktgen_mode;
-
-	sdio_info->pktgen_freq = pktgen.freq;
-	sdio_info->pktgen_count = pktgen.count;
-	sdio_info->pktgen_print = pktgen.print;
-	sdio_info->pktgen_total = pktgen.total;
-	sdio_info->pktgen_minlen = pktgen.minlen;
-	sdio_info->pktgen_maxlen = pktgen.maxlen;
-	sdio_info->pktgen_mode = pktgen.mode;
-	sdio_info->pktgen_stop = pktgen.stop;
-
-	sdio_info->pktgen_tick = sdio_info->pktgen_ptick = 0;
-	sdio_info->pktgen_len = MAX(sdio_info->pktgen_len, sdio_info->pktgen_minlen);
-	sdio_info->pktgen_len = MIN(sdio_info->pktgen_len, sdio_info->pktgen_maxlen);
-
-	/* Clear counts for a new pktgen (mode change, or was stopped) */
-	if (sdio_info->pktgen_count && (!oldcnt || oldmode != sdio_info->pktgen_mode))
-		sdio_info->pktgen_sent = sdio_info->pktgen_rcvd = sdio_info->pktgen_fail = 0;
-
-	return 0;
-}
-#endif /* SDTEST */
-
-static int
-dbus_sdio_membytes(probe_sdh_info_t *pinfo, bool write, uint32 address, uint8 *data, uint size)
-{
-	int bcmerror = 0;
-	uint32 sdaddr;
-	uint dsize;
-	bcmsdh_info_t *sdh;
-
-	ASSERT(pinfo->sdh);
-	sdh = pinfo->sdh;
-
-	/* Determine initial transfer parameters */
-	sdaddr = address & SBSDIO_SB_OFT_ADDR_MASK;
-	if ((sdaddr + size) & SBSDIO_SBWINDOW_MASK)
-		dsize = (SBSDIO_SB_OFT_ADDR_LIMIT - sdaddr);
-	else
-		dsize = size;
-
-	/* Set the backplane window to include the start address */
-	if ((bcmerror = bcmsdhsdio_set_sbaddr_window(sdh, address, TRUE))) {
-		DBUSERR(("%s: window change failed\n", __FUNCTION__));
-		goto xfer_done;
-	}
-
-	/* Do the transfer(s) */
-	while (size) {
-		DBUSINFO(("%s: %s %d bytes at offset 0x%08x in window 0x%08x\n",
-		          __FUNCTION__, (write ? "write" : "read"), dsize, sdaddr,
-		          (address & SBSDIO_SBWINDOW_MASK)));
-		if ((bcmerror = bcmsdh_rwdata(sdh, write, sdaddr, data, dsize))) {
-			DBUSERR(("%s: membytes transfer failed\n", __FUNCTION__));
-			break;
-		}
-
-		/* Adjust for next transfer (if any) */
-		if ((size -= dsize)) {
-			data += dsize;
-			address += dsize;
-			if ((bcmerror = bcmsdhsdio_set_sbaddr_window(sdh, address, FALSE))) {
-				DBUSERR(("%s: window change failed\n", __FUNCTION__));
-				break;
-			}
-			sdaddr = 0;
-			dsize = MIN(SBSDIO_SB_OFT_ADDR_LIMIT, size);
-		}
-	}
-
-xfer_done:
-	/* Return the window to backplane enumeration space for core access */
-	if (bcmsdhsdio_set_sbaddr_window(sdh, SI_ENUM_BASE, FALSE)) {
-		DBUSERR(("%s: FAILED to return to SI_ENUM_BASE\n", __FUNCTION__));
-	}
-
-	return bcmerror;
-}
-
-static int
-dbus_sdio_downloadvars(probe_sdh_info_t *pinfo, void *arg, int len)
-{
-	int bcmerror = BCME_OK;
-
-	if (!len) {
-		bcmerror = BCME_BUFTOOSHORT;
-		goto err;
-	}
-
-	if (pinfo->vars) {
-		MFREE(pinfo->osh, pinfo->vars, pinfo->varsz);
-		pinfo->vars = NULL;
-		pinfo->varsz = 0;
-	}
-	pinfo->vars = MALLOC(pinfo->osh, len);
-	pinfo->varsz = pinfo->vars ? len : 0;
-	if (pinfo->vars == NULL) {
-		pinfo->varsz = 0;
-		bcmerror = BCME_NOMEM;
-		goto err;
-	}
-	bcopy(arg, pinfo->vars, pinfo->varsz);
-err:
-	return bcmerror;
-}
-
-static int
-dbus_sdio_doiovar(sdio_info_t *sdio_info, const bcm_iovar_t *vi, uint32 actionid, const char *name,
-                void *params, int plen, void *arg, int len, int val_size)
-{
-	int bcmerror = 0;
-	int32 int_val = 0;
-	bool bool_val;
-
-	DBUSTRACE(("%s: Enter, action %d name %s params %p plen %d arg %p len %d val_size %d\n",
-	           __FUNCTION__, actionid, name, params, plen, arg, len, val_size));
-
-	if ((bcmerror = bcm_iovar_lencheck(vi, arg, len, IOV_ISSET(actionid))) != 0)
-		goto exit;
-
-	if (plen >= (int)sizeof(int_val))
-		bcopy(params, &int_val, sizeof(int_val));
-
-	bool_val = (int_val != 0) ? TRUE : FALSE;
-
-
-	/* Some ioctls use the bus */
-	/* Check if dongle is in reset. If so, only allow DEVRESET iovars */
-	if (sdio_info->dongle_reset && !(actionid == IOV_SVAL(IOV_DEVRESET) ||
-	                                actionid == IOV_GVAL(IOV_DEVRESET))) {
-		bcmerror = BCME_NOTREADY;
-		goto exit;
-	}
-
-	/* Handle sleep stuff before any clock mucking */
-	if (vi->varid == IOV_SLEEP) {
-		if (IOV_ISSET(actionid)) {
-			bcmerror = dbus_sdio_bussleep(sdio_info, bool_val);
-		} else {
-			int_val = (int32)sdio_info->sleeping;
-			bcopy(&int_val, arg, val_size);
-		}
-		goto exit;
-	}
-
-	/* Request clock to allow SDIO accesses */
-	if (!sdio_info->dongle_reset) {
-		BUS_WAKE(sdio_info);
-		dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-	}
-
-	switch (actionid) {
-	case IOV_GVAL(IOV_INTR):
-		int_val = (int32)sdio_info->intr;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_INTR):
-		sdio_info->intr = bool_val;
-		sdio_info->intdis = FALSE;
-
-		/* FIX: Change to use busstate instead of up flag */
-		if (sdio_info->up) {
-			if (sdio_info->intr) {
-				DBUSINTR(("%s: enable SDIO device interrupts\n", __FUNCTION__));
-				bcmsdh_intr_enable(sdio_info->sdh);
-			} else {
-				DBUSINTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
-				bcmsdh_intr_disable(sdio_info->sdh);
-			}
-		}
-		break;
-
-	case IOV_GVAL(IOV_POLLRATE):
-		int_val = (int32)sdio_info->pollrate;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_POLLRATE):
-		sdio_info->pollrate = (uint)int_val;
-		sdio_info->poll = (sdio_info->pollrate != 0);
-		break;
-
-	case IOV_GVAL(IOV_IDLETIME):
-		int_val = sdio_info->idletime;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_IDLETIME):
-		if ((int_val < 0) && (int_val != IDLE_IMMEDIATE)) {
-			bcmerror = BCME_BADARG;
-		} else {
-			sdio_info->idletime = int_val;
-		}
-		break;
-
-	case IOV_GVAL(IOV_IDLECLOCK):
-		int_val = (int32)sdio_info->idleclock;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_IDLECLOCK):
-		sdio_info->idleclock = int_val;
-		break;
-
-	case IOV_GVAL(IOV_SD1IDLE):
-		int_val = (int32)sd1idle;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_SD1IDLE):
-		sd1idle = bool_val;
-		break;
-
-	case IOV_SVAL(IOV_MEMBYTES):
-	case IOV_GVAL(IOV_MEMBYTES):
-	{
-		uint32 address;
-		uint size, dsize;
-		uint8 *data;
-
-		bool set = (actionid == IOV_SVAL(IOV_MEMBYTES));
-
-		ASSERT(plen >= 2*sizeof(int));
-
-		address = (uint32)int_val;
-		bcopy((char *)params + sizeof(int_val), &int_val, sizeof(int_val));
-		size = (uint)int_val;
-
-		/* Do some validation */
-		dsize = set ? plen - (2 * sizeof(int)) : len;
-		if (dsize < size) {
-			DBUSERR(("%s: error on %s membytes, addr 0x%08x size %d dsize %d\n",
-			           __FUNCTION__, (set ? "set" : "get"), address, size, dsize));
-			bcmerror = BCME_BADARG;
-			break;
-		}
-
-		DBUSINFO(("%s: Request to %s %d bytes at address 0x%08x\n", __FUNCTION__,
-		          (set ? "write" : "read"), size, address));
-
-		/* If we know about SOCRAM, check for a fit */
-		if ((sdio_info->orig_ramsize) &&
-		    ((address > sdio_info->orig_ramsize) ||
-			(address + size > sdio_info->orig_ramsize))) {
-			DBUSERR(("%s: ramsize 0x%08x doesn't have %d bytes at 0x%08x\n",
-			           __FUNCTION__, sdio_info->orig_ramsize, size, address));
-			bcmerror = BCME_BADARG;
-			break;
-		}
-
-		/* Generate the actual data pointer */
-		data = set ? (uint8*)params + 2 * sizeof(int): (uint8*)arg;
-
-		/* Call to do the transfer */
-		bcmerror = dbus_sdio_membytes(&g_probe_info, set, address, data, size);
-
-		break;
-	}
-
-	case IOV_GVAL(IOV_MEMSIZE):
-		int_val = (int32)sdio_info->ramsize;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_GVAL(IOV_SDIOD_DRIVE):
-		int_val = (int32)dhd_sdiod_drive_strength;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_SDIOD_DRIVE):
-		dhd_sdiod_drive_strength = int_val;
-		si_sdiod_drive_strength_init(sdio_info->sih,
-			sdio_info->pub->osh, dhd_sdiod_drive_strength);
-		break;
-
-	case IOV_SVAL(IOV_SET_DOWNLOAD_STATE):
-		bcmerror = dbus_sdio_download_state(&g_probe_info, bool_val);
-
-#ifndef BCM_DNGL_EMBEDIMAGE
-		if ((bool_val == FALSE) && (delay_eth == 0)) {
-			g_probe_info.devready = TRUE;
-			sdio_info->pub->busstate = DBUS_STATE_DL_DONE;
-		}
-#endif
-		break;
-
-	case IOV_SVAL(IOV_VARS):
-		bcmerror = dbus_sdio_downloadvars(&g_probe_info, arg, len);
-		break;
-
-	case IOV_GVAL(IOV_READAHEAD):
-		int_val = (int32)dhd_readahead;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_READAHEAD):
-		if (bool_val && !dhd_readahead)
-			sdio_info->nextlen = 0;
-		dhd_readahead = bool_val;
-		break;
-
-	case IOV_GVAL(IOV_SDRXCHAIN):
-		int_val = (int32)sdio_info->use_rxchain;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_SDRXCHAIN):
-		if (bool_val && !sdio_info->sd_rxchain)
-			bcmerror = BCME_UNSUPPORTED;
-		else
-			sdio_info->use_rxchain = bool_val;
-		break;
-
-	case IOV_GVAL(IOV_ALIGNCTL):
-		int_val = (int32)dhd_alignctl;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_ALIGNCTL):
-		dhd_alignctl = bool_val;
-		break;
-
-	case IOV_GVAL(IOV_SDALIGN):
-		int_val = SDALIGN;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-#ifdef BCMDBG
-	case IOV_GVAL(IOV_VARS):
-		if (sdio_info->varsz < (uint)len)
-			bcopy(sdio_info->vars, arg, sdio_info->varsz);
-		else
-			bcmerror = BCME_BUFTOOSHORT;
-		break;
-#endif /* BCMDBG */
-
-#ifdef BCMDBG
-	case IOV_GVAL(IOV_SDREG):
-	{
-		sdreg_t *sd_ptr;
-		uint32 addr, size;
-
-		sd_ptr = (sdreg_t *)params;
-
-		addr = (uintptr)sdio_info->regs + sd_ptr->offset;
-		size = sd_ptr->func;
-		int_val = (int32)bcmsdh_reg_read(sdio_info->sdh, addr, size);
-		if (bcmsdh_regfail(sdio_info->sdh))
-			bcmerror = BCME_SDIO_ERROR;
-		bcopy(&int_val, arg, sizeof(int32));
-		break;
-	}
-
-	case IOV_SVAL(IOV_SDREG):
-	{
-		sdreg_t *sd_ptr;
-		uint32 addr, size;
-
-		sd_ptr = (sdreg_t *)params;
-
-		addr = (uintptr)sdio_info->regs + sd_ptr->offset;
-		size = sd_ptr->func;
-		bcmsdh_reg_write(sdio_info->sdh, addr, size, sd_ptr->value);
-		if (bcmsdh_regfail(sdio_info->sdh))
-			bcmerror = BCME_SDIO_ERROR;
-		break;
-	}
-
-	/* Same as above, but offset is not backplane (not SDIO core) */
-	case IOV_GVAL(IOV_SBREG):
-	{
-		sdreg_t *sd_ptr;
-		uint32 addr, size;
-
-		sd_ptr = (sdreg_t *)params;
-
-		addr = SI_ENUM_BASE + sd_ptr->offset;
-		size = sd_ptr->func;
-		int_val = (int32)bcmsdh_reg_read(sdio_info->sdh, addr, size);
-		if (bcmsdh_regfail(sdio_info->sdh))
-			bcmerror = BCME_SDIO_ERROR;
-		bcopy(&int_val, arg, sizeof(int32));
-		break;
-	}
-
-	case IOV_SVAL(IOV_SBREG):
-	{
-		sdreg_t *sd_ptr;
-		uint32 addr, size;
-
-		sd_ptr = (sdreg_t *)params;
-
-		addr = SI_ENUM_BASE + sd_ptr->offset;
-		size = sd_ptr->func;
-		bcmsdh_reg_write(sdio_info->sdh, addr, size, sd_ptr->value);
-		if (bcmsdh_regfail(sdio_info->sdh))
-			bcmerror = BCME_SDIO_ERROR;
-		break;
-	}
-
-	case IOV_GVAL(IOV_SDCIS):
-	{
-		*(char *)arg = 0;
-
-		bcmstrcat(arg, "\nFunc 0\n");
-		bcmsdh_cis_read(sdio_info->sdh, 0x10, (char *)arg + strlen(arg), 49 * 32);
-		bcmstrcat(arg, "\nFunc 1\n");
-		bcmsdh_cis_read(sdio_info->sdh, 0x11, (char *)arg + strlen(arg), 49 * 32);
-		bcmstrcat(arg, "\nFunc 2\n");
-		bcmsdh_cis_read(sdio_info->sdh, 0x12, (char *)arg + strlen(arg), 49 * 32);
-		break;
-	}
-
-	case IOV_GVAL(IOV_FORCEEVEN):
-		int_val = (int32)forcealign;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_FORCEEVEN):
-		forcealign = bool_val;
-		break;
-
-	case IOV_GVAL(IOV_TXBOUND):
-		int_val = (int32)dhd_txbound;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_TXBOUND):
-		dhd_txbound = (uint)int_val;
-		break;
-
-	case IOV_GVAL(IOV_RXBOUND):
-		int_val = (int32)dhd_rxbound;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_RXBOUND):
-		dhd_rxbound = (uint)int_val;
-		break;
-#endif /* BCMDBG */
-
-#if defined(BCMDBG) || defined(DHD_SPROM)
-	case IOV_SVAL(IOV_SPROM):
-	case IOV_GVAL(IOV_SPROM):
-	{
-		uint32 offset;
-		uint size, dsize;
-
-		bool set = (actionid == IOV_SVAL(IOV_SPROM));
-
-		ASSERT(plen >= 2*sizeof(int));
-
-		offset = (uint32)int_val;
-		bcopy((char *)params + sizeof(int_val), &int_val, sizeof(int_val));
-		size = (uint)int_val;
-
-		/* Avoid bigger size of srom reads that may be requested from app.
-		 * gSPI has only F1 OTP visible from CC.  There is no CIS in gSPI.
-		 */
-		if (sdio_info->bus == SPI_BUS)
-			size = SBSDIO_CIS_SIZE_LIMIT;
-
-		/* Do some validation */
-		dsize = set ? plen - (2 * sizeof(int)) : len;
-		if (dsize < size) {
-			DBUSERR(("%s: error on srom %s, addr 0x%08x size %d dsize %d\n",
-			           __FUNCTION__, (set ? "write" : "read"), offset, size, dsize));
-			bcmerror = BCME_BADARG;
-			break;
-		}
-
-		if ((offset > SROM_MAX) || ((offset + size) > SROM_MAX)) {
-			DBUSERR(("%s: error on srom %s, offset %d size %d exceeds limit %d\n",
-			           __FUNCTION__, (set ? "write" : "read"), offset, size, SROM_MAX));
-			bcmerror = BCME_BADARG;
-			break;
-		}
-
-		if (!set) {
-			if (!ISALIGNED(arg, sizeof(uint16))) {
-				DBUSERR(("%s: srom data pointer %p not word-aligned\n",
-				           __FUNCTION__, arg));
-				bcmerror = BCME_BADARG;
-				break;
-			}
-			bcmerror = srom_read(sdio_info->sih, SD_BUSTYPE,
-				(void*)sdio_info->regs, sdio_info->pub->osh,
-				offset, size, (uint16*)arg, FALSE);
-
-		} else {
-			arg = (void*)((uintptr)arg + 2 * sizeof(int));
-			if (!ISALIGNED(arg, sizeof(uint16))) {
-				DBUSERR(("%s: srom data pointer %p not word-aligned\n",
-				           __FUNCTION__, arg));
-				bcmerror = BCME_BADARG;
-				break;
-			}
-			bcmerror = srom_write(sdio_info->sih, SD_BUSTYPE,
-				(void*)sdio_info->regs, sdio_info->pub->osh,
-				offset, size, (uint16*)arg);
-		}
-		break;
-	}
-#endif 
-
-#ifdef SDTEST
-	case IOV_GVAL(IOV_EXTLOOP):
-		int_val = (int32)sdio_info->ext_loop;
-		bcopy(&int_val, arg, val_size);
-		break;
-
-	case IOV_SVAL(IOV_EXTLOOP):
-		sdio_info->ext_loop = bool_val;
-		break;
-
-	case IOV_GVAL(IOV_PKTGEN):
-		bcmerror = dbus_sdio_pktgen_get(sdio_info, arg);
-		break;
-
-	case IOV_SVAL(IOV_PKTGEN):
-		bcmerror = dbus_sdio_pktgen_set(sdio_info, arg);
-		break;
-#endif /* SDTEST */
-
-
-	case IOV_SVAL(IOV_DEVRESET):
-		DBUSTRACE(("%s: Called set IOV_DEVRESET=%d dongle_reset=%d busstate=%d\n",
-		           __FUNCTION__, bool_val, sdio_info->dongle_reset,
-		           sdio_info->pub->busstate));
-
-		ASSERT(sdio_info->pub->osh);
-
-		/* FIX: Need to change to support async probe callback.
-		 */
-		DBUSERR(("DEVRESET unsupported for async probe callback \n"));
-		break;
-
-		if (bool_val == TRUE) {
-			if (sdio_info->dongle_reset)
-				break;
-			/* Expect app to have torn down any connection before calling */
-			/* Stop the bus, disable F2 */
-			dbus_bus_stop(sdio_info);
-
-			/* Release tx/rx buffer, detach from the dongle */
-			dbus_sdio_release_dongle(sdio_info, sdio_info->pub->osh);
-			dbus_sdio_probe_deinit(&g_probe_info);
-
-			sdio_info->dongle_reset = TRUE;
-			sdio_info->up = FALSE;
-
-			DBUSTRACE(("%s:  WLAN OFF DONE\n", __FUNCTION__));
-			/* App can now remove power from device */
-		} else {
-			/* App must have restored power to device before calling */
-
-			DBUSTRACE(("\n\n%s: == WLAN ON ==\n", __FUNCTION__));
-
-			if (!sdio_info->dongle_reset) {
-				bcmerror = BCME_NOTDOWN;
-				DBUSERR(("%s: Set DEVRESET=FALSE invoked when device is on\n",
-				           __FUNCTION__));
-				break;
-			}
-
-			/* Turn on WLAN */
-			/* Reset SD client */
-			bcmsdh_reset(sdio_info->sdh);
-
-			/* Attempt to re-attach & download */
-			if (dbus_sdio_probe_init(&g_probe_info)) {
-				/* Attempt to download binary to the dongle */
-				if ((dbus_sdio_attach_init(sdio_info, sdio_info->sdh,
-					sdio_info->firmware_path, sdio_info->nvram_path))) {
-					/* Re-init bus, enable F2 transfer */
-					dbus_sdio_init(sdio_info);
-
-					sdio_info->dongle_reset = FALSE;
-					sdio_info->up = TRUE;
-					DBUSTRACE(("%s: == WLAN ON DONE ===\n",
-					           __FUNCTION__));
-				} else
-					bcmerror = BCME_SDIO_ERROR;
-			} else
-				bcmerror = BCME_SDIO_ERROR;
-		}
-		break;
-
-	case IOV_GVAL(IOV_DEVRESET):
-		DBUSTRACE(("%s: Called get IOV_DEVRESET\n", __FUNCTION__));
-
-		/* Get its status */
-		int_val = (bool) sdio_info->dongle_reset;
-		bcopy(&int_val, arg, val_size);
-
-		break;
-
-	default:
-		bcmerror = BCME_UNSUPPORTED;
-		break;
-	}
-
-exit:
-	if ((sdio_info->idletime == IDLE_IMMEDIATE) && !sdio_info->dpc_sched) {
-		sdio_info->activity = FALSE;
-		dbus_sdio_clkctl(sdio_info, CLK_NONE, TRUE);
-	}
-
-	return bcmerror;
-}
-
-static int
-dbus_sdio_write_vars(probe_sdh_info_t *pinfo)
-{
-	int bcmerror = 0;
-	uint32 varsize;
-	uint32 varaddr;
-	char *vbuffer;
-	uint32 varsizew;
-
-	if (!pinfo->varsz || !pinfo->vars)
-		return BCME_OK;
-
-	varsize = ROUNDUP(pinfo->varsz, 4);
-	varaddr = (pinfo->ramsize - 4) - varsize;
-
-	vbuffer = (char*)MALLOC(pinfo->osh, varsize);
-	if (!vbuffer)
-		return BCME_NOMEM;
-
-	bzero(vbuffer, varsize);
-	bcopy(pinfo->vars, vbuffer, pinfo->varsz);
-
-	/* Write the vars list */
-	bcmerror = dbus_sdio_membytes(pinfo, TRUE, varaddr, vbuffer, varsize);
-
-	MFREE(pinfo->osh, vbuffer, varsize);
-
-	/* adjust to the user specified RAM */
-	DBUSINFO(("origram size is %d and used ramsize is %d, vars are at %d, orig varsize is %d\n",
-		pinfo->orig_ramsize, pinfo->ramsize, varaddr, varsize));
-	varsize = ((pinfo->orig_ramsize - 4) - varaddr);
-	varsizew = varsize >> 2;
-	DBUSINFO(("new varsize is %d, varsizew is %d\n", varsize, varsizew));
-
-	/* Write the length to the last word */
-	if (bcmerror) {
-		varsizew = 0;
-		DBUSINFO(("bcmerror : Varsizew is being written as %d\n", varsizew));
-		dbus_sdio_membytes(pinfo, TRUE, (pinfo->orig_ramsize - 4), (uint8*)&varsizew, 4);
-	} else {
-		DBUSINFO(("Varsize is %d and varsizew is %d\n", varsize, varsizew));
-		varsizew = (~varsizew << 16) | (varsizew & 0x0000FFFF);
-		varsizew = htol32(varsizew);
-		DBUSINFO(("Varsizew is 0x%x and htol is 0x%x\n", varsizew, htol32(varsizew)));
-		bcmerror = dbus_sdio_membytes(pinfo, TRUE, (pinfo->orig_ramsize - 4),
-			(uint8*)&varsizew, 4);
-	}
-
-	return bcmerror;
-}
-
-static int
-dbus_sdio_download_state(probe_sdh_info_t *pinfo, bool enter)
-{
-	int bcmerror = 0;
-	si_t *sih;
-
-	ASSERT(pinfo->sih);
-	ASSERT(pinfo->sdh);
-
-	sih = pinfo->sih;
-
-	/* To enter download state, disable ARM and reset SOCRAM.
-	 * To exit download state, simply reset ARM (default is RAM boot).
-	 */
-	if (enter) {
-
-		pinfo->alp_only = TRUE;
-
-		if (!(si_setcore(sih, ARM7S_CORE_ID, 0)) &&
-		    !(si_setcore(sih, ARMCM3_CORE_ID, 0))) {
-			DBUSERR(("%s: Failed to find ARM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-
-		si_core_disable(sih, 0);
-		if (bcmsdh_regfail(pinfo->sdh)) {
-			DBUSERR(("%s: Failed to disable ARM core!\n", __FUNCTION__));
-			bcmerror = BCME_SDIO_ERROR;
-			goto fail;
-		}
-
-		if (!(si_setcore(sih, SOCRAM_CORE_ID, 0))) {
-			DBUSERR(("%s: Failed to find SOCRAM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-
-		si_core_reset(sih, 0, 0);
-		if (bcmsdh_regfail(pinfo->sdh)) {
-			DBUSERR(("%s: Failure trying reset SOCRAM core?\n", __FUNCTION__));
-			bcmerror = BCME_SDIO_ERROR;
-			goto fail;
-		}
-
-		/* Clear the top bit of memory */
-		if (pinfo->ramsize) {
-			uint32 zeros = 0;
-			dbus_sdio_membytes(pinfo, TRUE, pinfo->ramsize - 4, (uint8*)&zeros, 4);
-		}
-	} else {
-		if (!(si_setcore(sih, SOCRAM_CORE_ID, 0))) {
-			DBUSERR(("%s: Failed to find SOCRAM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-
-		if (!si_iscoreup(sih)) {
-			DBUSERR(("%s: SOCRAM core is down after reset?\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-
-		if ((bcmerror = dbus_sdio_write_vars(pinfo))) {
-			DBUSERR(("%s: could not write vars to ram\n", __FUNCTION__));
-			goto fail;
-		}
-
-		if (!si_setcore(sih, PCMCIA_CORE_ID, 0) &&
-		    !si_setcore(sih, SDIOD_CORE_ID, 0)) {
-			DBUSERR(("%s: Can't change back to SDIO core?\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-		W_REG(pinfo->osh, &pinfo->chinfo->sdregs->intstatus, 0xFFFFFFFF);
-
-
-		if (!(si_setcore(sih, ARM7S_CORE_ID, 0)) &&
-		    !(si_setcore(sih, ARMCM3_CORE_ID, 0))) {
-			DBUSERR(("%s: Failed to find ARM core!\n", __FUNCTION__));
-			bcmerror = BCME_ERROR;
-			goto fail;
-		}
-
-		si_core_reset(sih, 0, 0);
-		if (bcmsdh_regfail(pinfo->sdh)) {
-			DBUSERR(("%s: Failure trying to reset ARM core?\n", __FUNCTION__));
-			bcmerror = BCME_SDIO_ERROR;
-			goto fail;
-		}
-
-		/* Allow HT Clock now that the ARM is running. */
-		pinfo->alp_only = FALSE;
-	}
-
-fail:
-	/* Always return to SDIOD core */
-	if (!si_setcore(sih, PCMCIA_CORE_ID, 0))
-		si_setcore(sih, SDIOD_CORE_ID, 0);
-
-	return bcmerror;
-}
-
-static int
-dbus_iovar_process(sdio_info_t *sdio_info, const char *name,
-                 void *params, int plen, void *arg, int len, bool set)
-{
-	const bcm_iovar_t *vi = NULL;
-	int bcmerror = 0;
-	int val_size;
-	uint32 actionid;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	ASSERT(name);
-	ASSERT(len >= 0);
-
-	/* Get MUST have return space */
-	ASSERT(set || (arg && len));
-
-	/* Set does NOT take qualifiers */
-	ASSERT(!set || (!params && !plen));
-
-	/* Look up var locally; if not found pass to host driver */
-	if ((vi = bcm_iovar_lookup(dbus_sdio_iovars, name)) == NULL) {
-		BUS_WAKE(sdio_info);
-
-		/* Turn on clock in case SD command needs backplane */
-		dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-
-		bcmerror = bcmsdh_iovar_op(sdio_info->sdh, name, params, plen, arg, len, set);
-
-		/* Check for bus configuration changes of interest */
-
-		/* If it was divisor change, read the new one */
-		if (set && strcmp(name, "sd_divisor") == 0) {
-			if (bcmsdh_iovar_op(sdio_info->sdh, "sd_divisor", NULL, 0,
-				&sdio_info->sd_divisor, sizeof(int32), FALSE) != BCME_OK) {
-				sdio_info->sd_divisor = -1;
-				DBUSERR(("%s: fail on %s get\n", __FUNCTION__, name));
-			} else {
-				DBUSINFO(("%s: noted %s update, value now %d\n",
-				          __FUNCTION__, name, sdio_info->sd_divisor));
-			}
-		}
-		/* If it was a mode change, read the new one */
-		if (set && strcmp(name, "sd_mode") == 0) {
-			if (bcmsdh_iovar_op(sdio_info->sdh, "sd_mode", NULL, 0,
-			                    &sdio_info->sd_mode, sizeof(int32), FALSE) != BCME_OK) {
-				sdio_info->sd_mode = -1;
-				DBUSERR(("%s: fail on %s get\n", __FUNCTION__, name));
-			} else {
-				DBUSINFO(("%s: noted %s update, value now %d\n",
-				          __FUNCTION__, name, sdio_info->sd_mode));
-			}
-		}
-		/* Similar check for blocksize change */
-		if (set && strcmp(name, "sd_blocksize") == 0) {
-			int32 fnum = 2;
-			if (bcmsdh_iovar_op(sdio_info->sdh, "sd_blocksize", &fnum, sizeof(int32),
-				&sdio_info->blocksize, sizeof(int32), FALSE) != BCME_OK) {
-				sdio_info->blocksize = 0;
-				DBUSERR(("%s: fail on %s get\n", __FUNCTION__, "sd_blocksize"));
-			} else {
-				DBUSINFO(("%s: noted %s update, value now %d\n",
-				          __FUNCTION__, "sd_blocksize", sdio_info->blocksize));
-			}
-		}
-		sdio_info->roundup = MIN(max_roundup, sdio_info->blocksize);
-
-		if ((sdio_info->idletime == IDLE_IMMEDIATE) && !sdio_info->dpc_sched) {
-			sdio_info->activity = FALSE;
-			dbus_sdio_clkctl(sdio_info, CLK_NONE, TRUE);
-		}
-
-		goto exit;
-	}
-
-	DBUSCTL(("%s: %s %s, len %d plen %d\n", __FUNCTION__,
-	         name, (set ? "set" : "get"), len, plen));
-
-	/* set up 'params' pointer in case this is a set command so that
-	 * the convenience int and bool code can be common to set and get
-	 */
-	if (params == NULL) {
-		params = arg;
-		plen = len;
-	}
-
-	if (vi->type == IOVT_VOID)
-		val_size = 0;
-	else if (vi->type == IOVT_BUFFER)
-		val_size = len;
-	else
-		/* all other types are integer sized */
-		val_size = sizeof(int);
-
-	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
-	bcmerror = dbus_sdio_doiovar(sdio_info, vi, actionid,
-		name, params, plen, arg, len, val_size);
-
-exit:
-	return bcmerror;
-}
-
-static int
-dbus_sdio_txctlq_process(void *bus)
-{
-	sdio_info_t *sdio_info = bus;
-	int err = DBUS_OK;
-
-	if (sdio_info->txctl_req.pending == TRUE) {
-		if (sdio_info->txctl_req.is_iovar == FALSE) {
-			ASSERT(sdio_info->txctl_req.ctl.buf);
-			ASSERT(sdio_info->txctl_req.ctl.len);
-
-			err = dbus_sdio_txctl(sdio_info, sdio_info->txctl_req.ctl.buf,
-				sdio_info->txctl_req.ctl.len);
-		} else {
-			err = dbus_iovar_process(sdio_info,
-				sdio_info->txctl_req.iovar.name,
-				sdio_info->txctl_req.iovar.params,
-				sdio_info->txctl_req.iovar.plen,
-				sdio_info->txctl_req.iovar.arg,
-				sdio_info->txctl_req.iovar.len,
-				sdio_info->txctl_req.iovar.set);
-		}
-
-		bzero(&sdio_info->txctl_req, sizeof(sdio_info->txctl_req));
-		dbus_sdio_ctl_complete(sdio_info, DBUS_CBCTL_WRITE, err);
-	}
-
-	return err;
-}
-
-static void
-dbus_sdio_txq_flush(sdio_info_t *sdio_info)
-{
-	int prec_out;
-	struct exec_parms exec_args;
-	pkttag_t *ptag;
-	void *pkt;
-
-	exec_args.pdeq.sdio_info = sdio_info;
-	exec_args.pdeq.tx_prec_map = ALLPRIO;
-	exec_args.pdeq.prec_out = &prec_out;
-
-	/* Cancel all pending pkts */
-	while ((pkt = dbus_sdos_exec_txlock(sdio_info,
-		(exec_cb_t) dbus_prec_pkt_deq_exec, &exec_args)) != NULL) {
-		ptag = (pkttag_t *) PKTTAG(pkt);
-		ASSERT(ptag);
-
-		dbus_sdio_send_irb_complete(sdio_info, ptag->txirb, DBUS_STATUS_CANCELLED);
-		dbus_sdcb_pktfree(sdio_info, pkt, TRUE);
-	}
-}
-
-int
-dbus_sdio_txq_process(void *bus)
-{
-	sdio_info_t *sdio_info = bus;
-	bcmsdh_info_t *sdh;
-	uint framecnt = 0;		  /* Temporary counter of tx/rx frames */
-	uint txlimit = dhd_txbound; /* Tx frames to send before resched */
-
-	dbus_sdos_lock(sdio_info);
-
-	sdh = sdio_info->sdh;
-
-	if (sdio_info->pub->busstate == DBUS_STATE_DOWN) {
-		dbus_sdio_txq_flush(sdio_info);
-		goto exit;
-	}
-
-	/* Send ctl requests first */
-	dbus_sdio_txctlq_process(sdio_info);
-
-	/* If waiting for HTAVAIL, check status */
-	if (sdio_info->clkstate == CLK_PENDING) {
-		int err;
-		uint8 clkctl, devctl = 0;
-
-		/* Read CSR, if clock on switch to AVAIL, else ignore */
-		clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-		if (err) {
-			DBUSERR(("%s: error reading CSR: %d\n", __FUNCTION__, err));
-			sdio_info->pub->busstate = DBUS_STATE_DOWN;
-		}
-
-		DBUSINFO(("DPC: PENDING, devctl 0x%02x clkctl 0x%02x\n", devctl, clkctl));
-
-		if (SBSDIO_HTAV(clkctl)) {
-			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-			if (err) {
-				DBUSERR(("%s: error reading DEVCTL: %d\n",
-				           __FUNCTION__, err));
-				sdio_info->pub->busstate = DBUS_STATE_DOWN;
-			}
-			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
-			if (err) {
-				DBUSERR(("%s: error writing DEVCTL: %d\n",
-				           __FUNCTION__, err));
-				sdio_info->pub->busstate = DBUS_STATE_DOWN;
-			}
-			sdio_info->clkstate = CLK_AVAIL;
-		}
-		else {
-			goto exit;
-		}
-	}
-
-	BUS_WAKE(sdio_info);
-
-	/* Make sure backplane clock is on */
-	dbus_sdio_clkctl(sdio_info, CLK_AVAIL, TRUE);
-	if (sdio_info->clkstate == CLK_PENDING)
-		goto exit;
-
-	/* Send queued frames (limit 1 if rx may still be pending) */
-	if ((sdio_info->clkstate != CLK_PENDING) && !sdio_info->fcstate &&
-	    pktq_mlen(&sdio_info->txq, ~sdio_info->flowcontrol) && txlimit && DATAOK(sdio_info)) {
-		framecnt = dbus_sdio_sendfromq(sdio_info, txlimit);
-	}
-
-	/* FIX: Check ctl requests again
-	 * It's possible to have ctl request while dbus_sdio_sendfromq()
-	 * is active.  Possibly check for pending ctl requests before sending
-	 * each pkt??
-	 */
-	dbus_sdio_txctlq_process(sdio_info);
-
-#ifdef SDTEST
-	/* Generate packets if configured */
-	if (sdio_info->pktgen_count && (++sdio_info->pktgen_tick >= sdio_info->pktgen_freq)) {
-		/* Make sure backplane clock is on */
-		dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-		sdio_info->pktgen_tick = 0;
-		dbus_sdio_pktgen(sdio_info);
-	}
-#endif
-
-exit:
-	dbus_sdos_unlock(sdio_info);
-
-	return DBUS_OK;
-}
-
-static int
-probe_htclk(probe_sdh_info_t *pinfo)
-{
-	int err = 0;
-	uint8 clkctl;
-	bcmsdh_info_t *sdh;
-
-	sdh = pinfo->sdh;
-
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
-		(SBSDIO_ALP_AVAIL_REQ | SBSDIO_HT_AVAIL_REQ), &err);
-	if (err) {
-		DBUSERR(("%s: HT Avail request error: %d\n", __FUNCTION__, err));
-		return BCME_ERROR;
-	}
-
-	clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (err) {
-		DBUSERR(("%s: HT Avail read error: %d\n", __FUNCTION__, err));
-		return BCME_ERROR;
-	}
-
-	if (!SBSDIO_HTAV(clkctl)) {
-		SPINWAIT(((clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-			SBSDIO_FUNC1_CHIPCLKCSR, &err)),
-			!SBSDIO_HTAV(clkctl)), PMU_MAX_TRANSITION_DLY);
-	}
-
-	return err;
-}
-
-int
-probe_dlstart()
-{
-	int err;
-	uint8 clkctl;
-
-	/* Need at least ALP */
-	clkctl = bcmsdh_cfg_read(g_probe_info.sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (!SBSDIO_ALPAV(clkctl))
-		err = probe_htclk(&g_probe_info);
-
-	dbus_sdio_download_state(&g_probe_info, TRUE);
-	g_probe_info.dl_addr = 0;
-	return 0;
-}
-
-int
-probe_dlstop()
-{
-	dbus_sdio_download_state(&g_probe_info, FALSE);
-	g_probe_info.dl_addr = 0;
-	return 0;
-}
-
-int
-probe_dlwrite(uint8 *buf, int count, bool isvars)
-{
-	if (isvars)
-		dbus_sdio_downloadvars(&g_probe_info, buf, count);
-	else {
-		dbus_sdio_membytes(&g_probe_info, TRUE, g_probe_info.dl_addr, buf, count);
-		g_probe_info.dl_addr += count;
-	}
-
-	return 0;
-}
-
-/*
- * Download iovars
- *
- * This handles iovars before dbus_attach() and
- * before bringing up eth interface
- */
-int
-probe_iovar(const char *name, void *params, int plen, void *arg, int len, bool set,
-	void **val, int *val_len)
-{
-	int actionid, err = 0;
-	int32 int_val = 0;
-	bool bool_val;
-	uint8 clkctl;
-	const bcm_iovar_t *vi = NULL;
-
-	if (name)
-		vi = bcm_iovar_lookup(dbus_sdio_iovars, (char *) name);
-
-	if (vi == NULL) {
-		DBUSERR(("Unsupported probe iovar: %s\n", name));
-		return -1;
-	}
-
-	bcopy(params, &int_val, sizeof(int_val));
-	bool_val = (int_val != 0) ? TRUE : FALSE;
-
-	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
-
-	/* Need at least ALP */
-	clkctl = bcmsdh_cfg_read(g_probe_info.sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-	if (!SBSDIO_ALPAV(clkctl))
-		err = probe_htclk(&g_probe_info);
-
-	/* Handle pre-attach() requests */
-	switch (actionid) {
-		case IOV_SVAL(IOV_SET_DOWNLOAD_STATE):
-			err = dbus_sdio_download_state(&g_probe_info, bool_val);
-			g_probe_info.dl_addr = 0;
-		break;
-		case IOV_SVAL(IOV_MEMBYTES): {
-			uint32 address;
-			uint size;
-			char *image;
-
-			address = (uint32)int_val;
-			g_probe_info.dl_addr = address;
-
-			bcopy((char *)params + sizeof(int_val), &int_val, sizeof(int_val));
-			size = (uint)int_val; /* in 2048 (2K) chunks */
-
-			image = (char *)params + sizeof(int_val) + sizeof(int_val);
-			dbus_sdio_membytes(&g_probe_info, TRUE, address, image, size);
-		} break;
-		case IOV_SVAL(IOV_VARS):
-			/* FIX: Need vars len in iovar string */
-		break;
-		case IOV_GVAL(IOV_MEMSIZE):
-			*val = (void *)&g_probe_info.ramsize;
-			*val_len = sizeof(uint32);
-		break;
-		default:
-			DBUSERR(("Pre-attach probe actionid (%d) unsupported\n", actionid));
-		break;
-	}
-
-	return err;
-}
-
-
-static uint
-dbus_sdio_sendfromq(sdio_info_t *sdio_info, uint maxframes)
-{
-	void *pkt;
-	int ret = 0, prec_out;
-	uint cnt = 0;
-	uint datalen;
-	uint8 tx_prec_map;
-	struct exec_parms exec_args;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	tx_prec_map = ~sdio_info->flowcontrol;
-
-	/* Send frames until the limit or some other event */
-	for (cnt = 0; (cnt < maxframes) && DATAOK(sdio_info); cnt++) {
-		exec_args.pdeq.sdio_info = sdio_info;
-		exec_args.pdeq.tx_prec_map = tx_prec_map;
-		exec_args.pdeq.prec_out = &prec_out;
-		pkt = dbus_sdos_exec_txlock(sdio_info,
-			(exec_cb_t) dbus_prec_pkt_deq_exec, &exec_args);
-		if (pkt == NULL)
-			break;
-
-		datalen = PKTLEN(sdio_info->pub->osh, pkt) - SDPCM_HDRLEN;
-
-#ifndef SDTEST
-		ret = dbus_sdio_txpkt(sdio_info, pkt, SDPCM_DATA_CHANNEL);
-#else
-		ret = dbus_sdio_txpkt(sdio_info, pkt,
-			(sdio_info->ext_loop ? SDPCM_TEST_CHANNEL : SDPCM_DATA_CHANNEL));
-#endif
-		if (ret) {
-			sdio_info->pub->stats.tx_errors++;
-			if (sdio_info->pub->busstate == DBUS_STATE_DOWN)
-				break;
-		}
-	}
-
-	return cnt;
-}
-
-static int
-dbus_sdio_txctl(sdio_info_t *sdio_info, uchar *msg, uint msglen)
-{
-	uint8 *frame;
-	uint16 len, pad;
-	uint32 swheader;
-	uint retries = 0;
-	bcmsdh_info_t *sdh = sdio_info->sdh;
-	uint8 doff = 0;
-	int ret = 0;
-	int i;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (sdio_info->dongle_reset)
-		return DBUS_ERR;
-
-	/* Back the pointer to make a room for bus header */
-	frame = msg - SDPCM_HDRLEN;
-	len = (msglen += SDPCM_HDRLEN);
-
-	/* Add alignment padding (optional for ctl frames) */
-	if (dhd_alignctl) {
-		if ((doff = ((uintptr)frame % SDALIGN))) {
-			frame -= doff;
-			len += doff;
-			msglen += doff;
-			bzero(frame, doff + SDPCM_HDRLEN);
-		}
-		ASSERT(doff < SDALIGN);
-	}
-	doff += SDPCM_HDRLEN;
-
-	/* Round send length to next SDIO block */
-	if (sdio_info->roundup && sdio_info->blocksize && (len > sdio_info->blocksize)) {
-		pad = sdio_info->blocksize - (len % sdio_info->blocksize);
-		if ((pad <= sdio_info->roundup) && (pad < sdio_info->blocksize))
-			len += pad;
-	}
-
-	/* Satisfy length-alignment requirements */
-	if (forcealign && (len & (ALIGNMENT - 1)))
-		len = ROUNDUP(len, ALIGNMENT);
-
-	ASSERT(ISALIGNED(frame, 2));
-
-	/* Need to lock here to protect txseq and SDIO tx calls */
-	BUS_WAKE(sdio_info);
-
-	/* Make sure backplane clock is on */
-	dbus_sdio_clkctl(sdio_info, CLK_AVAIL, FALSE);
-
-	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
-	*(uint16*)frame = htol16((uint16)msglen);
-	*(((uint16*)frame) + 1) = htol16(~msglen);
-
-	/* Software tag: channel, sequence number, data offset */
-	swheader = ((SDPCM_CONTROL_CHANNEL << SDPCM_CHANNEL_SHIFT) & SDPCM_CHANNEL_MASK)
-	        | sdio_info->tx_seq | ((doff << SDPCM_DOFFSET_SHIFT) & SDPCM_DOFFSET_MASK);
-	htol32_ua_store(swheader, frame + SDPCM_FRAMETAG_LEN);
-	htol32_ua_store(0, frame + SDPCM_FRAMETAG_LEN + sizeof(swheader));
-	sdio_info->tx_seq = (sdio_info->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
-
-	do {
-		ret = bcmsdh_send_buf(sdh, SI_ENUM_BASE, SDIO_FUNC_2, F2SYNC,
-		                      frame, len, NULL, NULL, NULL);
-		ASSERT(ret != BCME_PENDING);
-
-		if (ret < 0) {
-			/* On failure, abort the command and terminate the frame */
-			DBUSINFO(("%s: sdio error %d, abort command and terminate frame.\n",
-			          __FUNCTION__, ret));
-			sdio_info->tx_sderrs++;
-
-			ret = bcmsdh_abort(sdh, SDIO_FUNC_2);
-			if (ret == BCME_NODEVICE) {
-				dbus_sdio_state_change(sdio_info, DBUS_STATE_DISCONNECT);
-				break;
-			}
-
-#ifdef BCMSPI
-			DBUSERR(("%s: Check Overflow or F2-fifo-not-ready counters."
-			           " gSPI transmit error on control channel.\n", __FUNCTION__));
-#endif /* BCMSPI */
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_FRAMECTRL,
-			                 SFC_WF_TERM, NULL);
-			sdio_info->f1regdata++;
-
-			for (i = 0; i < 3; i++) {
-				uint8 hi, lo;
-				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				                     SBSDIO_FUNC1_WFRAMEBCHI, NULL);
-				lo = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
-				                     SBSDIO_FUNC1_WFRAMEBCLO, NULL);
-				sdio_info->f1regdata += 2;
-				if ((hi == 0) && (lo == 0))
-					break;
-			}
-		}
-	} while ((ret < 0) && retries++ < TXRETRIES);
-
-	if ((sdio_info->idletime == IDLE_IMMEDIATE) && !sdio_info->dpc_sched) {
-		sdio_info->activity = FALSE;
-		dbus_sdio_clkctl(sdio_info, CLK_NONE, TRUE);
-	}
-
-	if (ret)
-		sdio_info->tx_ctlerrs++;
-	else
-		sdio_info->tx_ctlpkts++;
-
-	return ret ? DBUS_ERR : DBUS_OK;
-}
-
-static int
-dbus_sdio_rxctl(sdio_info_t *sdio_info, uchar *msg, uint msglen)
-{
-	uint rxlen = 0;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (sdio_info->dongle_reset)
-		return DBUS_ERR;
-
-	/* FIX: Since rxctl() is async, need to fix case where ctl pkt is recevied
-	 * before this function is called.  We need to buffer incoming ctl pkts.
-	 */
-	rxlen = sdio_info->rxlen;
-	bcopy(sdio_info->rxctl, msg, MIN(msglen, rxlen));
-	sdio_info->rxlen = 0;
-
-	return DBUS_OK;
-}
-
-
-
-
-static void *
-dbus_sdh_probe(uint16 venid, uint16 devid, uint16 bus_no, uint16 slot,
-	uint16 func, uint bustype, void *regsva, osl_t * osh,
-	void *sdh)
-{
-	int err;
-	void *prarg;
-#ifndef BCMSPI
-	uint8 clkctl = 0;
-#endif /* !BCMSPI */
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	prarg = NULL;
-	/* We make assumptions about address window mappings */
-	ASSERT((uintptr)regsva == SI_ENUM_BASE);
-
-	/* BCMSDH passes venid and devid based on CIS parsing -- but low-power start
-	 * means early parse could fail, so here we should get either an ID
-	 * we recognize OR (-1) indicating we must request power first.
-	 */
-	/* Check the Vendor ID */
-	switch (venid) {
-		case 0x0000:
-		case VENDOR_BROADCOM:
-			break;
-		default:
-			DBUSERR(("%s: unknown vendor: 0x%04x\n",
-			           __FUNCTION__, venid));
-			return NULL;
-			break;
-	}
-
-	if (devid == 0)
-		devid = bcmsdh_reg_read(sdh, SI_ENUM_BASE, 4) & CID_ID_MASK;
-
-	/* Check the Device ID and make sure it's one that we support */
-	switch (devid) {
-		case BCM4325_CHIP_ID:
-		case BCM4325_D11DUAL_ID:		/* 4325 802.11a/g id */
-		case BCM4325_D11G_ID:			/* 4325 802.11g 2.4Ghz band id */
-		case BCM4325_D11A_ID:			/* 4325 802.11a 5Ghz band id */
-			DBUSERR(("%s: found 4325 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo =  &chipinfo_4325_15;
-			break;
-		case BCM4329_D11N_ID:		/* 4329 802.11n dualband device */
-		case BCM4329_D11N2G_ID:		/* 4329 802.11n 2.4G device */
-		case BCM4329_D11N5G_ID:		/* 4329 802.11n 5G device */
-		case BCM4321_D11N2G_ID:
-			DBUSERR(("%s: found 4329 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo =  &chipinfo_4329;
-			break;
-		case BCM4315_CHIP_ID:
-		case BCM4315_D11G_ID:			/* 4315 802.11g id */
-		case BCM4315_D11A_ID:			/* 4315 802.11a id */
-			DBUSINFO(("%s: found 4315 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo =  &chipinfo_4325_15;
-			break;
-		case BCM4336_D11N_ID:
-			DBUSINFO(("%s: found 4336 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo =  &chipinfo_4336;
-			break;
-
-		case BCM4330_D11N_ID:
-			DBUSINFO(("%s: found 4330 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo =  &chipinfo_4330;
-			break;
-
-		case BCM43237_D11N_ID:
-			DBUSINFO(("%s: found 43237 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo =  &chipinfo_43237;
-			break;
-
-		case BCM4314_CHIP_ID:
-			DBUSINFO(("%s: found 4314 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo = &chipinfo_4314;
-			break;
-
-		case BCM4334_CHIP_ID:
-			DBUSINFO(("%s: found 4334 Dongle\n", __FUNCTION__));
-			g_probe_info.chinfo = &chipinfo_4334;
-			break;
-
-		case 0:
-			DBUSINFO(("%s: allow device id 0, will check chip internals\n",
-			          __FUNCTION__));
-			/* FIX: Need to query chip */
-			g_probe_info.chinfo =  &chipinfo_4325_15;
-			break;
-
-		default:
-			DBUSERR(("%s: skipping 0x%04x/0x%04x, not a dongle\n",
-			           __FUNCTION__, venid, devid));
-			return NULL;
-			break;
-	}
-
-	if (osh == NULL) {
-		/* FIX: This osh is needed for si_attach() and R_REG()
-		 * If we simplify and do away with si_attach() at this stage,
-		 * then remove this as well.
-		 */
-		/* FIX: Linux needs this, but not NDIS
-		 * Remove this LINUX define;  Don't put
-		 * OS defines in this file.
-		 * Have DBUS maintain it's own osh and remove it from
-		 * dbus_attach() as an argument.
-		 */
-		osh = osl_attach(NULL, SD_BUSTYPE, TRUE);
-		g_probe_info.free_probe_osh = TRUE;
-	}
-	ASSERT(osh);
-
-	g_probe_info.venid = venid;
-	g_probe_info.devid = devid;
-	g_probe_info.bus_no = bus_no;
-	g_probe_info.slot = slot;
-	g_probe_info.func = func;
-	g_probe_info.bustype = bustype;
-	g_probe_info.regsva = regsva;
-	g_probe_info.osh = osh;
-	g_probe_info.sdh = sdh;
-	g_probe_info.firmware_file = NULL;
-	g_probe_info.nvram_file = NULL;
-
-	ASSERT(g_probe_info.chinfo);
-	g_probe_info.ramsize = g_probe_info.orig_ramsize = g_probe_info.chinfo->socram_size;
-
-#ifndef BCMSPI  /* wake-wlan in gSPI will bring up the htavail/alpavail clocks. */
-	/* Force PLL off until si_attach() programs PLL control regs */
-
-
-
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, DHD_INIT_CLKCTL1, &err);
-	if (!err)
-		clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-
-	if (err || ((clkctl & ~SBSDIO_AVBITS) != DHD_INIT_CLKCTL1)) {
-		DBUSERR(("dbus_sdio_probe: ChipClkCSR access: err %d wrote 0x%02x read 0x%02x\n",
-			err, DHD_INIT_CLKCTL1, clkctl));
-		return NULL;
-	}
-#endif /* !BCMSPI */
-
-	/* The si_attach() will provide an SI handle, scan the
-	 * backplane, and initialize the PLL.
-	 */
-	if (!(g_probe_info.sih = si_attach((uint)devid, osh, regsva, SD_BUSTYPE, sdh,
-	                           &g_probe_info.vars, &g_probe_info.varsz))) {
-		DBUSERR(("%s: si_attach failed!\n", __FUNCTION__));
-		return NULL;
-	}
-
-	ASSERT(g_probe_info.orig_ramsize == si_socram_size(g_probe_info.sih));
-
-	/* FIX: this is needed on some boards for download.  If not, it can
-	 * cause data errors if drive strength is not correct.
-	 * Default is 10mA, but 6mA is optimal.
-	 */
-	si_sdiod_drive_strength_init(g_probe_info.sih, osh, dhd_sdiod_drive_strength);
-
-
-	/* prepare dongle for download */
-	if (!(dbus_sdio_probe_init(&g_probe_info))) {
-		DBUSERR(("%s: dbus_sdio_probe_init failed\n", __FUNCTION__));
-		return NULL;
-	}
-
-	/* Set up the interrupt mask */
-	W_REG(osh, &g_probe_info.chinfo->sdregs->hostintmask, HOSTINTMASK);
-
-#ifdef BCM_DNGL_EMBEDIMAGE
-	prarg = dbus_sdio_probe_cb(&g_probe_info, "", SD_BUSTYPE, SDPCM_RESERVE);
-
-	if (prarg != NULL)
-		return &g_probe_info;
-	else
-		return NULL;
-#else
-	dbus_sdio_alpclk(sdh);
-
-	if (delay_eth == 0) {
-		dbus_sdio_probe_cb(&g_probe_info, "", SD_BUSTYPE, SDPCM_RESERVE);
-	} else {
-		DBUSERR(("Delay eth1 bringup\n"));
-		/*
-		 * Enable interrupt for DEVREADY when a valid image is downloaded
-		 */
-		bcmsdh_intr_disable(sdh);
-
-		if ((err = bcmsdh_intr_reg(sdh, dbus_sdh_devrdy_isr, &g_probe_info)) != 0) {
-			DBUSERR(("%s: FAILED: bcmsdh_intr_reg returned %d\n",
-				__FUNCTION__, err));
-		}
-
-		bcmsdh_intr_enable(sdh);
-	}
-
-	return &g_probe_info;
-#endif /* BCM_DNGL_EMBEDIMAGE */
-}
-
-static void
-dbus_sdh_disconnect(void *ptr)
-{
-	probe_sdh_info_t *pinfo = (probe_sdh_info_t *)ptr;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (pinfo == NULL) {
-		DBUSERR(("%s: pinfo is NULL\n", __FUNCTION__));
-		return;
-	}
-	dbus_sdio_disconnect_cb(NULL);
-
-	/* After this point, sdio_info is free'd;
-	 * Clean up stuff from dbus_sdh_probe()
-	 */
-	dbus_sdio_probe_deinit(pinfo);
-
-	if (pinfo->sih) {
-		si_detach(pinfo->sih);
-		if (pinfo->vars && pinfo->varsz) {
-			MFREE(pinfo->osh, pinfo->vars, pinfo->varsz);
-		}
-	}
-
-	if (pinfo->osh && (pinfo->free_probe_osh == TRUE)) {
-		if (MALLOCED(pinfo->osh)) {
-			DBUSERR(("%s: PROBE MEMORY LEAK %d bytes\n", __FUNCTION__,
-				MALLOCED(pinfo->osh)));
-		}
-		osl_detach(pinfo->osh);
-	}
-}
-
-static bool
-dbus_sdio_probe_init(probe_sdh_info_t *pinfo)
-{
-	bcmsdh_info_t	*sdh;	/* Handle for BCMSDH calls */
-	osl_t *osh;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	ASSERT(pinfo);
-	ASSERT(pinfo->sdh);
-	ASSERT(pinfo->osh);
-
-	sdh = pinfo->sdh;
-	osh = pinfo->osh;
-
-	pinfo->alp_only = TRUE;
-	pinfo->devready = FALSE;
-
-#ifdef BCMDBG
-	/* Return the window to backplane enumeration space for core access */
-	if (bcmsdhsdio_set_sbaddr_window(sdh, SI_ENUM_BASE, TRUE)) {
-		DBUSERR(("%s: FAILED to return to SI_ENUM_BASE\n", __FUNCTION__));
-		goto fail;
-	}
-
-	if (CHIPTYPE(pinfo->sih->socitype) != SOCI_AI) {
-		printf("F1 signature read @0x18000ffc=0x%4x\n",
-			bcmsdh_reg_read(sdh, SI_ENUM_BASE + 0xffc, 4));
-	}
-
-	printf("F1 signature read @0x18000000=0x%4x\n",
-	       bcmsdh_reg_read(sdh, SI_ENUM_BASE, 4));
-
-#endif /* BCMDBG */
-
-	/* Set core control so an SDIO reset does a backplane reset */
-	OR_REG(osh, &pinfo->chinfo->sdregs->corecontrol, CC_BPRESEN);
-
-	return TRUE;
-
-#ifdef BCMDBG
-fail:
-#endif
-	return FALSE;
-}
-
-static void
-dbus_sdio_probe_deinit(probe_sdh_info_t *pinfo)
-{
-	int err;
-
-	ASSERT(pinfo);
-	/* FIX: Not consolidating this with dbus_sdh_disconnect
-	 * because it's used during DEVRESET.  Need to resolve.
-	 */
-	if (pinfo->sih) {
-		bcmsdh_cfg_write(pinfo->sdh, SDIO_FUNC_1,
-			SBSDIO_FUNC1_CHIPCLKCSR, SBSDIO_HT_AVAIL_REQ, &err);
-		si_watchdog(pinfo->sih, 4);
-		bcmsdh_cfg_write(pinfo->sdh, SDIO_FUNC_1,
-			SBSDIO_FUNC1_CHIPCLKCSR, 0, &err);
-	}
-}
-
-
-bool
-dbus_sdio_attach_init(sdio_info_t *sdio_info, void *sdh, char *firmware_path,
-                       char * nvram_path)
-{
-	int ret;
-	int32 fnum;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-#ifdef SDTEST
-	dbus_sdio_pktgen_init(sdio_info);
-#endif /* SDTEST */
-
-#ifndef BCMSPI
-	/* Disable F2 to clear any intermediate frame state on the dongle */
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
-#endif /* !BCMSPI */
-
-#ifndef BCMSPI
-	/* Done with backplane-dependent accesses, can drop clock... */
-	bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, 0, NULL);
-	sdio_info->clkstate = CLK_SDONLY;
-#endif /* !BCMSPI */
-
-	/* Query the SD clock speed */
-	if (bcmsdh_iovar_op(sdh, "sd_divisor", NULL, 0,
-	                    &sdio_info->sd_divisor, sizeof(int32), FALSE) != BCME_OK) {
-		DBUSERR(("%s: fail on %s get\n", __FUNCTION__, "sd_divisor"));
-		sdio_info->sd_divisor = -1;
-	} else {
-		DBUSINFO(("%s: Initial value for %s is %d\n",
-		          __FUNCTION__, "sd_divisor", sdio_info->sd_divisor));
-	}
-
-	/* Query the SD bus mode */
-	if (bcmsdh_iovar_op(sdh, "sd_mode", NULL, 0,
-	                    &sdio_info->sd_mode, sizeof(int32), FALSE) != BCME_OK) {
-		DBUSERR(("%s: fail on %s get\n", __FUNCTION__, "sd_mode"));
-		sdio_info->sd_mode = -1;
-	} else {
-		DBUSINFO(("%s: Initial value for %s is %d\n",
-		          __FUNCTION__, "sd_mode", sdio_info->sd_mode));
-	}
-
-	/* Query the F2 block size, set roundup accordingly */
-	fnum = 2;
-	if (bcmsdh_iovar_op(sdh, "sd_blocksize", &fnum, sizeof(int32),
-	                    &sdio_info->blocksize, sizeof(int32), FALSE) != BCME_OK) {
-		sdio_info->blocksize = 0;
-		DBUSERR(("%s: fail on %s get\n", __FUNCTION__, "sd_blocksize"));
-	} else {
-		DBUSINFO(("%s: Initial value for %s is %d\n",
-		          __FUNCTION__, "sd_blocksize", sdio_info->blocksize));
-	}
-	sdio_info->roundup = MIN(max_roundup, sdio_info->blocksize);
-
-	/* Query if bus module supports packet chaining, default to use if supported */
-	if (bcmsdh_iovar_op(sdh, "sd_rxchain", NULL, 0,
-	                    &sdio_info->sd_rxchain, sizeof(int32), FALSE) != BCME_OK) {
-		sdio_info->sd_rxchain = FALSE;
-	} else {
-		DBUSINFO(("%s: bus module (through bcmsdh API) %s chaining\n",
-		          __FUNCTION__, (sdio_info->sd_rxchain ? "supports" : "does not support")));
-	}
-	sdio_info->use_rxchain = (bool)sdio_info->sd_rxchain;
-
-	/* Register interrupt callback, but mask it (not operational yet). */
-	DBUSINTR(("%s: disable SDIO interrupts (not interested yet)\n", __FUNCTION__));
-	bcmsdh_intr_disable(sdh);
-	if ((ret = bcmsdh_intr_reg(sdh, dbus_sdh_isr, sdio_info)) != 0) {
-		DBUSERR(("%s: FAILED: bcmsdh_intr_reg returned %d\n",
-		           __FUNCTION__, ret));
-		goto fail;
-	}
-	DBUSINTR(("%s: registered SDIO interrupt function ok\n", __FUNCTION__));
-
-	return TRUE;
-
-fail:
-	return FALSE;
-}
-
-static void
-dbus_sdio_release(sdio_info_t *sdio_info, osl_t *osh)
-{
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (sdio_info) {
-		ASSERT(osh);
-		dbus_sdio_release_dongle(sdio_info, osh);
-	}
-}
-
-static void
-dbus_sdio_release_dongle(sdio_info_t *sdio_info, osl_t *osh)
-{
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (sdio_info->dongle_reset)
-		return;
-
-	if (sdio_info->rxbuf) {
-		MFREE(osh, sdio_info->rxbuf, sdio_info->rxblen);
-		sdio_info->rxctl = sdio_info->rxbuf = NULL;
-		sdio_info->rxlen = 0;
-	}
-
-	if (sdio_info->databuf) {
-		MFREE(osh, sdio_info->databuf, MAX_DATA_BUF);
-		sdio_info->databuf = NULL;
-	}
-}
-
-#ifdef BCM_DNGL_EMBEDIMAGE
-int
-dhd_bus_download_image_array(probe_sdh_info_t *pinfo, char * nvram_path, uint8 *fw, int len)
-{
-	int bcmerror = -1;
-	int offset = 0;
-
-	/* Download image */
-	while ((offset + MEMBLOCK) < len) {
-		bcmerror = dbus_sdio_membytes(pinfo, TRUE,
-			offset, fw + offset, MEMBLOCK);
-		if (bcmerror) {
-			DBUSERR(("%s: error %d on writing %d membytes at 0x%08x\n",
-			        __FUNCTION__, bcmerror, MEMBLOCK, offset));
-			goto err;
-		}
-
-		offset += MEMBLOCK;
-	}
-
-	if (offset < len) {
-		bcmerror = dbus_sdio_membytes(pinfo, TRUE, offset,
-			fw + offset, len - offset);
-		if (bcmerror) {
-			DBUSERR(("%s: error %d on writing %d membytes at 0x%08x\n",
-			        __FUNCTION__, bcmerror, len - offset, offset));
-			goto err;
-		}
-	}
-
-	/* Download SROM if provided externally through file */
-	dhd_bus_download_nvram_file(pinfo, nvram_path);
-err:
-	return bcmerror;
-}
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-
-/*
- * ProcessVars:Takes a buffer of "<var>=<value>\n" lines read from a file and ending in a NUL.
- * Removes carriage returns, empty lines, comment lines, and converts newlines to NULs.
- * Shortens buffer as needed and pads with NULs.  End of buffer is marked by two NULs.
-*/
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-int
-dhd_bus_download_nvram_file(probe_sdh_info_t *pinfo, char * nvram_path)
-{
-	int bcmerror = -1;
-	uint len = 0;
-	void * image = NULL;
-	uint8 * memblock = NULL;
-	char *bufp;
-
-	if (!nvram_path[0])
-		return 0;
-
-	/* FIX: Need to implement dhd_os_open_image() */
-	/* image = dhd_os_open_image(nvram_path); */
-	if (image == NULL)
-		goto err;
-
-	memblock = MALLOC(pinfo->osh, MEMBLOCK);
-	if (memblock == NULL) {
-		DBUSERR(("%s: Failed to allocate memory %d bytes\n",
-		           __FUNCTION__, MEMBLOCK));
-		goto err;
-	}
-
-	/* Download variables */
-	/* FIX: Need to implement dhd_os_get_image_block() */
-	/* len = dhd_os_get_image_block(memblock, MEMBLOCK, image); */
-
-	if (len != MEMBLOCK && len > 0) {
-		bufp = (char *)memblock;
-		len = process_nvram_vars(bufp, len);
-		if (len % 4)
-			len += (4 - len % 4);
-		bufp += len;
-		*bufp++ = 0;
-		if (len)
-			bcmerror = dbus_sdio_downloadvars(pinfo, memblock, len + 1);
-		if (bcmerror) {
-			DBUSERR(("%s: error downloading vars: %d\n",
-			           __FUNCTION__, bcmerror));
-		}
-	} else {
-		DBUSERR(("%s: error reading nvram file: %d\n",
-		           __FUNCTION__, len));
-		bcmerror = BCME_SDIO_ERROR;
-	}
-
-err:
-	if (memblock)
-		MFREE(pinfo->osh, memblock, MEMBLOCK);
-
-	/* FIX: Need to implement dhd_os_close_image() */
-
-	return bcmerror;
-}
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-static void
-dbus_sdos_lock(sdio_info_t *sdio_info)
-{
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->drvintf && sdio_info->drvintf->lock)
-		sdio_info->drvintf->lock(sdio_info->sdos_info);
-	else
-		ASSERT(0);
-
-	ASSERT(sdio_info->sdlocked == FALSE);
-	sdio_info->sdlocked = TRUE;
-}
-
-static void
-dbus_sdos_unlock(sdio_info_t *sdio_info)
-{
-	ASSERT(sdio_info->sdlocked == TRUE);
-	sdio_info->sdlocked = FALSE;
-
-	if (sdio_info->drvintf && sdio_info->drvintf->unlock)
-		sdio_info->drvintf->unlock(sdio_info->sdos_info);
-	else
-		ASSERT(0);
-}
-
-static void *
-dbus_sdos_exec_txlock(sdio_info_t *sdio_info, exec_cb_t cb, struct exec_parms *args)
-{
-	ASSERT(cb);
-	if (sdio_info->drvintf && sdio_info->drvintf->exec_txlock)
-		return sdio_info->drvintf->exec_txlock(sdio_info->sdos_info, cb, args);
-
-	return NULL;
-}
-
-static void *
-dbus_sdcb_pktget(sdio_info_t *sdio_info, uint len, bool send)
-{
-	void *p = NULL;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (sdio_info == NULL)
-		return NULL;
-
-	if (sdio_info->cbs && sdio_info->cbs->pktget)
-		p = sdio_info->cbs->pktget(sdio_info->cbarg, len, send);
-
-	return p;
-}
-
-static void
-dbus_sdcb_pktfree(sdio_info_t *sdio_info, void *p, bool send)
-{
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->pktfree)
-		sdio_info->cbs->pktfree(sdio_info->cbarg, p, send);
-}
-
-static dbus_irb_t *
-dbus_sdcb_getirb(sdio_info_t *sdio_info, bool send)
-{
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (sdio_info == NULL)
-		return NULL;
-
-	if (sdio_info->cbs && sdio_info->cbs->getirb)
-		return sdio_info->cbs->getirb(sdio_info->cbarg, send);
-
-	return NULL;
-}
-
-/*
- * Interface functions
- */
-static int
-dbus_sdif_send_irb(void *bus, dbus_irb_tx_t *txirb)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err;
-
-	if (sdio_info == NULL)
-		return DBUS_ERR;
-
-	err = dbus_sdio_txbuf_submit(sdio_info, txirb);
-	if (err != DBUS_OK) {
-		err = DBUS_ERR_TXFAIL;
-	}
-
-	return err;
-}
-
-static int
-dbus_sdif_send_ctl(void *bus, uint8 *buf, int len)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err = DBUS_OK;
-
-	if (sdio_info == NULL)
-		return DBUS_ERR;
-
-	if (sdio_info->txctl_req.pending == TRUE) {
-		DBUSERR(("%s: ctl is pending!\n", __FUNCTION__));
-		return DBUS_ERR_PENDING;
-	}
-
-	sdio_info->txctl_req.ctl.buf = buf;
-	sdio_info->txctl_req.ctl.len = len;
-	sdio_info->txctl_req.is_iovar = FALSE;
-	sdio_info->txctl_req.pending = TRUE;
-	dbus_sdio_txq_sched(sdio_info->sdos_info);
-	return err;
-}
-
-static int
-dbus_sdif_recv_ctl(void *bus, uint8 *buf, int len)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-
-	if (sdio_info == NULL)
-		return DBUS_ERR;
-
-	if (sdio_info->rxctl_req.pending == TRUE) {
-		DBUSERR(("%s: ctl is pending!\n", __FUNCTION__));
-		return DBUS_ERR_PENDING;
-	}
-
-	/* Do have a rxctl pkt available? */
-	if (sdio_info->rxlen > 0) {
-		dbus_sdio_rxctl(sdio_info, buf, len);
-		dbus_sdio_ctl_complete(sdio_info, DBUS_CBCTL_READ, DBUS_OK);
-	} else {
-		sdio_info->rxctl_req.ctl.buf = buf;
-		sdio_info->rxctl_req.ctl.len = len;
-		sdio_info->rxctl_req.pending = TRUE;
-	}
-	return DBUS_OK;
-}
-
-static int
-dbus_sdif_up(void *bus)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err = DBUS_ERR;
-
-	if (sdio_info == NULL)
-		return DBUS_ERR;
-
-	if (sdio_info->drvintf && sdio_info->drvintf->up) {
-		err = sdio_info->drvintf->up(sdio_info->sdos_info);
-	}
-
-	dbus_sdos_lock(sdio_info);
-	err = dbus_sdio_init(sdio_info);
-	if (err != 0)
-		err = DBUS_ERR;
-	dbus_sdos_unlock(sdio_info);
-
-	return err;
-}
-
-static int
-dbus_sdif_iovar_op(void *bus, const char *name,
-	void *params, int plen, void *arg, int len, bool set)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err = DBUS_OK;
-
-	if (sdio_info == NULL)
-		return DBUS_ERR;
-
-	err = dbus_iovar_process(sdio_info, name, params, plen, arg, len, set);
-	return err;
-}
-
-static bool
-dbus_sdif_device_exists(void *bus)
-{
-	return TRUE;
-}
-
-static bool
-dbus_sdif_dlneeded(void *bus)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-
-	if (sdio_info == NULL)
-		return FALSE;
-
-#ifdef BCM_DNGL_EMBEDIMAGE
-	return (g_probe_info.devready == FALSE);
-#else
-	return FALSE;
-#endif
-}
-
-static int
-dbus_sdif_dlstart(void *bus, uint8 *fw, int len)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err = DBUS_ERR;
-
-	if (sdio_info == NULL)
-		return DBUS_ERR;
-
-	dbus_sdio_alpclk(g_probe_info.sdh);
-	sdio_info->clkstate = CLK_AVAIL;
-
-	/* Put ARM in reset for download */
-	err = dbus_sdio_download_state(&g_probe_info, TRUE);
-	if (err) {
-		DBUSERR(("%s: error placing ARM core in reset\n", __FUNCTION__));
-		err = DBUS_ERR;
-		goto err;
-	}
-
-	/* FIX: Which embedded image has priority?
-	 */
-#ifdef BCM_DNGL_EMBEDIMAGE
-	if (dhd_bus_download_image_array(&g_probe_info, nvram_path, fw, len)) {
-		DBUSERR(("%s: dongle image download failed\n", __FUNCTION__));
-		err = DBUS_ERR;
-		goto err;
-	}
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-	/* FIX: Skip this for now
-	 * If above succeeds, do we still download this one?
-	 */
-
-	err = DBUS_OK;
-	g_probe_info.devready = TRUE;
-	sdio_info->pub->busstate = DBUS_STATE_DL_DONE;
-err:
-	return err;
-}
-
-static int
-dbus_sdif_dlrun(void *bus)
-{
-	sdio_info_t *sdio_info;
-	int err = DBUS_ERR;
-
-	sdio_info = BUS_INFO(bus, sdio_info_t);
-
-	/* Take ARM out of reset */
-	err = dbus_sdio_download_state(&g_probe_info, FALSE);
-	if (err) {
-		DBUSERR(("%s: error getting out of ARM reset\n", __FUNCTION__));
-		err = DBUS_ERR;
-	} else
-		err = DBUS_OK;
-
-	return err;
-}
-
-static int
-dbus_sdif_stop(void *bus)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err;
-
-	if (sdio_info->drvintf && sdio_info->drvintf->stop)
-		err = sdio_info->drvintf->stop(sdio_info->sdos_info);
-
-	dbus_bus_stop(sdio_info);
-	return DBUS_OK;
-}
-
-static int
-dbus_sdif_down(void *bus)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	int err;
-
-	if (sdio_info->drvintf && sdio_info->drvintf->down)
-		err = sdio_info->drvintf->down(sdio_info->sdos_info);
-
-	dbus_bus_stop(sdio_info);
-	return DBUS_OK;
-}
-
-static int
-dbus_sdif_get_attrib(void *bus, dbus_attrib_t *attrib)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-
-	if ((sdio_info == NULL) || (attrib == NULL))
-		return DBUS_ERR;
-
-	attrib->bustype = DBUS_SDIO;
-	attrib->vid = g_probe_info.venid;
-	attrib->pid = 0;
-	attrib->devid = g_probe_info.devid;
-	attrib->nchan = 1;
-	attrib->mtu = 512;
-
-	return DBUS_OK;
-}
-
-static int
-dbus_sdos_sched_dpc(sdio_info_t *sdio_info)
-{
-	if (sdio_info->pub->busstate == DBUS_STATE_DOWN) {
-		DBUSERR(("Bus down. Do not sched dpc\n"));
-		return DBUS_ERR;
-	}
-
-	if (sdio_info && sdio_info->drvintf && sdio_info->drvintf->sched_dpc)
-		return sdio_info->drvintf->sched_dpc(sdio_info->sdos_info);
-	else
-		return DBUS_ERR;
-}
-
-#ifndef BCM_DNGL_EMBEDIMAGE
-static int
-dbus_sdos_sched_probe_cb()
-{
-	if (g_dbusintf && g_dbusintf->sched_probe_cb)
-		return g_dbusintf->sched_probe_cb(NULL);
-
-	return DBUS_ERR;
-}
-#endif
-
-
-/* This callback is overloaded to also handle pre-attach() requests
- * such as downloading an image to the dongle.
- * Before attach(), we're limited to what can be done since
- * sdio_info handle is not available yet:
- * 	- Reading/writing registers
- * 	- Querying cores using si handle
- */
-static void *
-dbus_sdio_probe_cb(void *handle, const char *desc, uint32 bustype, uint32 hdrlen)
-{
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (handle == &g_probe_info) {
-
-		if (g_dbusintf != NULL) {
-
-			/* First, initialize all lower-level functions as default
-			 * so that dbus.c simply calls directly to dbus_sdio_os.c.
-			 */
-			bcopy(g_dbusintf, &dbus_sdio_intf, sizeof(dbus_intf_t));
-
-			/* Second, selectively override functions we need.
-			 */
-			dbus_sdio_intf.attach = dbus_sdif_attach;
-			dbus_sdio_intf.detach = dbus_sdif_detach;
-			dbus_sdio_intf.send_irb = dbus_sdif_send_irb;
-			/* SDIO does not need pre-submitted IRBs like USB
-			 * so set recv_irb() to NULL so dbus.c would not call
-			 * this function.
-			 */
-			dbus_sdio_intf.recv_irb = NULL;
-			dbus_sdio_intf.send_ctl = dbus_sdif_send_ctl;
-			dbus_sdio_intf.recv_ctl = dbus_sdif_recv_ctl;
-			dbus_sdio_intf.up = dbus_sdif_up;
-			dbus_sdio_intf.iovar_op = dbus_sdif_iovar_op;
-			dbus_sdio_intf.device_exists = dbus_sdif_device_exists;
-			dbus_sdio_intf.dlneeded = dbus_sdif_dlneeded;
-			dbus_sdio_intf.dlstart = dbus_sdif_dlstart;
-			dbus_sdio_intf.dlrun = dbus_sdif_dlrun;
-			dbus_sdio_intf.stop = dbus_sdif_stop;
-			dbus_sdio_intf.down = dbus_sdif_down;
-			dbus_sdio_intf.get_attrib = dbus_sdif_get_attrib;
-		}
-
-		/* Assume a valid image has been downloaded when
-		 * the handle matches ours so propagate probe callback to upper
-		 * layer
-		 */
-		if (probe_cb) {
-			disc_arg = probe_cb(probe_arg, "DBUS SDIO", SD_BUSTYPE, SDPCM_RESERVE);
-			return disc_arg;
-		}
-	}
-
-	return NULL;
-}
-
-static void
-dbus_sdio_disconnect_cb(void *handle)
-{
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (disconnect_cb)
-		disconnect_cb(disc_arg);
-}
-
-int
-dbus_bus_register(int vid, int pid, probe_cb_t prcb,
-	disconnect_cb_t discb, void *prarg, dbus_intf_t **intf, void *param1, void *param2)
-{
-	int err;
-
-	probe_cb = prcb;
-	disconnect_cb = discb;
-	probe_arg = prarg;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	bzero(&g_probe_info, sizeof(probe_sdh_info_t));
-	*intf = &dbus_sdio_intf;
-
-	err = dbus_bus_osl_register(vid, pid, dbus_sdio_probe_cb,
-		dbus_sdio_disconnect_cb, &g_probe_info, &g_dbusintf, param1, param2);
-
-	ASSERT(g_dbusintf);
-
-	return err;
-}
-
-int
-dbus_bus_deregister()
-{
-	dbus_bus_osl_deregister();
-	return DBUS_OK;
-}
-
-void *
-dbus_sdif_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs)
-{
-	sdio_info_t *sdio_info;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-	if ((g_dbusintf == NULL) || (g_dbusintf->attach == NULL))
-		return NULL;
-
-	/* Sanity check for BUS_INFO() */
-	ASSERT(OFFSETOF(sdio_info_t, pub) == 0);
-
-	sdio_info = MALLOC(pub->osh, sizeof(sdio_info_t));
-	if (sdio_info == NULL)
-		return NULL;
-
-	bzero(sdio_info, sizeof(sdio_info_t));
-
-	sdio_info->pub = pub;
-	sdio_info->cbarg = cbarg;
-	sdio_info->cbs = cbs;
-	sdio_info->bus = SD_BUSTYPE;
-	/* Use bufpool if allocated, else use locally malloced rxbuf */
-	sdio_info->usebufpool = FALSE;
-
-	/* Update sdio_info with probe info */
-	sdio_info->sdh = g_probe_info.sdh;
-	sdio_info->sih = g_probe_info.sih;
-	sdio_info->ramsize = g_probe_info.ramsize;
-	sdio_info->orig_ramsize = g_probe_info.orig_ramsize;
-
-	ASSERT(g_probe_info.chinfo);
-	sdio_info->regs = g_probe_info.chinfo->sdregs;
-	sdio_info->vars = g_probe_info.vars;
-	sdio_info->varsz = g_probe_info.varsz;
-	sdio_info->hostintmask = HOSTINTMASK;
-
-	if (g_probe_info.firmware_file)
-		sdio_info->firmware_path = g_probe_info.firmware_file;
-	else
-		sdio_info->firmware_path = firmware_path;
-
-	if (g_probe_info.nvram_file)
-		sdio_info->nvram_path = g_probe_info.nvram_file;
-	else
-		sdio_info->nvram_path = nvram_path;
-
-	/* FIX: Need to redo this maxctl stuff since we don't want cdc and IOCTL
-	 * info in DBUS.  maxctl is used by rxbuf for static allocation.
-	 *
-	 * sdio_info->maxctl = WLC_IOCTL_MAXLEN + sizeof(cdc_ioctl_t) + ROUND_UP_MARGIN;
-	 */
-	sdio_info->maxctl = 8192 + 16 + 2048;
-	if (sdio_info->maxctl) {
-		sdio_info->rxblen =
-			ROUNDUP((sdio_info->maxctl + SDPCM_HDRLEN), ALIGNMENT) + SDALIGN;
-		if (!(sdio_info->rxbuf = MALLOC(pub->osh, sdio_info->rxblen))) {
-			DBUSERR(("%s: MALLOC of %d-byte rxbuf failed\n",
-			           __FUNCTION__, sdio_info->rxblen));
-			goto err;
-		}
-	}
-
-	/* Allocate buffer to receive glomed packet */
-	if (!(sdio_info->databuf = MALLOC(pub->osh, MAX_DATA_BUF))) {
-		DBUSERR(("%s: MALLOC of %d-byte databuf failed\n",
-			__FUNCTION__, MAX_DATA_BUF));
-		goto err;
-	}
-
-	/* Align the buffer */
-	if ((uintptr)sdio_info->databuf % SDALIGN)
-		sdio_info->dataptr =
-			sdio_info->databuf + (SDALIGN - ((uintptr)sdio_info->databuf % SDALIGN));
-	else
-		sdio_info->dataptr = sdio_info->databuf;
-
-	/* ...and initialize clock/power states */
-	sdio_info->sleeping = FALSE;
-	sdio_info->idletime = (int32)dhd_idletime;
-	sdio_info->idleclock = IDLE_ACTIVE;
-
-	if (!(dbus_sdio_attach_init(sdio_info, sdio_info->sdh,
-		sdio_info->firmware_path, sdio_info->nvram_path))) {
-		DBUSERR(("%s: dbus_sdio_attach_init failed\n", __FUNCTION__));
-		goto err;
-	}
-
-	ASSERT(sdio_info->pub->ntxq > 0);
-	pktq_init(&sdio_info->txq, (PRIOMASK+1), sdio_info->pub->ntxq);
-
-	/* Locate an appropriately-aligned portion of hdrbuf */
-	sdio_info->rxhdr = (uint8*)ROUNDUP((uintptr)&sdio_info->hdrbuf[0], SDALIGN);
-
-	/* Set the poll and/or interrupt flags */
-	sdio_info->intr = (bool)dhd_intr;
-	if ((sdio_info->poll = (bool)dhd_poll))
-		sdio_info->pollrate = 1;
-
-	sdio_info->sdos_info = (dbus_pub_t *)g_dbusintf->attach(pub,
-		sdio_info, &dbus_sdio_intf_cbs);
-	if (sdio_info->sdos_info == NULL)
-		goto err;
-
-	/* Save SDIO OS-specific driver entry points */
-	sdio_info->drvintf = g_dbusintf;
-
-	if (g_probe_info.devready == TRUE)
-		sdio_info->pub->busstate = DBUS_STATE_DL_DONE;
-
-	pub->bus = sdio_info;
-
-	return (void *) sdio_info->sdos_info; /* Return Lower layer info */
-err:
-	if (sdio_info) {
-		MFREE(pub->osh, sdio_info, sizeof(sdio_info_t));
-	}
-	return NULL;
-
-}
-
-void
-dbus_sdif_detach(dbus_pub_t *pub, void *info)
-{
-	sdio_info_t *sdio_info = pub->bus;
-	osl_t *osh = pub->osh;
-
-	dbus_bus_stop(sdio_info);
-
-	if (sdio_info->drvintf && sdio_info->drvintf->detach)
-		sdio_info->drvintf->detach(pub, sdio_info->sdos_info);
-
-	dbus_sdio_release(sdio_info, sdio_info->pub->osh);
-	MFREE(osh, sdio_info, sizeof(sdio_info_t));
-}
-
-static void
-dbus_sdio_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->send_irb_timeout)
-		sdio_info->cbs->send_irb_timeout(sdio_info->cbarg, txirb);
-}
-
-static void
-dbus_sdio_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->send_irb_complete)
-		sdio_info->cbs->send_irb_complete(sdio_info->cbarg, txirb, status);
-}
-
-static void
-dbus_sdio_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->recv_irb_complete)
-		sdio_info->cbs->recv_irb_complete(sdio_info->cbarg, rxirb, status);
-}
-
-static void
-dbus_sdio_errhandler(void *handle, int err)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->errhandler)
-		sdio_info->cbs->errhandler(sdio_info->cbarg, err);
-}
-
-static void
-dbus_sdio_ctl_complete(void *handle, int type, int status)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->ctl_complete)
-		sdio_info->cbs->ctl_complete(sdio_info->cbarg, type, status);
-}
-
-static void
-dbus_sdio_state_change(void *handle, int state)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-
-	if (sdio_info == NULL)
-		return;
-
-	if (sdio_info->cbs && sdio_info->cbs->state_change)
-		sdio_info->cbs->state_change(sdio_info->cbarg, state);
-
-	if (state == DBUS_STATE_DISCONNECT) {
-		if (sdio_info->drvintf && sdio_info->drvintf->remove)
-			sdio_info->drvintf->remove(sdio_info->sdos_info);
-
-		sdio_info->pub->busstate = DBUS_STATE_DOWN;
-	}
-
-}
-
-static bool
-dbus_sdio_dpc(void *handle, bool bounded)
-{
-	sdio_info_t *sdio_info = (sdio_info_t *) handle;
-	bcmsdh_info_t *sdh;
-	sdpcmd_regs_t *regs;
-	uint32 intstatus, newstatus = 0;
-	uint retries = 0;
-
-	uint rxlimit = dhd_rxbound; /* Rx frames to read before resched */
-	uint framecnt = 0;		  /* Temporary counter of tx/rx frames */
-	bool rxdone = TRUE;		  /* Flag for no more read data */
-	bool resched = FALSE;	  /* Flag indicating resched wanted */
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	if (sdio_info == NULL) {
-		DBUSERR(("%s: sdio_info == NULL!\n", __FUNCTION__));
-		return FALSE;
-	}
-
-	dbus_sdos_lock(sdio_info);
-
-	sdh = sdio_info->sdh;
-	regs = sdio_info->regs;
-
-	/* Start with leftover status bits */
-	intstatus = sdio_info->intstatus;
-
-	/* If waiting for HTAVAIL, check status */
-	if (sdio_info->clkstate == CLK_PENDING) {
-		int err;
-		uint8 clkctl, devctl = 0;
-
-#ifdef BCMDBG
-		/* Check for inconsistent device control */
-		devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-		if (err) {
-			DBUSERR(("%s: error reading DEVCTL: %d\n", __FUNCTION__, err));
-			sdio_info->pub->busstate = DBUS_STATE_DOWN;
-		}
-		ASSERT(devctl & SBSDIO_DEVCTL_CA_INT_ONLY);
-#endif /* BCMDBG */
-
-		/* Read CSR, if clock on switch to AVAIL, else ignore */
-		clkctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
-		if (err) {
-			DBUSERR(("%s: error reading CSR: %d\n", __FUNCTION__, err));
-			sdio_info->pub->busstate = DBUS_STATE_DOWN;
-		}
-
-		DBUSINFO(("DPC: PENDING, devctl 0x%02x clkctl 0x%02x\n", devctl, clkctl));
-
-		if (SBSDIO_HTAV(clkctl)) {
-			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
-			if (err) {
-				DBUSERR(("%s: error reading DEVCTL: %d\n",
-				           __FUNCTION__, err));
-				sdio_info->pub->busstate = DBUS_STATE_DOWN;
-			}
-			devctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;
-			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, devctl, &err);
-			if (err) {
-				DBUSERR(("%s: error writing DEVCTL: %d\n",
-				           __FUNCTION__, err));
-				sdio_info->pub->busstate = DBUS_STATE_DOWN;
-			}
-			sdio_info->clkstate = CLK_AVAIL;
-		} else {
-			goto clkwait;
-		}
-	}
-
-	BUS_WAKE(sdio_info);
-
-	/* Make sure backplane clock is on */
-	dbus_sdio_clkctl(sdio_info, CLK_AVAIL, TRUE);
-	if (sdio_info->clkstate == CLK_PENDING)
-		goto clkwait;
-
-	/* Pending interrupt indicates new device status */
-	if (sdio_info->ipend) {
-		sdio_info->ipend = FALSE;
-		R_SDREG(newstatus, &regs->intstatus, retries);
-		sdio_info->f1regdata++;
-		if (bcmsdh_regfail(sdio_info->sdh))
-			newstatus = 0;
-		newstatus &= sdio_info->hostintmask;
-		sdio_info->fcstate = !!(newstatus & I_HMB_FC_STATE);
-		if (newstatus) {
-			W_SDREG(newstatus, &regs->intstatus, retries);
-			sdio_info->f1regdata++;
-		}
-	}
-
-	/* Merge new bits with previous */
-	intstatus |= newstatus;
-	sdio_info->intstatus = 0;
-
-	/* Handle flow-control change: read new state in case our ack
-	 * crossed another change interrupt.  If change still set, assume
-	 * FC ON for safety, let next loop through do the debounce.
-	 */
-	if (intstatus & I_HMB_FC_CHANGE) {
-		intstatus &= ~I_HMB_FC_CHANGE;
-		W_SDREG(I_HMB_FC_CHANGE, &regs->intstatus, retries);
-		R_SDREG(newstatus, &regs->intstatus, retries);
-		sdio_info->f1regdata += 2;
-		sdio_info->fcstate = !!(newstatus & (I_HMB_FC_STATE | I_HMB_FC_CHANGE));
-		intstatus |= (newstatus & sdio_info->hostintmask);
-	}
-
-	/* Just being here means nothing more to do for chipactive */
-	if (intstatus & I_CHIPACTIVE) {
-		/* ASSERT(sdio_info->clkstate == CLK_AVAIL); */
-		intstatus &= ~I_CHIPACTIVE;
-	}
-
-	/* Handle host mailbox indication */
-	if (intstatus & I_HMB_HOST_INT) {
-		intstatus &= ~I_HMB_HOST_INT;
-		intstatus |= dbus_sdio_hostmail(sdio_info);
-	}
-
-	/* Generally don't ask for these, can get CRC errors... */
-	if (intstatus & I_WR_OOSYNC) {
-		DBUSERR(("Dongle reports WR_OOSYNC\n"));
-		intstatus &= ~I_WR_OOSYNC;
-	}
-
-	if (intstatus & I_RD_OOSYNC) {
-		DBUSERR(("Dongle reports RD_OOSYNC\n"));
-		intstatus &= ~I_RD_OOSYNC;
-	}
-
-	if (intstatus & I_SBINT) {
-		DBUSERR(("Dongle reports SBINT\n"));
-		intstatus &= ~I_SBINT;
-	}
-
-	/* Would be active due to wake-wlan in gSPI */
-	if (intstatus & I_CHIPACTIVE) {
-		DBUSERR(("Dongle reports CHIPACTIVE\n"));
-		intstatus &= ~I_CHIPACTIVE;
-	}
-
-	/* Ignore frame indications if rxskip is set */
-	if (sdio_info->rxskip)
-		intstatus &= ~I_HMB_FRAME_IND;
-
-	/* On frame indication, read available frames */
-	if (PKT_AVAILABLE()) {
-		framecnt = dbus_sdio_readframes(sdio_info, rxlimit, &rxdone);
-		if (rxdone || sdio_info->rxskip)
-			intstatus &= ~I_HMB_FRAME_IND;
-		rxlimit -= MIN(framecnt, rxlimit);
-	}
-
-	if (pktq_mlen(&sdio_info->txq, ~sdio_info->flowcontrol) > 0) {
-		/* reschedule txq */
-		dbus_sdio_txq_sched(sdio_info->sdos_info);
-	}
-
-	/* Keep still-pending events for next scheduling */
-	sdio_info->intstatus = intstatus;
-
-clkwait:
-	/* Re-enable interrupts to detect new device events (mailbox, rx frame)
-	 * or clock availability.  (Allows tx loop to check ipend if desired.)
-	 * (Unless register access seems hosed, as we may not be able to ACK...)
-	 */
-	if (sdio_info->intr && sdio_info->intdis && !bcmsdh_regfail(sdh)) {
-		DBUSINTR(("%s: enable SDIO interrupts, rxdone %d framecnt %d\n",
-		          __FUNCTION__, rxdone, framecnt));
-		sdio_info->intdis = FALSE;
-		bcmsdh_intr_enable(sdh);
-	}
-
-	/* Resched if events or tx frames are pending, else await next interrupt */
-	/* On failed register access, all bets are off: no resched or interrupts */
-	if ((sdio_info->pub->busstate == DBUS_STATE_DOWN) || bcmsdh_regfail(sdh)) {
-		DBUSERR(("%s: failed backplane access over SDIO, halting operation\n",
-		           __FUNCTION__));
-		dbus_sdio_state_change(sdio_info, DBUS_STATE_DISCONNECT);
-		sdio_info->intstatus = 0;
-		dbus_bus_stop(sdio_info);
-	} else if (sdio_info->clkstate == CLK_PENDING) {
-		/* Awaiting I_CHIP_ACTIVE, don't resched */
-	} else if (sdio_info->intstatus || sdio_info->ipend || PKT_AVAILABLE()) {
-		resched = TRUE;
-	}
-
-	/* If we're done for now, turn off clock request. */
-	if (sdio_info->idletime == IDLE_IMMEDIATE) {
-		sdio_info->activity = FALSE;
-		dbus_sdio_clkctl(sdio_info, CLK_NONE, FALSE);
-	}
-
-	sdio_info->dpc_sched = resched;
-	dbus_sdos_unlock(sdio_info);
-
-	return resched;
-}
-
-static void
-dbus_sdio_watchdog(void *handle)
-{
-}
-
-void
-dbus_bus_fw_get(void *bus, uint8 **fw, int *fwlen, int *decomp)
-{
-	sdio_info_t *sdio_info = BUS_INFO(bus, sdio_info_t);
-	unsigned int devid;
-	unsigned int crev;
-
-	devid = sdio_info->pub->attrib.devid;
-	crev = sdio_info->pub->attrib.chiprev;
-
-	*fw = NULL;
-	*fwlen = 0;
-
-	switch (devid) {
-	case BCM4319_CHIP_ID:
-#if  defined(EMBED_IMAGE_4319sd)
-		*fw = (uint8 *)dlarray_4319sd;
-		*fwlen = sizeof(dlarray_4319sd);
-#endif
-		break;
-	case BCM4325_CHIP_ID:
-#ifdef EMBED_IMAGE_4325sd
-		*fw = (uint8 *)dlarray_4325sd;
-		*fwlen = sizeof(dlarray_4325sd);
-#endif
-		break;
-	default:
-#ifdef EMBED_IMAGE_GENERIC
-		*fw = (uint8 *)dlarray;
-		*fwlen = sizeof(dlarray);
-#endif
-		break;
-	}
-}
diff -Nuar merlin-bkp/shared/dbus_usb.c merlin-new/shared/dbus_usb.c
--- merlin-bkp/shared/dbus_usb.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/dbus_usb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1156 +0,0 @@
-/*
- * Dongle BUS interface for USB, OS independent
- *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
- * 
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * $Id: dbus_usb.c 419467 2013-08-21 09:19:48Z $
- */
-
-#include <osl.h>
-#include <bcmdefs.h>
-#include <bcmutils.h>
-#include <dbus.h>
-#include <usbrdl.h>
-#include <bcmdevs.h>
-#include <bcmendian.h>
-
-#if defined(BCM_DNGL_EMBEDIMAGE)
-#ifdef EMBED_IMAGE_43236b
-#include "rtecdc_43236b.h"
-#endif /* EMBED_IMAGE_43236b */
-#ifdef EMBED_IMAGE_43238b
-#include "rtecdc_43238b.h"
-#endif /* EMBED_IMAGE_43238b */
-#ifdef EMBED_IMAGE_43526a
-#include "rtecdc_43526a.h"
-#endif /* EMBED_IMAGE_43526a */
-#ifdef EMBED_IMAGE_43526b
-#include "rtecdc_43526b.h"
-#endif /* EMBED_IMAGE_43526b */
-#ifdef EMBED_IMAGE_4360b
-#include "rtecdc_4360b.h"
-#endif /* EMBED_IMAGE_4360b */
-#ifdef EMBED_IMAGE_43242a0
-#include "rtecdc_43242a0.h"
-#endif /* EMBED_IMAGE_43242a0 */
-#ifdef EMBED_IMAGE_43242a1
-#include "rtecdc_43242a1.h"
-#endif /* EMBED_IMAGE_43242a1 */
-#ifdef EMBED_IMAGE_43143a0
-#include "rtecdc_43143a0.h"
-#endif /* EMBED_IMAGE_43143a0 */
-#ifdef EMBED_IMAGE_43143b0
-#include "rtecdc_43143b0.h"
-#endif /* EMBED_IMAGE_43143b0 */
-#ifdef EMBED_IMAGE_4350a0
-#include "rtecdc_4350a0.h"
-#endif /* EMBED_IMAGE_4350a0 */
-#ifdef EMBED_IMAGE_4350b0
-#include "rtecdc_4350b0.h"
-#endif /* EMBED_IMAGE_4350b0 */
-#ifdef EMBED_IMAGE_4350b1
-#include "rtecdc_4350b1.h"
-#endif /* EMBED_IMAGE_4350b1 */
-#ifdef EMBED_IMAGE_GENERIC
-#include "rtecdc.h"
-#endif
-#endif /* BCM_DNGL_EMBEDIMAGE */
-
-#define USB_DLIMAGE_SPINWAIT         10      /* in unit of ms */
-#define USB_DLIMAGE_LIMIT            500     /* spinwait limit (ms) */
-#define USB_SFLASH_DLIMAGE_SPINWAIT  200     /* in unit of ms */
-#define USB_SFLASH_DLIMAGE_LIMIT     2000    /* spinwait limit (ms) */
-#define POSTBOOT_ID                  0xA123  /* ID to detect if dongle has boot up */
-#define USB_RESETCFG_SPINWAIT        1       /* wait after resetcfg (ms) */
-#define USB_DEV_ISBAD(u)             (u->pub->attrib.devid == 0xDEAD)
-#define USB_DLGO_SPINWAIT            100     /* wait after DL_GO (ms) */
-#define TEST_CHIP                    0x4328
-
-typedef struct {
-	dbus_pub_t  *pub;
-
-	void        *cbarg;
-	dbus_intf_callbacks_t *cbs;
-	dbus_intf_t *drvintf;
-	void        *usbosl_info;
-	uint32      rdlram_base_addr;
-	uint32      rdlram_size;
-} usb_info_t;
-
-/*
- * Callbacks common to all USB
- */
-static void dbus_usb_disconnect(void *handle);
-static void dbus_usb_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb);
-static void dbus_usb_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status);
-static void dbus_usb_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status);
-static void dbus_usb_errhandler(void *handle, int err);
-static void dbus_usb_ctl_complete(void *handle, int type, int status);
-static void dbus_usb_state_change(void *handle, int state);
-static struct dbus_irb* dbus_usb_getirb(void *handle, bool send);
-static void dbus_usb_rxerr_indicate(void *handle, bool on);
-static int dbus_usb_resetcfg(usb_info_t *usbinfo);
-static int dbus_usb_iovar_op(void *bus, const char *name,
-	void *params, int plen, void *arg, int len, bool set);
-static int dbus_iovar_process(usb_info_t* usbinfo, const char *name,
-                 void *params, int plen, void *arg, int len, bool set);
-static int dbus_usb_doiovar(usb_info_t *bus, const bcm_iovar_t *vi, uint32 actionid,
-	const char *name, void *params, int plen, void *arg, int len, int val_size);
-static int dhdusb_downloadvars(usb_info_t *bus, void *arg, int len);
-
-static int dbus_usb_dl_writeimage(usb_info_t *usbinfo, uint8 *fw, int fwlen);
-static int dbus_usb_dlstart(void *bus, uint8 *fw, int len);
-static bool dbus_usb_dlneeded(void *bus);
-static int dbus_usb_dlrun(void *bus);
-static int dbus_usb_rdl_dwnld_state(usb_info_t *usbinfo);
-
-#ifdef BCM_DNGL_EMBEDIMAGE
-static bool dbus_usb_device_exists(void *bus);
-#endif
-
-/* OS specific */
-extern bool dbus_usbos_dl_cmd(void *info, uint8 cmd, void *buffer, int buflen);
-extern int dbus_usbos_wait(void *info, uint16 ms);
-extern int dbus_write_membytes(usb_info_t *usbinfo, bool set, uint32 address,
-	uint8 *data, uint size);
-extern bool dbus_usbos_dl_send_bulk(void *info, void *buffer, int len);
-
-static dbus_intf_callbacks_t dbus_usb_intf_cbs = {
-	dbus_usb_send_irb_timeout,
-	dbus_usb_send_irb_complete,
-	dbus_usb_recv_irb_complete,
-	dbus_usb_errhandler,
-	dbus_usb_ctl_complete,
-	dbus_usb_state_change,
-	NULL,  /* isr */
-	NULL,  /* dpc */
-	NULL,  /* watchdog */
-	NULL,  /* dbus_if_pktget */
-	NULL,  /* dbus_if_pktfree */
-	dbus_usb_getirb,
-	dbus_usb_rxerr_indicate
-};
-
-/* IOVar table */
-enum {
-	IOV_SET_DOWNLOAD_STATE = 1,
-	IOV_MEMBYTES,
-	IOV_VARS
-};
-
-const bcm_iovar_t dhdusb_iovars[] = {
-	{"vars",	IOV_VARS,	0,	IOVT_BUFFER,	0 },
-	{"dwnldstate",	IOV_SET_DOWNLOAD_STATE,	0,	IOVT_BOOL,	0 },
-	{"membytes",	IOV_MEMBYTES,	0,	IOVT_BUFFER,	2 * sizeof(int) },
-	{NULL, 0, 0, 0, 0 }
-};
-
-/*
- * Need global for probe() and disconnect() since
- * attach() is not called at probe and detach()
- * can be called inside disconnect()
- */
-static probe_cb_t      probe_cb = NULL;
-static disconnect_cb_t disconnect_cb = NULL;
-static void            *probe_arg = NULL;
-static void            *disc_arg = NULL;
-static dbus_intf_t     *g_dbusintf = NULL;
-static dbus_intf_t     dbus_usb_intf;
-
-/*
- * dbus_intf_t common to all USB
- * These functions override dbus_usb_<os>.c.
- */
-static void *dbus_usb_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs);
-static void dbus_usb_detach(dbus_pub_t *pub, void *info);
-static void * dbus_usb_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen);
-
-/* functions */
-
-/**
- * As part of DBUS initialization/registration, the higher level DBUS (dbus.c) needs to know what
- * lower level DBUS functions to call (in both dbus_usb.c and dbus_usb_os.c).
- */
-static void *
-dbus_usb_probe(void *arg, const char *desc, uint32 bustype, uint32 hdrlen)
-{
-	if (probe_cb) {
-
-		if (g_dbusintf != NULL) {
-			/* First, initialize all lower-level functions as default
-			 * so that dbus.c simply calls directly to dbus_usb_os.c.
-			 */
-			bcopy(g_dbusintf, &dbus_usb_intf, sizeof(dbus_intf_t));
-
-			/* Second, selectively override functions we need, if any. */
-			dbus_usb_intf.attach = dbus_usb_attach;
-			dbus_usb_intf.detach = dbus_usb_detach;
-			dbus_usb_intf.iovar_op = dbus_usb_iovar_op;
-			dbus_usb_intf.dlstart = dbus_usb_dlstart;
-			dbus_usb_intf.dlneeded = dbus_usb_dlneeded;
-			dbus_usb_intf.dlrun = dbus_usb_dlrun;
-#ifdef BCM_DNGL_EMBEDIMAGE
-			dbus_usb_intf.device_exists = dbus_usb_device_exists;
-#endif
-		}
-
-		disc_arg = probe_cb(probe_arg, "DBUS USB", USB_BUS, hdrlen);
-		return disc_arg;
-	}
-
-	return NULL;
-}
-
-/**
- * On return, *intf contains this or lower-level DBUS functions to be called by higher
- * level (dbus.c)
- */
-int
-dbus_bus_register(int vid, int pid, probe_cb_t prcb,
-	disconnect_cb_t discb, void *prarg, dbus_intf_t **intf, void *param1, void *param2)
-{
-	int err;
-
-	probe_cb = prcb;
-	disconnect_cb = discb;
-	probe_arg = prarg;
-
-	*intf = &dbus_usb_intf;
-
-	err = dbus_bus_osl_register(vid, pid, dbus_usb_probe,
-		dbus_usb_disconnect, NULL, &g_dbusintf, param1, param2);
-
-	ASSERT(g_dbusintf);
-	return err;
-}
-
-int
-dbus_bus_deregister()
-{
-	return dbus_bus_osl_deregister();
-}
-
-/** initialization consists of registration followed by 'attach'. */
-void *
-dbus_usb_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs)
-{
-	usb_info_t *usb_info;
-
-	if ((g_dbusintf == NULL) || (g_dbusintf->attach == NULL))
-		return NULL;
-
-	/* Sanity check for BUS_INFO() */
-	ASSERT(OFFSETOF(usb_info_t, pub) == 0);
-
-	usb_info = MALLOC(pub->osh, sizeof(usb_info_t));
-	if (usb_info == NULL)
-		return NULL;
-
-	bzero(usb_info, sizeof(usb_info_t));
-
-	usb_info->pub = pub;
-	usb_info->cbarg = cbarg;
-	usb_info->cbs = cbs;
-
-	usb_info->usbosl_info = (dbus_pub_t *)g_dbusintf->attach(pub,
-		usb_info, &dbus_usb_intf_cbs);
-	if (usb_info->usbosl_info == NULL) {
-		MFREE(pub->osh, usb_info, sizeof(usb_info_t));
-		return NULL;
-	}
-
-	/* Save USB OS-specific driver entry points */
-	usb_info->drvintf = g_dbusintf;
-
-	pub->bus = usb_info;
-#if  !defined(BCM_DNGL_EMBEDIMAGE) && !defined(BCM_REQUEST_FW)
-
-	if (!dbus_usb_resetcfg(usb_info)) {
-	usb_info->pub->busstate = DBUS_STATE_DL_DONE;
-	}
-#endif
-	/* Return Lower layer info */
-	return (void *) usb_info->usbosl_info;
-}
-
-void
-dbus_usb_detach(dbus_pub_t *pub, void *info)
-{
-	usb_info_t *usb_info = (usb_info_t *) pub->bus;
-	osl_t *osh = pub->osh;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->drvintf && usb_info->drvintf->detach)
-		usb_info->drvintf->detach(pub, usb_info->usbosl_info);
-
-	MFREE(osh, usb_info, sizeof(usb_info_t));
-}
-
-void
-dbus_usb_disconnect(void *handle)
-{
-	if (disconnect_cb)
-		disconnect_cb(disc_arg);
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_send_irb_timeout(void *handle, dbus_irb_tx_t *txirb)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->send_irb_timeout)
-		usb_info->cbs->send_irb_timeout(usb_info->cbarg, txirb);
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_send_irb_complete(void *handle, dbus_irb_tx_t *txirb, int status)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->send_irb_complete)
-		usb_info->cbs->send_irb_complete(usb_info->cbarg, txirb, status);
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_recv_irb_complete(void *handle, dbus_irb_rx_t *rxirb, int status)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->recv_irb_complete)
-		usb_info->cbs->recv_irb_complete(usb_info->cbarg, rxirb, status);
-}
-
-/** Lower DBUS level (dbus_usb_os.c) requests a free IRB. Pass this on to the higher DBUS level. */
-static struct dbus_irb*
-dbus_usb_getirb(void *handle, bool send)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return NULL;
-
-	if (usb_info->cbs && usb_info->cbs->getirb)
-		return usb_info->cbs->getirb(usb_info->cbarg, send);
-
-	return NULL;
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_rxerr_indicate(void *handle, bool on)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->rxerr_indicate)
-		usb_info->cbs->rxerr_indicate(usb_info->cbarg, on);
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_errhandler(void *handle, int err)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->errhandler)
-		usb_info->cbs->errhandler(usb_info->cbarg, err);
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_ctl_complete(void *handle, int type, int status)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->ctl_complete)
-		usb_info->cbs->ctl_complete(usb_info->cbarg, type, status);
-}
-
-/**
- * When the lower DBUS level (dbus_usb_os.c) signals this event, the higher DBUS level has to be
- * notified.
- */
-static void
-dbus_usb_state_change(void *handle, int state)
-{
-	usb_info_t *usb_info = (usb_info_t *) handle;
-
-	if (usb_info == NULL)
-		return;
-
-	if (usb_info->cbs && usb_info->cbs->state_change)
-		usb_info->cbs->state_change(usb_info->cbarg, state);
-}
-
-/** called by higher DBUS level (dbus.c) */
-static int
-dbus_usb_iovar_op(void *bus, const char *name,
-	void *params, int plen, void *arg, int len, bool set)
-{
-	int err = DBUS_OK;
-
-	err = dbus_iovar_process((usb_info_t*)bus, name, params, plen, arg, len, set);
-	return err;
-}
-
-/** process iovar request from higher DBUS level */
-static int
-dbus_iovar_process(usb_info_t* usbinfo, const char *name,
-                 void *params, int plen, void *arg, int len, bool set)
-{
-	const bcm_iovar_t *vi = NULL;
-	int bcmerror = 0;
-	int val_size;
-	uint32 actionid;
-
-	DBUSTRACE(("%s: Enter\n", __FUNCTION__));
-
-	ASSERT(name);
-	ASSERT(len >= 0);
-
-	/* Get MUST have return space */
-	ASSERT(set || (arg && len));
-
-	/* Set does NOT take qualifiers */
-	ASSERT(!set || (!params && !plen));
-
-	/* Look up var locally; if not found pass to host driver */
-	if ((vi = bcm_iovar_lookup(dhdusb_iovars, name)) == NULL) {
-		/* Not Supported */
-		bcmerror = BCME_UNSUPPORTED;
-		DBUSTRACE(("%s: IOVAR %s is not supported\n", name, __FUNCTION__));
-		goto exit;
-
-	}
-
-	DBUSTRACE(("%s: %s %s, len %d plen %d\n", __FUNCTION__,
-	         name, (set ? "set" : "get"), len, plen));
-
-	/* set up 'params' pointer in case this is a set command so that
-	 * the convenience int and bool code can be common to set and get
-	 */
-	if (params == NULL) {
-		params = arg;
-		plen = len;
-	}
-
-	if (vi->type == IOVT_VOID)
-		val_size = 0;
-	else if (vi->type == IOVT_BUFFER)
-		val_size = len;
-	else
-		/* all other types are integer sized */
-		val_size = sizeof(int);
-
-	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
-	bcmerror = dbus_usb_doiovar(usbinfo, vi, actionid,
-		name, params, plen, arg, len, val_size);
-
-exit:
-	return bcmerror;
-}
-
-static int
-dbus_usb_doiovar(usb_info_t *bus, const bcm_iovar_t *vi, uint32 actionid, const char *name,
-                void *params, int plen, void *arg, int len, int val_size)
-{
-	int bcmerror = 0;
-	int32 int_val = 0;
-	bool bool_val = 0;
-
-	DBUSTRACE(("%s: Enter, action %d name %s params %p plen %d arg %p len %d val_size %d\n",
-	           __FUNCTION__, actionid, name, params, plen, arg, len, val_size));
-
-	if ((bcmerror = bcm_iovar_lencheck(vi, arg, len, IOV_ISSET(actionid))) != 0)
-		goto exit;
-
-	if (plen >= (int)sizeof(int_val))
-		bcopy(params, &int_val, sizeof(int_val));
-
-	bool_val = (int_val != 0) ? TRUE : FALSE;
-
-	switch (actionid) {
-
-	case IOV_SVAL(IOV_MEMBYTES):
-	case IOV_GVAL(IOV_MEMBYTES):
-	{
-		uint32 address;
-		uint size, dsize;
-		uint8 *data;
-
-		bool set = (actionid == IOV_SVAL(IOV_MEMBYTES));
-
-		ASSERT(plen >= 2*sizeof(int));
-
-		address = (uint32)int_val;
-		BCM_REFERENCE(address);
-		bcopy((char *)params + sizeof(int_val), &int_val, sizeof(int_val));
-		size = (uint)int_val;
-
-		/* Do some validation */
-		dsize = set ? plen - (2 * sizeof(int)) : len;
-		if (dsize < size) {
-			DBUSTRACE(("%s: error on %s membytes, addr 0x%08x size %d dsize %d\n",
-			           __FUNCTION__, (set ? "set" : "get"), address, size, dsize));
-			bcmerror = BCME_BADARG;
-			break;
-		}
-		DBUSTRACE(("%s: Request to %s %d bytes at address 0x%08x\n", __FUNCTION__,
-		          (set ? "write" : "read"), size, address));
-
-		/* Generate the actual data pointer */
-		data = set ? (uint8*)params + 2 * sizeof(int): (uint8*)arg;
-
-		/* Call to do the transfer */
-		bcmerror = dbus_usb_dl_writeimage(BUS_INFO(bus, usb_info_t), data, size);
-	}
-		break;
-
-
-	case IOV_SVAL(IOV_SET_DOWNLOAD_STATE):
-
-		if (bool_val == TRUE) {
-			bcmerror = dbus_usb_dlneeded(bus);
-			dbus_usb_rdl_dwnld_state(BUS_INFO(bus, usb_info_t));
-		} else {
-			usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
-			bcmerror = dbus_usb_dlrun(bus);
-			usbinfo->pub->busstate = DBUS_STATE_DL_DONE;
-		}
-		break;
-
-	case IOV_SVAL(IOV_VARS):
-		bcmerror = dhdusb_downloadvars(BUS_INFO(bus, usb_info_t), arg, len);
-		break;
-
-	default:
-		bcmerror = BCME_UNSUPPORTED;
-		break;
-	}
-
-exit:
-	return bcmerror;
-}
-
-/** higher DBUS level (dbus.c) wants to set NVRAM variables in dongle */
-static int
-dhdusb_downloadvars(usb_info_t *bus, void *arg, int len)
-{
-	int bcmerror = 0;
-	uint32 varsize;
-	uint32 varaddr;
-	uint32 varsizew;
-
-	if (!len) {
-		bcmerror = BCME_BUFTOOSHORT;
-		goto err;
-	}
-
-	/* RAM size is not set. Set it at dbus_usb_dlneeded */
-	if (!bus->rdlram_size)
-		bcmerror = BCME_ERROR;
-
-	/* Even if there are no vars are to be written, we still need to set the ramsize. */
-	varsize = len ? ROUNDUP(len, 4) : 0;
-	varaddr = (bus->rdlram_size - 4) - varsize;
-
-	/* Write the vars list */
-	DBUSTRACE(("WriteVars: @%x varsize=%d\n", varaddr, varsize));
-	bcmerror = dbus_write_membytes(bus->usbosl_info, TRUE, (varaddr + bus->rdlram_base_addr),
-		arg, varsize);
-
-	/* adjust to the user specified RAM */
-	DBUSTRACE(("Usable memory size: %d\n", bus->rdlram_size));
-	DBUSTRACE(("Vars are at %d, orig varsize is %d\n", varaddr, varsize));
-
-	varsize = ((bus->rdlram_size - 4) - varaddr);
-
-	/*
-	 * Determine the length token:
-	 * Varsize, converted to words, in lower 16-bits, checksum in upper 16-bits.
-	 */
-	if (bcmerror) {
-		varsizew = 0;
-	} else {
-		varsizew = varsize / 4;
-		varsizew = (~varsizew << 16) | (varsizew & 0x0000FFFF);
-		varsizew = htol32(varsizew);
-	}
-
-	DBUSTRACE(("New varsize is %d, length token=0x%08x\n", varsize, varsizew));
-
-	/* Write the length token to the last word */
-	bcmerror = dbus_write_membytes(bus->usbosl_info, TRUE, ((bus->rdlram_size - 4) +
-		bus->rdlram_base_addr), (uint8*)&varsizew, 4);
-err:
-	return bcmerror;
-}
-
-/**
- * After downloading firmware into dongle and starting it, we need to know if the firmware is
- * indeed up and running.
- */
-static int
-dbus_usb_resetcfg(usb_info_t *usbinfo)
-{
-	void *osinfo;
-	bootrom_id_t id;
-	uint16 wait = 0, wait_time;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (usbinfo == NULL)
-		return DBUS_ERR;
-
-	osinfo = usbinfo->usbosl_info;
-	ASSERT(osinfo);
-
-	/* Give dongle chance to boot */
-	wait_time = USB_SFLASH_DLIMAGE_SPINWAIT;
-	while (wait < USB_SFLASH_DLIMAGE_LIMIT) {
-		dbus_usbos_wait(osinfo, wait_time);
-
-		wait += wait_time;
-
-		id.chip = 0xDEAD;       /* Get the ID */
-		dbus_usbos_dl_cmd(osinfo, DL_GETVER, &id, sizeof(bootrom_id_t));
-		id.chip = ltoh32(id.chip);
-
-		if (id.chip == POSTBOOT_ID)
-			break;
-	}
-
-	if (id.chip == POSTBOOT_ID) {
-		DBUSERR(("%s: download done %d ms postboot chip 0x%x/rev 0x%x\n",
-			__FUNCTION__, wait, id.chip, id.chiprev));
-
-		dbus_usbos_dl_cmd(osinfo, DL_RESETCFG, &id, sizeof(bootrom_id_t));
-
-		dbus_usbos_wait(osinfo, USB_RESETCFG_SPINWAIT);
-		return DBUS_OK;
-	} else {
-		DBUSERR(("%s: Cannot talk to Dongle. Firmware is not UP, %d ms \n",
-			__FUNCTION__, wait));
-		return DBUS_ERR;
-	}
-
-	return DBUS_OK;
-}
-
-/** before firmware download, the dongle has to be prepared to receive the fw image */
-static int
-dbus_usb_rdl_dwnld_state(usb_info_t *usbinfo)
-{
-	void *osinfo = usbinfo->usbosl_info;
-	rdl_state_t state;
-	int err = DBUS_OK;
-
-	/* 1) Prepare USB boot loader for runtime image */
-	dbus_usbos_dl_cmd(osinfo, DL_START, &state, sizeof(rdl_state_t));
-
-	state.state = ltoh32(state.state);
-	state.bytes = ltoh32(state.bytes);
-
-	/* 2) Check we are in the Waiting state */
-	if (state.state != DL_WAITING) {
-		DBUSERR(("%s: Failed to DL_START\n", __FUNCTION__));
-		err = DBUS_ERR;
-		goto fail;
-	}
-
-fail:
-	return err;
-}
-
-/**
- * Dongle contains bootcode in ROM but firmware is (partially) contained in dongle RAM. Therefore,
- * firmware has to be downloaded into dongle RAM.
- */
-static int
-dbus_usb_dl_writeimage(usb_info_t *usbinfo, uint8 *fw, int fwlen)
-{
-	osl_t *osh = usbinfo->pub->osh;
-	void *osinfo = usbinfo->usbosl_info;
-	unsigned int sendlen, sent, dllen, pktlen;
-	char *bulkchunk = NULL, *dlpos;
-	rdl_state_t state;
-	int err = DBUS_OK;
-	bootrom_id_t id;
-	uint16 wait, wait_time;
-
-	bulkchunk = MALLOC(osh, RDL_CHUNK);
-	if (bulkchunk == NULL) {
-		err = DBUS_ERR;
-		goto fail;
-	}
-
-	sent = 0;
-	dlpos = fw;
-	dllen = fwlen;
-	pktlen = RDL_CHUNK;
-
-#ifdef BCM_USB30
-	/* for SuperSpeed with non-disconnect target, need to make sure */
-	/* bulk out write times can divided by 32 to keep SeqN is 0           */
-	pktlen = (fwlen + RDL_CHUNK - 1)/RDL_CHUNK;
-	if (pktlen%32) {
-		pktlen = (pktlen/32 + 1)*32;
-	}
-	pktlen = (dllen + pktlen - 1)/pktlen;
-#endif /* BCM_USB30 */
-
-	/* Get chip id and rev */
-	id.chip = usbinfo->pub->attrib.devid;
-	id.chiprev = usbinfo->pub->attrib.chiprev;
-
-	DBUSTRACE(("enter %s: fwlen=%d\n", __FUNCTION__, fwlen));
-
-	dbus_usbos_dl_cmd(osinfo, DL_GETSTATE, &state, sizeof(rdl_state_t));
-
-	/* 3) Load the image */
-	while ((sent < dllen)) {
-		/* Wait until the usb device reports it received all the bytes we sent */
-
-		if (sent < dllen) {
-			if ((dllen-sent) < pktlen)
-				sendlen = dllen-sent;
-			else
-				sendlen = pktlen;
-
-#ifndef BCM_USB30
-			/* simply avoid having to send a ZLP by ensuring we never have an even
-			 * multiple of 64
-			 */
-			if (!(sendlen % 64))
-				sendlen -= 4;
-#endif /* BCM_USB30 */
-			/* send data */
-			memcpy(bulkchunk, dlpos, sendlen);
-			if (!dbus_usbos_dl_send_bulk(osinfo, bulkchunk, sendlen)) {
-				err = DBUS_ERR;
-				goto fail;
-			}
-
-			dlpos += sendlen;
-			sent += sendlen;
-			DBUSTRACE(("%s: sendlen %d\n", __FUNCTION__, sendlen));
-		}
-
-		wait = 0;
-		wait_time = USB_SFLASH_DLIMAGE_SPINWAIT;
-		while (!dbus_usbos_dl_cmd(osinfo, DL_GETSTATE, &state,
-			sizeof(rdl_state_t))) {
-			if ((id.chip == 43236) && (id.chiprev == 0)) {
-				DBUSERR(("%s: 43236a0 SFlash delay, waiting for dongle crc check "
-					 "completion!!!\n", __FUNCTION__));
-				dbus_usbos_wait(osinfo, wait_time);
-				wait += wait_time;
-				if (wait >= USB_SFLASH_DLIMAGE_LIMIT) {
-					DBUSERR(("%s: DL_GETSTATE Failed xxxx\n", __FUNCTION__));
-					err = DBUS_ERR;
-					goto fail;
-					break;
-				}
-			} else {
-				DBUSERR(("%s: DL_GETSTATE Failed xxxx\n", __FUNCTION__));
-				err = DBUS_ERR;
-				goto fail;
-			}
-		}
-
-		state.state = ltoh32(state.state);
-		state.bytes = ltoh32(state.bytes);
-
-		/* restart if an error is reported */
-		if ((state.state == DL_BAD_HDR) || (state.state == DL_BAD_CRC)) {
-			DBUSERR(("%s: Bad Hdr or Bad CRC\n", __FUNCTION__));
-			err = DBUS_ERR;
-			goto fail;
-		}
-
-	}
-fail:
-	if (bulkchunk)
-		MFREE(osh, bulkchunk, RDL_CHUNK);
-
-	return err;
-}
-
-/** Higher level DBUS layer (dbus.c) requests this layer to download image into dongle */
-static int
-dbus_usb_dlstart(void *bus, uint8 *fw, int len)
-{
-	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
-	int err;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (usbinfo == NULL)
-		return DBUS_ERR;
-
-	if (USB_DEV_ISBAD(usbinfo))
-		return DBUS_ERR;
-
-	err = dbus_usb_rdl_dwnld_state(usbinfo);
-
-	if (DBUS_OK == err) {
-	err = dbus_usb_dl_writeimage(usbinfo, fw, len);
-	if (err == DBUS_OK)
-		usbinfo->pub->busstate = DBUS_STATE_DL_DONE;
-	else
-		usbinfo->pub->busstate = DBUS_STATE_DL_PENDING;
-	} else
-		usbinfo->pub->busstate = DBUS_STATE_DL_PENDING;
-
-	return err;
-}
-static bool
-dbus_usb_update_chipinfo(usb_info_t *usbinfo, uint32 chip)
-{
-	bool retval = TRUE;
-	/* based on the CHIP Id, store the ram size which is needed for NVRAM download. */
-	switch (chip) {
-
-		case 0x4319:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_4319;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4319;
-			break;
-
-		case 0x4329:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_4329;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4329;
-			break;
-
-		case 43234:
-		case 43235:
-		case 43236:
-		case 43238:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_43236;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_43236;
-			break;
-
-		case 0x4328:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_4328;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4328;
-			break;
-
-		case 0x4322:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_4322;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4322;
-			break;
-
-		case 0x4360:
-		case 0xAA06:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_4360;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4360;
-			break;
-
-		case 43242:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_43242;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_43242;
-			break;
-
-		case 43143:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_43143;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_43143;
-			break;
-
-		case 0x4350:
-			usbinfo->rdlram_size = RDL_RAM_SIZE_4350;
-			usbinfo->rdlram_base_addr = RDL_RAM_BASE_4350;
-			break;
-
-		case POSTBOOT_ID:
-			break;
-
-		default:
-			DBUSERR(("%s: Chip 0x%x Ram size is not known\n", __FUNCTION__, chip));
-			retval = FALSE;
-			break;
-
-	}
-
-	return retval;
-}
-
-/** higher DBUS level (dbus.c) wants to know if firmware download is required. */
-static bool
-dbus_usb_dlneeded(void *bus)
-{
-	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
-	void *osinfo;
-	bootrom_id_t id;
-	bool dl_needed = TRUE;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (usbinfo == NULL)
-		return FALSE;
-
-	osinfo = usbinfo->usbosl_info;
-	ASSERT(osinfo);
-
-	/* Check if firmware downloaded already by querying runtime ID */
-	id.chip = 0xDEAD;
-	dbus_usbos_dl_cmd(osinfo, DL_GETVER, &id, sizeof(bootrom_id_t));
-
-	id.chip = ltoh32(id.chip);
-	id.chiprev = ltoh32(id.chiprev);
-
-	if (FALSE == dbus_usb_update_chipinfo(usbinfo, id.chip)) {
-		dl_needed = FALSE;
-		goto exit;
-	}
-
-	DBUSERR(("%s: chip 0x%x rev 0x%x\n", __FUNCTION__, id.chip, id.chiprev));
-	if (id.chip == POSTBOOT_ID) {
-		/* This code is  needed to support two enumerations on USB1.1 scenario */
-		DBUSERR(("%s: Firmware already downloaded\n", __FUNCTION__));
-
-		dbus_usbos_dl_cmd(osinfo, DL_RESETCFG, &id, sizeof(bootrom_id_t));
-		dl_needed = FALSE;
-		if (usbinfo->pub->busstate == DBUS_STATE_DL_PENDING)
-			usbinfo->pub->busstate = DBUS_STATE_DL_DONE;
-	} else {
-		usbinfo->pub->attrib.devid = id.chip;
-		usbinfo->pub->attrib.chiprev = id.chiprev;
-	}
-
-exit:
-	return dl_needed;
-}
-
-/** After issuing firmware download, higher DBUS level (dbus.c) wants to start the firmware. */
-static int
-dbus_usb_dlrun(void *bus)
-{
-	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
-	void *osinfo;
-	rdl_state_t state;
-	int err = DBUS_OK;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (usbinfo == NULL)
-		return DBUS_ERR;
-
-	if (USB_DEV_ISBAD(usbinfo))
-		return DBUS_ERR;
-
-	osinfo = usbinfo->usbosl_info;
-	ASSERT(osinfo);
-
-	/* Check we are runnable */
-	dbus_usbos_dl_cmd(osinfo, DL_GETSTATE, &state, sizeof(rdl_state_t));
-
-	state.state = ltoh32(state.state);
-	state.bytes = ltoh32(state.bytes);
-
-	/* Start the image */
-	if (state.state == DL_RUNNABLE) {
-		DBUSTRACE(("%s: Issue DL_GO\n", __FUNCTION__));
-		dbus_usbos_dl_cmd(osinfo, DL_GO, &state, sizeof(rdl_state_t));
-
-		if (usbinfo->pub->attrib.devid == TEST_CHIP)
-			dbus_usbos_wait(osinfo, USB_DLGO_SPINWAIT);
-
-		dbus_usb_resetcfg(usbinfo);
-		/* The Donlge may go for re-enumeration. */
-	} else {
-		DBUSERR(("%s: Dongle not runnable\n", __FUNCTION__));
-		err = DBUS_ERR;
-	}
-
-	return err;
-}
-
-/**
- * As preparation for firmware download, higher DBUS level (dbus.c) requests the firmware image
- * to be used for the type of dongle detected. Directly called by dbus.c (so not via a callback
- * construction)
- */
-void
-dbus_bus_fw_get(void *bus, uint8 **fw, int *fwlen, int *decomp)
-{
-	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
-	unsigned int devid;
-	unsigned int crev;
-
-	devid = usbinfo->pub->attrib.devid;
-	crev = usbinfo->pub->attrib.chiprev;
-
-	*fw = NULL;
-	*fwlen = 0;
-
-	switch (devid) {
-	case BCM43236_CHIP_ID:
-	case BCM43235_CHIP_ID:
-	case BCM43234_CHIP_ID:
-	case BCM43238_CHIP_ID: {
-		if (crev == 3 || crev == 2 || crev == 1) {
-#ifdef EMBED_IMAGE_43236b
-			*fw = (uint8 *)dlarray_43236b;
-			*fwlen = sizeof(dlarray_43236b);
-#endif
-#ifdef EMBED_IMAGE_43238b
-			*fw = (uint8 *)dlarray_43238b;
-			*fwlen = sizeof(dlarray_43238b);
-#endif
-
-		}
-	}	break;
-	case BCM4360_CHIP_ID:
-#ifdef EMBED_IMAGE_4360b
-		if (crev > 2) {
-			*fw = (uint8 *)dlarray_4360b;
-			*fwlen = sizeof(dlarray_4360b);
-		}
-#endif
-		break;
-	case BCM4352_CHIP_ID:
-	case BCM43526_CHIP_ID:
-#ifdef EMBED_IMAGE_43526a
-		if (crev <= 2) {
-			*fw = (uint8 *)dlarray_43526a;
-			*fwlen = sizeof(dlarray_43526a);
-		}
-#endif
-#ifdef EMBED_IMAGE_43526b
-		if (crev > 2) {
-			*fw = (uint8 *)dlarray_43526b;
-			*fwlen = sizeof(dlarray_43526b);
-		}
-#endif
-		break;
-
-	case BCM43242_CHIP_ID:
-#ifdef EMBED_IMAGE_43242a0
-		*fw = (uint8 *)dlarray_43242a0;
-		*fwlen = sizeof(dlarray_43242a0);
-#elif defined(EMBED_IMAGE_43242a1)
-		*fw = (uint8 *)dlarray_43242a1;
-		*fwlen = sizeof(dlarray_43242a1);
-#endif
-		break;
-
-	case BCM43143_CHIP_ID:
-#ifdef EMBED_IMAGE_43143a0
-		*fw = (uint8 *)dlarray_43143a0;
-		*fwlen = sizeof(dlarray_43143a0);
-#elif defined(EMBED_IMAGE_43143b0)
-		*fw = (uint8 *)dlarray_43143b0;
-		*fwlen = sizeof(dlarray_43143b0);
-#endif
-		break;
-
-	case BCM4350_CHIP_ID:
-#ifdef EMBED_IMAGE_4350a0
-		if (crev == 0) {
-			*fw = (uint8 *)dlarray_4350a0;
-			*fwlen = sizeof(dlarray_4350a0);
-		}
-#endif
-#ifdef EMBED_IMAGE_4350b0
-		if (crev == 1) {
-			*fw = (uint8 *)dlarray_4350b0;
-			*fwlen = sizeof(dlarray_4350b0);
-		}
-#endif
-#ifdef EMBED_IMAGE_4350b1
-		if (crev == 2) {
-			*fw = (uint8 *)dlarray_4350b1;
-			*fwlen = sizeof(dlarray_4350b1);
-		}
-#endif
-		break;
-
-	default:
-#ifdef EMBED_IMAGE_GENERIC
-		*fw = (uint8 *)dlarray;
-		*fwlen = sizeof(dlarray);
-#endif
-		break;
-	}
-}
-
-#ifdef BCM_DNGL_EMBEDIMAGE
-static bool
-dbus_usb_device_exists(void *bus)
-{
-	usb_info_t *usbinfo = BUS_INFO(bus, usb_info_t);
-	void *osinfo;
-	bootrom_id_t id;
-
-	DBUSTRACE(("%s\n", __FUNCTION__));
-
-	if (usbinfo == NULL)
-		return FALSE;
-
-	osinfo = usbinfo->usbosl_info;
-	ASSERT(osinfo);
-
-	id.chip = 0xDEAD;
-	/* Query device to see if we get a response */
-	dbus_usbos_dl_cmd(osinfo, DL_GETVER, &id, sizeof(bootrom_id_t));
-
-	usbinfo->pub->attrib.devid = id.chip;
-	if (id.chip == 0xDEAD)
-		return FALSE;
-	else
-		return TRUE;
-}
-#endif /* BCM_DNGL_EMBEDIMAGE */
diff -Nuar merlin-bkp/shared/dbus_usb_linux.c merlin-new/shared/dbus_usb_linux.c
--- merlin-bkp/shared/dbus_usb_linux.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/dbus_usb_linux.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3993 +0,0 @@
-/*
- * Dongle BUS interface
- * USB Linux Implementation
- *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
- * 
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * $Id: dbus_usb_linux.c 431326 2013-10-23 06:42:11Z $
- */
-
-#include <typedefs.h>
-#include <osl.h>
-
-/**
- * DBUS_LINUX_RXDPC is created for router platform performance tuning. A separate thread is created
- * to handle USB RX and avoid the call chain getting too long and enhance cache hit rate.
- *
- * DBUS_LINUX_RXDPC setting is in wlconfig file.
- */
-
-/*
- * If DBUS_LINUX_RXDPC is off, spin_lock_bh() for CTFPOOL in
- * linux_osl.c has to be changed to spin_lock_irqsave() because
- * PKTGET/PKTFREE are no longer in bottom half.
- *
- * Right now we have another queue rpcq in wl_linux.c. Maybe we
- * can eliminate that one to reduce the overhead.
- *
- * Enabling 2nd EP and DBUS_LINUX_RXDPC causing traffic from
- * both EP's to be queued in the same rx queue. If we want
- * RXDPC to work with 2nd EP. The EP for RPC call return
- * should bypass the dpc and go directly up.
- */
-
-/* #define DBUS_LINUX_RXDPC */
-
-/* Dbus histogram for ntxq, nrxq, dpc parameter tuning */
-/* #define DBUS_LINUX_HIST */
-
-#include <usbrdl.h>
-#include <bcmendian.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/usb.h>
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-#include <linux/random.h>
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <asm/uaccess.h>
-#include <asm/unaligned.h>
-#include <dbus.h>
-#include <bcmutils.h>
-#include <bcmdevs.h>
-#include <linux/usb.h>
-#include <usbrdl.h>
-#include <linux/firmware.h>
-#ifdef DBUS_LINUX_RXDPC
-#include <linux/sched.h>
-#endif
-#ifdef USBOS_THREAD
-/**
- * The usb-thread is designed to provide currency on multiprocessors and SMP linux kernels. On the
- * dual cores platform, the WLAN driver, without threads, executed only on CPU0. The driver consumed
- * almost of 100% on CPU0, while CPU1 remained idle. The behavior was observed on Broadcom's STB.
- *
- * The WLAN driver consumed most of CPU0 and not CPU1 because tasklets/queues, software irq, and
- * hardware irq are executing from CPU0, only. CPU0 became the system's bottle-neck. TPUT is lower
- * and system's responsiveness is slower.
- *
- * To improve system responsiveness and TPUT usb-thread was implemented. The system's threads could
- * be scheduled to run on any core. One core could be processing data in the usb-layer and the other
- * core could be processing data in the wl-layer.
- *
- * For further info see [WlThreadAndUsbThread] Twiki.
- */
-
-#include <linux/kthread.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/hardirq.h>
-#include <linux/list.h>
-#include <linux_osl.h>
-#endif /* USBOS_THREAD */
-
-
-#ifdef DBUS_LINUX_RXDPC
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25))
-#define RESCHED()   _cond_resched()
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
-#define RESCHED()   cond_resched()
-#else
-#define RESCHED()   __cond_resched()
-#endif /* LINUX_VERSION_CODE  */
-#endif	/* DBUS_LINUX_RXDPC */
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
-#define KERNEL26
-
-#define USB_ALLOC_URB()      usb_alloc_urb(0, GFP_ATOMIC)
-#define USB_SUBMIT_URB(urb)  usb_submit_urb(urb, GFP_ATOMIC)
-#define USB_UNLINK_URB(urb)  (usb_kill_urb(urb))
-#define USB_FREE_URB(urb)    (usb_free_urb(urb))
-#define USB_REGISTER()       usb_register(&dbus_usbdev)
-#define USB_DEREGISTER()     usb_deregister(&dbus_usbdev)
-#if defined(CONFIG_USB_SUSPEND)
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && (LINUX_VERSION_CODE < \
-	KERNEL_VERSION(2, 6, 33)))
-#define USB_AUTOPM_SET_INTERFACE(intf)  usb_autopm_set_interface(intf)
-#else
-#define USB_ENABLE_AUTOSUSPEND(udev)    usb_enable_autosuspend(udev)
-#define USB_DISABLE_AUTOSUSPEND(udev)    usb_disable_autosuspend(udev)
-#endif  /* ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) .....  */
-#endif  /* defined(CONFIG_USB_SUSPEND) */
-
-#define USB_CONTROL_MSG(dev, pipe, request, requesttype, value, index, data, size, timeout) \
-	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), \
-	(data), (size), (timeout))
-#define USB_BUFFER_ALLOC(dev, size, mem, dma)  usb_buffer_alloc(dev, size, mem, dma)
-#define USB_BUFFER_FREE(dev, size, data, dma)  usb_buffer_free(dev, size, data, dma)
-
-#ifdef WL_URB_ZPKT
-#define URB_QUEUE_BULK   URB_ZERO_PACKET
-#else
-#define URB_QUEUE_BULK   0
-#endif /* WL_URB_ZPKT */
-
-#define CALLBACK_ARGS      struct urb *urb, struct pt_regs *regs
-#define CALLBACK_ARGS_DATA urb, regs
-#define CONFIGDESC(usb)    (&((usb)->actconfig)->desc)
-#define IFPTR(usb, idx)    ((usb)->actconfig->interface[idx])
-#define IFALTS(usb, idx)   (IFPTR((usb), (idx))->altsetting[0])
-#define IFDESC(usb, idx)   IFALTS((usb), (idx)).desc
-#define IFEPDESC(usb, idx, ep) (IFALTS((usb), (idx)).endpoint[ep]).desc
-
-#ifdef DBUS_LINUX_RXDPC
-#define DAEMONIZE(a)   daemonize(a); allow_signal(SIGKILL); allow_signal(SIGTERM);
-#define SET_NICE(n)    set_user_nice(current, n)
-#endif /* DBUS_LINUX_RXDPC */
-
-#else /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */
-
-#define USB_ALLOC_URB()     usb_alloc_urb(0)
-#define USB_SUBMIT_URB(urb) usb_submit_urb(urb)
-#define USB_UNLINK_URB(urb) usb_unlink_urb(urb)
-#define USB_FREE_URB(urb)   (usb_free_urb(urb))
-#define USB_REGISTER()      usb_register(&dbus_usbdev)
-#define USB_DEREGISTER()    usb_deregister(&dbus_usbdev)
-
-#define USB_CONTROL_MSG(dev, pipe, request, requesttype, value, index, data, size, timeout) \
-	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), \
-	(data), (size), (timeout))
-#define USB_BUFFER_ALLOC(dev, size, mem, dma)  kmalloc(size, mem)
-#define USB_BUFFER_FREE(dev, size, data, dma)  kfree(data)
-
-#ifdef WL_URB_ZPKT
-#define URB_QUEUE_BULK   USB_QUEUE_BULK|URB_ZERO_PACKET
-#else
-#define URB_QUEUE_BULK   0
-#endif /*  WL_URB_ZPKT */
-
-#define CALLBACK_ARGS     struct urb *urb
-#define CALLBACK_ARGS_DATA urb
-#define CONFIGDESC(usb)   ((usb)->actconfig)
-#define IFPTR(usb, idx)   (&(usb)->actconfig->interface[idx])
-#define IFALTS(usb, idx)  ((usb)->actconfig->interface[idx].altsetting[0])
-#define IFDESC(usb, idx)  IFALTS((usb), (idx))
-#define IFEPDESC(usb, idx, ep)  (IFALTS((usb), (idx)).endpoint[ep])
-
-#ifdef DBUS_LINUX_RXDPC
-#define DAEMONIZE(a)    daemonize();
-#define SET_NICE(n)     do {current->nice = (n);} while (0)
-#endif /* DBUS_LINUX_RXDPC */
-
-#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))
-#define USB_SPEED_SUPER		5
-#endif  /* #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)) */
-
-#define CONTROL_IF   0
-#define BULK_IF      0
-
-#ifdef BCMUSBDEV_COMPOSITE
-#define USB_COMPIF_MAX       4
-
-#define USB_CLASS_WIRELESS   0xe0
-#define USB_CLASS_MISC       0xef
-#define USB_SUBCLASS_COMMON  0x02
-#define USB_PROTO_IAD        0x01
-#define USB_PROTO_VENDOR	 0xff
-
-#define USB_QUIRK_NO_SET_INTF   0x04 /* device does not support set_interface */
-#endif /* BCMUSBDEV_COMPOSITE */
-
-#define USB_SYNC_WAIT_TIMEOUT  300  /* ms */
-
-/* Private data kept in skb */
-#define SKB_PRIV(skb, idx)  (&((void **)skb->cb)[idx])
-#define SKB_PRIV_URB(skb)   (*(struct urb **)SKB_PRIV(skb, 0))
-
-#define BCM_USB_HOST_TOTALLEN_ZLP      512
-#define BCM_USB_HOST_TOTALLEN_ZLP_PAD  8
-
-#ifndef DBUS_USB_RXQUEUE_BATCH_ADD
-/* items to add each time within limit */
-#define DBUS_USB_RXQUEUE_BATCH_ADD            8
-#endif
-#ifndef DBUS_USB_RXQUEUE_LOWER_WATERMARK
-/* add a new batch req to rx queue when waiting item count reduce to this number */
-#define DBUS_USB_RXQUEUE_LOWER_WATERMARK      4
-#endif
-
-enum usbos_suspend_state {
-	USBOS_SUSPEND_STATE_DEVICE_ACTIVE = 0, /* Device is busy, won't allow suspend */
-	USBOS_SUSPEND_STATE_SUSPEND_PENDING,   /* Device is idle, can be suspended */
-	                                       /* Wating PM to suspend */
-	USBOS_SUSPEND_STATE_SUSPENDED          /* Device suspended */
-};
-
-typedef struct {
-	uint32 notification;
-	uint32 reserved;
-} intr_t;
-
-typedef struct {
-	dbus_pub_t *pub;
-
-	void *cbarg;
-	dbus_intf_callbacks_t *cbs;
-
-	/* Imported */
-	struct usb_device *usb;	/* USB device pointer from OS */
-	struct urb *intr_urb; /* URB for interrupt endpoint */
-	struct list_head req_rxfreeq;
-	struct list_head req_txfreeq;
-	struct list_head req_rxpostedq;	/* Posted down to USB driver for RX */
-	struct list_head req_txpostedq;	/* Posted down to USB driver for TX */
-	spinlock_t rxfree_lock; /* Lock for rx free list */
-	spinlock_t txfree_lock; /* Lock for tx free list */
-	spinlock_t rxposted_lock; /* Lock for rx posted list */
-	spinlock_t txposted_lock; /* Lock for tx posted list */
-	uint rx_pipe, tx_pipe, intr_pipe, rx_pipe2; /* Pipe numbers for USB I/O */
-	uint rxbuf_len;
-
-	struct list_head req_rxpendingq; /* RXDPC: Pending for dpc to send up */
-	spinlock_t rxpending_lock;	/* RXDPC: Lock for rx pending list */
-	long dpc_pid;
-	struct semaphore dpc_sem;
-	struct completion dpc_exited;
-	int rxpending;
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	int	dpc_cnt, dpc_pktcnt, dpc_maxpktcnt;
-#endif
-
-	struct urb *ctl_urb;
-	int ctl_in_pipe, ctl_out_pipe;
-	struct usb_ctrlrequest ctl_write;
-	struct usb_ctrlrequest ctl_read;
-
-	spinlock_t rxlock;      /* Lock for rxq management */
-	spinlock_t txlock;      /* Lock for txq management */
-
-	int intr_size;          /* Size of interrupt message */
-	int interval;           /* Interrupt polling interval */
-	intr_t intr;            /* Data buffer for interrupt endpoint */
-
-	int maxps;
-	int txposted;
-	atomic_t rxposted;
-	atomic_t txallocated;
-	atomic_t rxallocated;
-	bool rxctl_deferrespok;	/* Get a response for setup from dongle */
-
-	wait_queue_head_t wait;
-	bool waitdone;
-	int sync_urb_status;
-
-	struct urb *blk_urb; /* Used for downloading embedded image */
-
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	int *txposted_hist;
-	int *rxposted_hist;
-#endif
-#ifdef USBOS_THREAD
-	spinlock_t              ctrl_lock;
-	spinlock_t              usbos_list_lock;
-	struct list_head        usbos_list;
-	struct list_head        usbos_free_list;
-	atomic_t                usbos_list_cnt;
-	wait_queue_head_t       usbos_queue_head;
-	struct task_struct      *usbos_kt;
-#endif /* USBOS_THREAD */
-
-	struct dma_pool *qtd_pool; /* QTD pool for USB optimization only */
-	int tx_ep, rx_ep, rx2_ep;  /* EPs for USB optimization */
-	struct usb_device *usb_device; /* USB device for optimization */
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX) /** Linux USB AP related */
-	spinlock_t fastpath_lock;
-#endif
-} usbos_info_t;
-
-typedef struct urb_req {
-	void         *pkt;
-	int          buf_len;
-	struct urb   *urb;
-	void         *arg;
-	usbos_info_t *usbinfo;
-	struct list_head urb_list;
-} urb_req_t;
-
-#ifdef USBOS_THREAD
-typedef struct usbos_list_entry {
-	struct list_head    list;   /* must be first */
-	void               *urb_context;
-	int                 urb_length;
-	int                 urb_status;
-} usbos_list_entry_t;
-
-static void* dbus_usbos_thread_init(usbos_info_t *usbos_info);
-static void dbus_usbos_thread_deinit(usbos_info_t *usbos_info);
-static void dbus_usbos_dispatch_schedule(CALLBACK_ARGS);
-static int  dbus_usbos_thread_func(void *data);
-#endif /* USBOS_THREAD */
-
-/* Shared Function prototypes */
-bool dbus_usbos_dl_cmd(usbos_info_t *usbinfo, uint8 cmd, void *buffer, int buflen);
-int dbus_usbos_wait(usbos_info_t *usbinfo, uint16 ms);
-bool dbus_usbos_dl_send_bulk(usbos_info_t *usbinfo, void *buffer, int len);
-int dbus_write_membytes(usbos_info_t *usbinfo, bool set, uint32 address, uint8 *data, uint size);
-
-/* Local function prototypes */
-static void dbus_usbos_send_complete(CALLBACK_ARGS);
-#ifdef DBUS_LINUX_RXDPC
-static void dbus_usbos_recv_dpc(usbos_info_t *usbos_info);
-static int dbus_usbos_dpc_thread(void *data);
-#endif /* DBUS_LINUX_RXDPC */
-static void dbus_usbos_recv_complete(CALLBACK_ARGS);
-static int  dbus_usbos_errhandler(void *bus, int err);
-static int  dbus_usbos_state_change(void *bus, int state);
-static void dbusos_stop(usbos_info_t *usbos_info);
-
-#ifdef KERNEL26
-static int dbus_usbos_probe(struct usb_interface *intf, const struct usb_device_id *id);
-static void dbus_usbos_disconnect(struct usb_interface *intf);
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) \
-	&& (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 11, 1))
-static int dbus_usbos_resume(struct usb_interface *intf);
-static int dbus_usbos_suspend(struct usb_interface *intf, pm_message_t message);
-static void dbus_usbos_sleep(usbos_info_t *usbos_info);
-#endif
-#else
-static void *dbus_usbos_probe(struct usb_device *usb, unsigned int ifnum,
-	const struct usb_device_id *id);
-static void dbus_usbos_disconnect(struct usb_device *usb, void *ptr);
-#endif /* KERNEL26 */
-
-#ifdef USB_TRIGGER_DEBUG
-static bool dbus_usbos_ctl_send_debugtrig(usbos_info_t *usbinfo);
-#endif /* USB_TRIGGER_DEBUG */
-static struct usb_device_id devid_table[] = {
-	{ USB_DEVICE(BCM_DNGL_VID, 0x0000) }, /* Configurable via register() */
-#if !defined(WLC_HIGH) || defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4328) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4322) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4319) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43236) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43143) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_43242) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4360) },
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BL_PID_4350) },
-#endif
-#ifdef EXTENDED_VID_PID
-	EXTENDED_VID_PID,
-#endif /* EXTENDED_VID_PID */
-	{ USB_DEVICE(BCM_DNGL_VID, BCM_DNGL_BDC_PID) }, /* Default BDC */
-	{ }
-};
-
-MODULE_DEVICE_TABLE(usb, devid_table);
-
-/** functions called by the Linux kernel USB subsystem */
-static struct usb_driver dbus_usbdev = {
-	name:         "dbus_usbdev",
-	probe:        dbus_usbos_probe,
-	disconnect:   dbus_usbos_disconnect,
-	id_table:     devid_table,
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) \
-	&& (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 11, 1))
-	suspend:      dbus_usbos_suspend,
-	resume:       dbus_usbos_resume,
-	supports_autosuspend: 1
-#endif
-};
-
-/** This stores USB info during Linux probe callback
- * since attach() is not called yet at this point
- */
-typedef struct {
-	void    *usbos_info;
-	struct usb_device *usb; /* USB device pointer from OS */
-	uint    rx_pipe;   /* Pipe numbers for USB I/O */
-	uint    tx_pipe;   /* Pipe numbers for USB I/O */
-	uint    intr_pipe; /* Pipe numbers for USB I/O */
-	uint    rx_pipe2;  /* Pipe numbers for USB I/O */
-	int     intr_size; /* Size of interrupt message */
-	int     interval;  /* Interrupt polling interval */
-	bool    dldone;
-	int     vid;
-	int     pid;
-	bool    dereged;
-	bool    disc_cb_done;
-	DEVICE_SPEED    device_speed;
-	enum usbos_suspend_state suspend_state;
-	struct usb_interface     *intf;
-} probe_info_t;
-
-/*
- * USB Linux dbus_intf_t
- */
-static void *dbus_usbos_intf_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs);
-static void dbus_usbos_intf_detach(dbus_pub_t *pub, void *info);
-static int  dbus_usbos_intf_send_irb(void *bus, dbus_irb_tx_t *txirb);
-static int  dbus_usbos_intf_recv_irb(void *bus, dbus_irb_rx_t *rxirb);
-static int  dbus_usbos_intf_recv_irb_from_ep(void *bus, dbus_irb_rx_t *rxirb, uint32 ep_idx);
-static int  dbus_usbos_intf_cancel_irb(void *bus, dbus_irb_tx_t *txirb);
-static int  dbus_usbos_intf_send_ctl(void *bus, uint8 *buf, int len);
-static int  dbus_usbos_intf_recv_ctl(void *bus, uint8 *buf, int len);
-static int  dbus_usbos_intf_get_attrib(void *bus, dbus_attrib_t *attrib);
-static int  dbus_usbos_intf_up(void *bus);
-static int  dbus_usbos_intf_down(void *bus);
-static int  dbus_usbos_intf_stop(void *bus);
-static int  dbus_usbos_readreg(void *bus, uint32 regaddr, int datalen, uint32 *value);
-int dbus_usbos_writereg(void *bus, uint32 regaddr, int datalen, uint32 data);
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-static void dbus_usbos_intf_dump(void *bus, struct bcmstrbuf *b);
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-static int  dbus_usbos_intf_set_config(void *bus, dbus_config_t *config);
-static bool dbus_usbos_intf_recv_needed(void *bus);
-static void *dbus_usbos_intf_exec_rxlock(void *bus, exec_cb_t cb, struct exec_parms *args);
-static void *dbus_usbos_intf_exec_txlock(void *bus, exec_cb_t cb, struct exec_parms *args);
-static int dbus_usbos_intf_pnp(void *bus, int evnt);
-#ifdef BCMUSBDEV_COMPOSITE
-static int dbus_usbos_intf_wlan(struct usb_device *usb);
-#endif /* BCMUSBDEV_COMPOSITE */
-
-/** functions called by dbus_usb.c */
-static dbus_intf_t dbus_usbos_intf = {
-	dbus_usbos_intf_attach,
-	dbus_usbos_intf_detach,
-	dbus_usbos_intf_up,
-	dbus_usbos_intf_down,
-	dbus_usbos_intf_send_irb,
-	dbus_usbos_intf_recv_irb,
-	dbus_usbos_intf_cancel_irb,
-	dbus_usbos_intf_send_ctl,
-	dbus_usbos_intf_recv_ctl,
-	NULL, /* get_stats */
-	dbus_usbos_intf_get_attrib,
-	dbus_usbos_intf_pnp, /* pnp */
-	NULL, /* remove */
-	NULL, /* resume */
-	NULL, /* suspend */
-	dbus_usbos_intf_stop,
-	NULL, /* reset */
-	NULL, /* pktget */
-	NULL, /* pktfree */
-	NULL, /* iovar_op */
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	dbus_usbos_intf_dump, /* dump */
-#else
-	NULL, /* dump */
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-	dbus_usbos_intf_set_config, /* set_config */
-	NULL, /* get_config */
-	NULL, /* device_exists */
-	NULL, /* dlneeded */
-	NULL, /* dlstart */
-	NULL, /* dlrun */
-	dbus_usbos_intf_recv_needed,
-	dbus_usbos_intf_exec_rxlock,
-	dbus_usbos_intf_exec_txlock,
-
-	NULL, /* tx_timer_init */
-	NULL, /* tx_timer_start */
-	NULL, /* tx_timer_stop */
-
-	NULL, /* sched_dpc */
-	NULL, /* lock */
-	NULL, /* unlock */
-	NULL, /* sched_probe_cb */
-
-	NULL, /* shutdown */
-
-	NULL, /* recv_stop */
-	NULL, /* recv_resume */
-
-	dbus_usbos_intf_recv_irb_from_ep,
-	dbus_usbos_readreg
-};
-
-static probe_info_t    g_probe_info;
-static probe_cb_t      probe_cb = NULL;
-static disconnect_cb_t disconnect_cb = NULL;
-static void            *probe_arg = NULL;
-static void            *disc_arg = NULL;
-
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-#define EHCI_PAGE_SIZE    4096
-
-/* Copies of structures located elsewhere. */
-
-typedef struct {
-	dbus_pub_t *pub;
-
-	void *cbarg;
-	dbus_intf_callbacks_t *cbs;
-	dbus_intf_t *drvintf;
-	void *usbosl_info;
-} usb_info_t;
-
-/* This private structure dbus_info_t is also declared in dbus.c.
- * All the fields must be consistent in both declarations.
- */
-typedef struct dbus_info {
-	dbus_pub_t pub; /* MUST BE FIRST */
-
-	void *cbarg;
-	dbus_callbacks_t *cbs;
-	void *bus_info;
-	dbus_intf_t *drvintf;
-	uint8 *fw;
-	int fwlen;
-	uint32 errmask;
-	int rx_low_watermark;
-	int tx_low_watermark;
-	bool txoff;
-	bool txoverride;
-	bool rxoff;
-	bool tx_timer_ticking;
-
-	dbus_irbq_t *rx_q;
-	dbus_irbq_t *tx_q;
-
-#ifdef BCMDBG
-	int *txpend_q_hist;
-	int *rxpend_q_hist;
-#endif /* BCMDBG */
-#ifdef EHCI_FASTPATH_RX
-	atomic_t rx_outstanding;
-#endif
-	uint8 *nvram;
-	int	nvram_len;
-	uint8 *image;	/* buffer for combine fw and nvram */
-	int image_len;
-	uint8 *orig_fw;
-	int origfw_len;
-	int decomp_memsize;
-	dbus_extdl_t extdl;
-	int nvram_nontxt;
-} dbus_info_t;
-
-static atomic_t s_tx_pending;
-
-static int optimize_qtd_fill_with_data(const dbus_pub_t *pub, int epn, struct ehci_qtd *qtd,
-	void *data,	int token, int len);
-static void inline optimize_ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma);
-static int optimize_init(usbos_info_t *usbos_info, struct usb_device *usb, int out, int in,
-	int in2);
-static int optimize_deinit(usbos_info_t *usbos_info, struct usb_device *usb);
-#endif  /* #if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX) */
-
-
-/**
- * multiple code paths in this file dequeue a URB request, this function makes sure that it happens
- * in a concurrency save manner. Don't call this from a sleepable process context.
- */
-static urb_req_t * BCMFASTPATH
-dbus_usbos_qdeq(struct list_head *urbreq_q, spinlock_t *lock)
-{
-	unsigned long flags;
-	urb_req_t *req;
-
-	ASSERT(urbreq_q != NULL);
-
-	spin_lock_irqsave(lock, flags);
-
-	if (list_empty(urbreq_q)) {
-		req = NULL;
-	} else {
-		ASSERT(urbreq_q->next != NULL);
-		ASSERT(urbreq_q->next != urbreq_q);
-
-		req = list_entry(urbreq_q->next, urb_req_t, urb_list);
-		list_del_init(&req->urb_list);
-	}
-
-	spin_unlock_irqrestore(lock, flags);
-
-	return req;
-}
-
-static void BCMFASTPATH
-dbus_usbos_qenq(struct list_head *urbreq_q, urb_req_t *req, spinlock_t *lock)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(lock, flags);
-
-	list_add_tail(&req->urb_list, urbreq_q);
-
-	spin_unlock_irqrestore(lock, flags);
-
-}
-
-/**
- * multiple code paths in this file remove a URB request from a list, this function makes sure that
- * it happens in a concurrency save manner. Don't call this from a sleepable process context.
- * Is quite similar to dbus_usbos_qdeq(), I wonder why this function is needed.
- */
-static void
-dbus_usbos_req_del(urb_req_t *req, spinlock_t *lock)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(lock, flags);
-
-	list_del_init(&req->urb_list);
-
-	spin_unlock_irqrestore(lock, flags);
-}
-
-/**
- * Driver requires a pool of URBs to operate. This function is called during
- * initialization (attach phase), allocates a number of URBs, and puts them
- * on the free (req_rxfreeq and req_txfreeq) queue
- */
-static int
-dbus_usbos_urbreqs_alloc(usbos_info_t *usbos_info, uint32 count, bool is_rx)
-{
-	int i;
-	int allocated = 0;
-	int err = DBUS_OK;
-
-	for (i = 0; i < count; i++) {
-		urb_req_t *req;
-
-		req = MALLOC(usbos_info->pub->osh, sizeof(urb_req_t));
-		if (req == NULL) {
-			DBUSERR(("%s: MALLOC req failed\n", __FUNCTION__));
-			err = DBUS_ERR_NOMEM;
-			goto fail;
-		}
-		bzero(req, sizeof(urb_req_t));
-
-		req->urb = USB_ALLOC_URB();
-		if (req->urb == NULL) {
-			DBUSERR(("%s: USB_ALLOC_URB req->urb failed\n", __FUNCTION__));
-			err = DBUS_ERR_NOMEM;
-			goto fail;
-		}
-
-		INIT_LIST_HEAD(&req->urb_list);
-
-		if (is_rx) {
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-			/* don't allocate now. Do it on demand */
-			req->pkt = NULL;
-#else
-			/* pre-allocate  buffers never to be released */
-			req->pkt = MALLOC(usbos_info->pub->osh, usbos_info->rxbuf_len);
-			if (req->pkt == NULL) {
-				DBUSERR(("%s: MALLOC req->pkt failed\n", __FUNCTION__));
-				err = DBUS_ERR_NOMEM;
-				goto fail;
-			}
-#endif
-			req->buf_len = usbos_info->rxbuf_len;
-			dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
-		} else {
-			req->buf_len = 0;
-			dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
-		}
-		allocated++;
-		continue;
-
-fail:
-		if (req) {
-			if (is_rx && req->pkt) {
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-				/* req->pkt is NULL in "NOCOPY" mode */
-#else
-				MFREE(usbos_info->pub->osh, req->pkt, req->buf_len);
-#endif
-			}
-			if (req->urb) {
-				USB_FREE_URB(req->urb);
-			}
-			MFREE(usbos_info->pub->osh, req, sizeof(urb_req_t));
-		}
-		break;
-	}
-
-	atomic_add(allocated, is_rx ? &usbos_info->rxallocated : &usbos_info->txallocated);
-
-	if (is_rx) {
-		DBUSTRACE(("%s: add %d (total %d) rx buf, each has %d bytes\n", __FUNCTION__,
-			allocated, atomic_read(&usbos_info->rxallocated), usbos_info->rxbuf_len));
-	} else {
-		DBUSTRACE(("%s: add %d (total %d) tx req\n", __FUNCTION__,
-			allocated, atomic_read(&usbos_info->txallocated)));
-	}
-
-	return err;
-}
-
-/** Typically called during detach or when attach failed. Don't call until all URBs unlinked */
-static int
-dbus_usbos_urbreqs_free(usbos_info_t *usbos_info, bool is_rx)
-{
-	int rtn = 0;
-	urb_req_t *req;
-	struct list_head *req_q;
-	spinlock_t *lock;
-
-	if (is_rx) {
-		req_q = &usbos_info->req_rxfreeq;
-		lock = &usbos_info->rxfree_lock;
-	} else {
-		req_q = &usbos_info->req_txfreeq;
-		lock = &usbos_info->txfree_lock;
-	}
-	while ((req = dbus_usbos_qdeq(req_q, lock)) != NULL) {
-
-		if (is_rx) {
-			if (req->pkt) {
-				/* We do MFREE instead of PKTFREE because the pkt has been
-				 * converted to native already
-				 */
-				MFREE(usbos_info->pub->osh, req->pkt, req->buf_len);
-				req->pkt = NULL;
-				req->buf_len = 0;
-			}
-		}
-		else {
-			/* sending req should not be assigned pkt buffer */
-			ASSERT(req->pkt == NULL);
-		}
-
-		if (req->urb) {
-			USB_FREE_URB(req->urb);
-			req->urb = NULL;
-		}
-		MFREE(usbos_info->pub->osh, req, sizeof(urb_req_t));
-
-		rtn++;
-	}
-	return rtn;
-}
-
-/**
- * called by Linux kernel on URB completion. Upper DBUS layer (dbus_usb.c) has to be notified of
- * send completion.
- */
-void
-dbus_usbos_send_complete(CALLBACK_ARGS)
-{
-	urb_req_t *req = urb->context;
-	dbus_irb_tx_t *txirb = req->arg;
-	usbos_info_t *usbos_info = req->usbinfo;
-	unsigned long flags;
-	int status = DBUS_OK;
-
-	spin_lock_irqsave(&usbos_info->txlock, flags);
-	dbus_usbos_req_del(req, &usbos_info->txposted_lock);
-	usbos_info->txposted--;
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	if (usbos_info->txposted_hist) {
-		usbos_info->txposted_hist[usbos_info->txposted]++;
-	}
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-	if (unlikely (usbos_info->txposted < 0)) {
-		DBUSERR(("%s ERROR: txposted is negative!!\n", __FUNCTION__));
-	}
-	spin_unlock_irqrestore(&usbos_info->txlock, flags);
-
-	if (unlikely (urb->status)) {
-		status = DBUS_ERR_TXFAIL;
-		DBUSTRACE(("txfail status %d\n", urb->status));
-	}
-
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-	/* sending req should not be assigned pkt buffer */
-	ASSERT(req->pkt == NULL);
-#endif
-	if (txirb->send_buf) {
-		MFREE(usbos_info->pub->osh, txirb->send_buf, req->buf_len);
-		txirb->send_buf = NULL;
-		req->buf_len = 0;
-	}
-	if (likely (usbos_info->cbarg && usbos_info->cbs)) {
-		if (likely (usbos_info->cbs->send_irb_complete != NULL))
-			usbos_info->cbs->send_irb_complete(usbos_info->cbarg, txirb, status);
-	}
-
-	dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
-}
-
-/**
- * In order to receive USB traffic from the dongle, we need to supply the Linux kernel with a free
- * URB that is going to contain received data.
- */
-static int BCMFASTPATH
-dbus_usbos_recv_urb_submit(usbos_info_t *usbos_info, dbus_irb_rx_t *rxirb, uint32 ep_idx)
-{
-	urb_req_t *req;
-	int ret = DBUS_OK;
-	unsigned long flags;
-	void *p;
-	uint rx_pipe;
-	int rxposted;
-
-	BCM_REFERENCE(rxposted);
-
-	if (!(req = dbus_usbos_qdeq(&usbos_info->req_rxfreeq, &usbos_info->rxfree_lock))) {
-		DBUSTRACE(("%s No free URB!\n", __FUNCTION__));
-		return DBUS_ERR_RXDROP;
-	}
-
-	spin_lock_irqsave(&usbos_info->rxlock, flags);
-
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-	req->pkt = rxirb->pkt = PKTGET(usbos_info->pub->osh, req->buf_len, FALSE);
-	if (!rxirb->pkt) {
-		DBUSERR(("%s: PKTGET failed\n", __FUNCTION__));
-		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
-		ret = DBUS_ERR_RXDROP;
-		goto fail;
-	}
-	/* consider the packet "native" so we don't count it as MALLOCED in the osl */
-	PKTTONATIVE(usbos_info->pub->osh, req->pkt);
-	rxirb->buf = NULL;
-	p = PKTDATA(usbos_info->pub->osh, req->pkt);
-#else
-	rxirb->buf = req->pkt;
-	p = rxirb->buf;
-#endif /* defined(BCM_RPC_NOCOPY) */
-	rxirb->buf_len = req->buf_len;
-	req->usbinfo = usbos_info;
-	req->arg = rxirb;
-	if (ep_idx == 0) {
-		rx_pipe = usbos_info->rx_pipe;
-	} else {
-		rx_pipe = usbos_info->rx_pipe2;
-		ASSERT(usbos_info->rx_pipe2);
-	}
-	/* Prepare the URB */
-	usb_fill_bulk_urb(req->urb, usbos_info->usb, rx_pipe,
-		p,
-		rxirb->buf_len,
-		(usb_complete_t)dbus_usbos_recv_complete, req);
-		req->urb->transfer_flags |= URB_QUEUE_BULK;
-
-	if ((ret = USB_SUBMIT_URB(req->urb))) {
-		DBUSERR(("%s USB_SUBMIT_URB failed. status %d\n", __FUNCTION__, ret));
-		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
-		ret = DBUS_ERR_RXFAIL;
-		goto fail;
-	}
-	rxposted = atomic_inc_return(&usbos_info->rxposted);
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	if (usbos_info->rxposted_hist) {
-		usbos_info->rxposted_hist[rxposted]++;
-	}
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-
-	dbus_usbos_qenq(&usbos_info->req_rxpostedq, req, &usbos_info->rxposted_lock);
-fail:
-	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
-	return ret;
-}
-
-#ifdef DBUS_LINUX_RXDPC
-static void BCMFASTPATH
-dbus_usbos_recv_dpc(usbos_info_t *usbos_info)
-{
-	urb_req_t *req = NULL;
-	dbus_irb_rx_t *rxirb = NULL;
-	int dbus_status = DBUS_OK;
-	bool killed = (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) ? 1 : 0;
-
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	int cnt = 0;
-
-	usbos_info->dpc_cnt++;
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-
-	while ((req = dbus_usbos_qdeq(&usbos_info->req_rxpendingq,
-		&usbos_info->rxpending_lock)) != NULL) {
-		struct urb *urb = req->urb;
-		rxirb = req->arg;
-
-		/* Handle errors */
-		if (urb->status) {
-			/*
-			 * Linux 2.4 disconnect: -ENOENT or -EILSEQ for CRC error; rmmod: -ENOENT
-			 * Linux 2.6 disconnect: -EPROTO, rmmod: -ESHUTDOWN
-			 */
-			if ((urb->status == -ENOENT && (!killed)) || urb->status == -ESHUTDOWN) {
-				/* NOTE: unlink() can not be called from URB callback().
-				 * Do not call dbusos_stop() here.
-				 */
-				dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
-			} else if (urb->status == -EPROTO) {
-			} else {
-				DBUSERR(("%s rx error %d\n", __FUNCTION__, urb->status));
-				dbus_usbos_errhandler(usbos_info, DBUS_ERR_RXFAIL);
-			}
-
-			/* On error, don't submit more URBs yet */
-			DBUSERR(("%s %d rx error %d\n", __FUNCTION__, __LINE__, urb->status));
-			rxirb->buf = NULL;
-			rxirb->actual_len = 0;
-			dbus_status = DBUS_ERR_RXFAIL;
-			goto fail;
-		}
-
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-		/* detach the packet from the req */
-		req->pkt = NULL;
-#endif
-		/* Make the skb represent the received urb */
-		rxirb->actual_len = urb->actual_length;
-
-fail:
-		usbos_info->rxpending--;
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-		cnt++;
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-		if (usbos_info->cbarg && usbos_info->cbs &&
-			usbos_info->cbs->recv_irb_complete) {
-			usbos_info->cbs->recv_irb_complete(usbos_info->cbarg, rxirb, dbus_status);
-		}
-		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
-	}
-
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	usbos_info->dpc_pktcnt += cnt;
-	usbos_info->dpc_maxpktcnt = MAX(cnt, usbos_info->dpc_maxpktcnt);
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-#ifdef DBUS_LINUX_HIST
-	{
-		static unsigned long last_dump = 0;
-
-		/* dump every 20 sec */
-		if (jiffies > (last_dump + 20*HZ)) {
-			dbus_usbos_intf_dump(usbos_info, NULL);
-			last_dump = jiffies;
-		}
-	}
-#endif /* DBUS_LINUX_HIST */
-}
-
-static int BCMFASTPATH
-dbus_usbos_dpc_thread(void *data)
-{
-	usbos_info_t *usbos_info = (usbos_info_t*)data;
-
-	DAEMONIZE("dbus_rx_dpc");
-	/* High priority for short response time. We will yield by ourselves. */
-	/* SET_NICE(-10); */
-
-	/* Run until signal received */
-	while (1) {
-		if (down_interruptible(&usbos_info->dpc_sem) == 0) {
-			dbus_usbos_recv_dpc(usbos_info);
-			RESCHED();
-		} else
-			break;
-	}
-
-	complete_and_exit(&usbos_info->dpc_exited, 0);
-	return 0;
-}
-#endif /* DBUS_LINUX_RXDPC */
-
-/* called by worked thread when a 'receive URB' completed */
-/* or Linux kernel when it returns a URB to this driver */
-static void BCMFASTPATH
-dbus_usbos_recv_complete_handle(urb_req_t *req, int len, int status)
-{
-#ifdef DBUS_LINUX_RXDPC
-	usbos_info_t *usbos_info = req->usbinfo;
-	unsigned long flags;
-	int rxallocated, rxposted;
-
-	spin_lock_irqsave(&usbos_info->rxlock, flags);
-	/* detach the packet from the queue */
-	dbus_usbos_req_del(req, &usbos_info->rxposted_lock);
-	rxposted = atomic_dec_return(&usbos_info->rxposted);
-	rxallocated = atomic_read(&usbos_info->rxallocated);
-
-	/* Enqueue to rxpending queue */
-	usbos_info->rxpending++;
-	dbus_usbos_qenq(&usbos_info->req_rxpendingq, req, &usbos_info->rxpending_lock);
-	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
-
-#error "RX req/buf appending-mode not verified for DBUS_LINUX_RXDPC because it was disabled"
-	if ((rxallocated < usbos_info->pub->nrxq) && (!status) &&
-		(rxposted == DBUS_USB_RXQUEUE_LOWER_WATERMARK)) {
-			DBUSTRACE(("%s: need more rx buf: rxallocated %d rxposted %d!\n",
-				__FUNCTION__, rxallocated, rxposted));
-			dbus_usbos_urbreqs_alloc(usbos_info,
-				MIN(DBUS_USB_RXQUEUE_BATCH_ADD,
-				usbos_info->pub->nrxq - rxallocated), TRUE);
-	}
-#error "Please verify above code works if you happened to enable DBUS_LINUX_RXDPC!!"
-
-	/* Wake up dpc for further processing */
-	ASSERT(usbos_info->dpc_pid >= 0);
-	up(&usbos_info->dpc_sem);
-#else
-	dbus_irb_rx_t *rxirb = req->arg;
-	usbos_info_t *usbos_info = req->usbinfo;
-	unsigned long flags;
-	int rxallocated, rxposted;
-	int dbus_status = DBUS_OK;
-	bool killed = (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) ? 1 : 0;
-
-	spin_lock_irqsave(&usbos_info->rxlock, flags);
-	dbus_usbos_req_del(req, &usbos_info->rxposted_lock);
-	rxposted = atomic_dec_return(&usbos_info->rxposted);
-	rxallocated = atomic_read(&usbos_info->rxallocated);
-	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
-
-	if ((rxallocated < usbos_info->pub->nrxq) && (!status) &&
-		(rxposted == DBUS_USB_RXQUEUE_LOWER_WATERMARK)) {
-			DBUSTRACE(("%s: need more rx buf: rxallocated %d rxposted %d!\n",
-				__FUNCTION__, rxallocated, rxposted));
-			dbus_usbos_urbreqs_alloc(usbos_info,
-				MIN(DBUS_USB_RXQUEUE_BATCH_ADD,
-				usbos_info->pub->nrxq - rxallocated), TRUE);
-	}
-
-	/* Handle errors */
-	if (status) {
-		/*
-		 * Linux 2.4 disconnect: -ENOENT or -EILSEQ for CRC error; rmmod: -ENOENT
-		 * Linux 2.6 disconnect: -EPROTO, rmmod: -ESHUTDOWN
-		 */
-		if ((status == -ENOENT && (!killed))|| status == -ESHUTDOWN) {
-			/* NOTE: unlink() can not be called from URB callback().
-			 * Do not call dbusos_stop() here.
-			 */
-			dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
-		} else if (status == -EPROTO) {
-		} else {
-			DBUSTRACE(("%s rx error %d\n", __FUNCTION__, status));
-			dbus_usbos_errhandler(usbos_info, DBUS_ERR_RXFAIL);
-		}
-
-		/* On error, don't submit more URBs yet */
-		rxirb->buf = NULL;
-		rxirb->actual_len = 0;
-		dbus_status = DBUS_ERR_RXFAIL;
-		goto fail;
-	}
-
-	/* Make the skb represent the received urb */
-	rxirb->actual_len = len;
-fail:
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-	/* detach the packet from the queue */
-	req->pkt = NULL;
-#endif /* BCM_RPC_NOCOPY || BCM_RPC_RXNOCOPY */
-
-	if (usbos_info->cbarg && usbos_info->cbs) {
-		if (usbos_info->cbs->recv_irb_complete) {
-			usbos_info->cbs->recv_irb_complete(usbos_info->cbarg, rxirb, dbus_status);
-		}
-	}
-
-	dbus_usbos_qenq(&usbos_info->req_rxfreeq, req, &usbos_info->rxfree_lock);
-#endif /* DBUS_LINUX_RXDPC */
-}
-
-/** called by Linux kernel when it returns a URB to this driver */
-static void
-dbus_usbos_recv_complete(CALLBACK_ARGS)
-{
-#ifdef USBOS_THREAD
-	dbus_usbos_dispatch_schedule(CALLBACK_ARGS_DATA);
-#else /*  !USBOS_THREAD */
-	dbus_usbos_recv_complete_handle(urb->context, urb->actual_length, urb->status);
-#endif /*  USBOS_THREAD */
-}
-
-#if (defined(WLC_HIGH) && defined(WLC_LOW))
-/** called by Linux kernel on URB completion */
-static void
-dbus_usbos_intr_complete(CALLBACK_ARGS)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
-#ifdef KERNEL26
-	int ret;
-#endif
-	bool killed = (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) ? 1 : 0;
-
-	if (usbos_info == NULL || usbos_info->pub == NULL)
-		return;
-	if ((urb->status == -ENOENT && (!killed)) || urb->status == -ESHUTDOWN ||
-		urb->status == -ENODEV) {
-		dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
-	}
-
-	if (usbos_info->pub->busstate == DBUS_STATE_DOWN) {
-		DBUSERR(("%s: intr cb when DBUS down, ignoring\n", __FUNCTION__));
-		return;
-	}
-
-#ifdef KERNEL26
-	/* Resubmit every time (2.6 only) */
-	if (((usbos_info->pub->busstate == DBUS_STATE_UP) &&
-	     (ret = USB_SUBMIT_URB(usbos_info->intr_urb))))
-		DBUSERR(("%s intr USB_SUBMIT_URB failed with status %d\n", __FUNCTION__, ret));
-#endif
-}
-#endif	/* (defined(WLC_HIGH) && defined(WLC_LOW)) */
-
-/**
- * If Linux notifies our driver that a control read or write URB has completed, we should notify
- * the DBUS layer above us (dbus_usb.c in this case).
- */
-static void
-dbus_usbos_ctl_complete(usbos_info_t *usbos_info, int type, int urbstatus)
-{
-	int status = DBUS_ERR;
-
-	if (usbos_info == NULL)
-		return;
-
-	switch (urbstatus) {
-		case 0:
-			status = DBUS_OK;
-		break;
-		case -EINPROGRESS:
-		case -ENOENT:
-		default:
-			DBUSERR(("%s: failed with status %d\n", __FUNCTION__, urbstatus));
-			status = DBUS_ERR;
-		break;
-	}
-
-	if (usbos_info->cbarg && usbos_info->cbs) {
-		if (usbos_info->cbs->ctl_complete)
-			usbos_info->cbs->ctl_complete(usbos_info->cbarg, type, status);
-	}
-}
-
-/** called by Linux */
-static void
-dbus_usbos_ctlread_complete(CALLBACK_ARGS)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
-#ifdef USBOS_THREAD
-	unsigned long flags;
-
-	spin_lock_irqsave(&usbos_info->ctrl_lock, flags);
-#endif /* USBOS_THREAD */
-
-	ASSERT(urb);
-	usbos_info = (usbos_info_t *)urb->context;
-
-	dbus_usbos_ctl_complete(usbos_info, DBUS_CBCTL_READ, urb->status);
-
-#ifdef USBOS_THREAD
-	if (usbos_info->rxctl_deferrespok) {
-		usbos_info->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_CLASS |
-		USB_RECIP_INTERFACE;
-		usbos_info->ctl_read.bRequest = 1;
-	}
-	spin_unlock_irqrestore(&usbos_info->ctrl_lock, flags);
-#endif
-}
-
-/** called by Linux */
-static void
-dbus_usbos_ctlwrite_complete(CALLBACK_ARGS)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
-#ifdef USBOS_THREAD
-	unsigned long flags;
-
-	spin_lock_irqsave(&usbos_info->ctrl_lock, flags);
-#endif /* USBOS_THREAD */
-
-	ASSERT(urb);
-	usbos_info = (usbos_info_t *)urb->context;
-
-	dbus_usbos_ctl_complete(usbos_info, DBUS_CBCTL_WRITE, urb->status);
-
-#ifdef USBOS_THREAD
-	spin_unlock_irqrestore(&usbos_info->ctrl_lock, flags);
-#endif
-}
-
-/**
- * when the bus is going to sleep or halt, the Linux kernel requires us to take ownership of our
- * URBs again. Multiple code paths in this file require a list of URBs to be cancelled in a
- * concurrency save manner.
- */
-static void
-dbus_usbos_unlink(struct list_head *urbreq_q, spinlock_t *lock)
-{
-	urb_req_t *req;
-
-	/* dbus_usbos_recv_complete() adds req back to req_freeq */
-	while ((req = dbus_usbos_qdeq(urbreq_q, lock)) != NULL) {
-		ASSERT(req->urb != NULL);
-		USB_UNLINK_URB(req->urb);
-	}
-}
-
-/** multiple code paths in this file require the bus to stop */
-static void
-dbusos_stop(usbos_info_t *usbos_info)
-{
-	urb_req_t *req;
-	int rxposted;
-	req = NULL;
-	BCM_REFERENCE(req);
-
-	ASSERT(usbos_info);
-
-#ifdef USB_TRIGGER_DEBUG
-	dbus_usbos_ctl_send_debugtrig(usbos_info);
-#endif /* USB_TRIGGER_DEBUG */
-	dbus_usbos_state_change(usbos_info, DBUS_STATE_DOWN);
-	DBUSTRACE(("%s: unlink all URBs\n", __FUNCTION__));
-	if (usbos_info->intr_urb)
-		USB_UNLINK_URB(usbos_info->intr_urb);
-
-	if (usbos_info->ctl_urb)
-		USB_UNLINK_URB(usbos_info->ctl_urb);
-
-	if (usbos_info->blk_urb)
-		USB_UNLINK_URB(usbos_info->blk_urb);
-
-	dbus_usbos_unlink(&usbos_info->req_txpostedq, &usbos_info->txposted_lock);
-	if (usbos_info->txposted > 0) {
-		DBUSERR(("%s ERROR: tx REQs posted=%d in stop!\n", __FUNCTION__,
-			usbos_info->txposted));
-	}
-	dbus_usbos_unlink(&usbos_info->req_rxpostedq, &usbos_info->rxposted_lock);
-
-#ifdef USBOS_THREAD
-	/* yield the CPU to rx packet thread */
-	while (1) {
-		if (atomic_read(&usbos_info->usbos_list_cnt) <= 0)	break;
-		wake_up_interruptible(&usbos_info->usbos_queue_head);
-		msleep(3);
-	}
-#endif /* USBOS_THREAD */
-
-	rxposted = atomic_read(&usbos_info->rxposted);
-	if (rxposted > 0) {
-		DBUSERR(("%s ERROR: rx REQs posted=%d in stop!\n", __FUNCTION__,
-			rxposted));
-	}
-
-	ASSERT(usbos_info->txposted == 0 && rxposted == 0);
-
-#ifdef DBUS_LINUX_RXDPC
-	/* Stop the dpc thread */
-	if (usbos_info->dpc_pid >= 0) {
-		KILL_PROC(usbos_info->dpc_pid, SIGTERM);
-		wait_for_completion(&usbos_info->dpc_exited);
-	}
-
-	/* Move pending reqs to free queue so they can be freed */
-	while ((req = dbus_usbos_qdeq(&usbos_info->req_rxpendingq,
-		&usbos_info->rxpending_lock)) != NULL) {
-		dbus_usbos_qenq(&usbos_info->req_rxfreeq, req,
-			&usbos_info->rxfree_lock);
-	}
-#endif /* DBUS_LINUX_RXDPC */
-}
-
-#ifdef KERNEL26
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) \
-	&& (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 11, 1))
-/**
- * Linux kernel sports a 'USB auto suspend' feature. See: http://lwn.net/Articles/373550/
- * The suspend method is called by the Linux kernel to warn the driver that the device is going to
- * be suspended.  If the driver returns a negative error code, the suspend will be aborted. If the
- * driver returns 0, it must cancel all outstanding URBs (usb_kill_urb()) and not submit any more.
- */
-static int
-dbus_usbos_suspend(struct usb_interface *intf,
-            pm_message_t message)
-{
-	DBUSERR(("%s suspend state: %d\n", __FUNCTION__, g_probe_info.suspend_state));
-	if (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) {
-		g_probe_info.suspend_state = USBOS_SUSPEND_STATE_SUSPENDED;
-		return 0;
-	}
-	else {
-		return -EBUSY;
-	}
-}
-
-/**
- * The resume method is called to tell the driver that the device has been resumed and the driver
- * can return to normal operation.  URBs may once more be submitted.
- */
-static int dbus_usbos_resume(struct usb_interface *intf)
-{
-	DBUSERR(("%s Device resumed\n", __FUNCTION__));
-	g_probe_info.suspend_state = USBOS_SUSPEND_STATE_DEVICE_ACTIVE;
-	return 0;
-}
-#endif /* ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) */
-
-/**
- * Called by Linux kernel at initialization time, kernel wants to know if our driver will accept the
- * caller supplied USB interface. Note that USB drivers are bound to interfaces, and not to USB
- * devices.
- */
-static int
-dbus_usbos_probe(struct usb_interface *intf, const struct usb_device_id *id)
-#else
-static void *
-dbus_usbos_probe(struct usb_device *usb, unsigned int ifnum, const struct usb_device_id *id)
-#endif /* KERNEL26 */
-{
-	int ep;
-	struct usb_endpoint_descriptor *endpoint;
-	int ret = 0;
-#ifdef KERNEL26
-	struct usb_device *usb = interface_to_usbdev(intf);
-#else
-	int claimed = 0;
-#endif
-	int num_of_eps;
-#ifdef BCMUSBDEV_COMPOSITE
-	int wlan_if = -1;
-	bool intr_ep = FALSE;
-#endif /* BCMUSBDEV_COMPOSITE */
-
-#ifdef BCMUSBDEV_COMPOSITE
-	wlan_if = dbus_usbos_intf_wlan(usb);
-#ifdef KERNEL26
-	if ((wlan_if >= 0) && (IFPTR(usb, wlan_if) == intf)) {
-#else
-	if (wlan_if == ifnum) {
-#endif /* KERNEL26 */
-#endif /* BCMUSBDEV_COMPOSITE */
-		g_probe_info.usb = usb;
-		g_probe_info.dldone = TRUE;
-#ifdef BCMUSBDEV_COMPOSITE
-	} else {
-		DBUSTRACE(("dbus_usbos_probe: skip probe for non WLAN interface\n"));
-		ret = BCME_UNSUPPORTED;
-		goto fail;
-	}
-#endif /* BCMUSBDEV_COMPOSITE */
-
-#ifdef KERNEL26
-	g_probe_info.intf = intf;
-#endif /* KERNEL26 */
-
-#ifdef BCMUSBDEV_COMPOSITE
-	if (IFDESC(usb, wlan_if).bInterfaceNumber > USB_COMPIF_MAX) {
-#else
-	if (IFDESC(usb, CONTROL_IF).bInterfaceNumber) {
-#endif /* BCMUSBDEV_COMPOSITE */
-		ret = -1;
-		goto fail;
-	}
-	if (id != NULL) {
-		g_probe_info.vid = id->idVendor;
-		g_probe_info.pid = id->idProduct;
-	}
-
-#ifdef KERNEL26
-	usb_set_intfdata(intf, &g_probe_info);
-#endif
-
-	/* Check that the device supports only one configuration */
-	if (usb->descriptor.bNumConfigurations != 1) {
-		ret = -1;
-		goto fail;
-	}
-
-	if (usb->descriptor.bDeviceClass != USB_CLASS_VENDOR_SPEC) {
-#ifdef BCMUSBDEV_COMPOSITE
-		if ((usb->descriptor.bDeviceClass != USB_CLASS_MISC) &&
-			(usb->descriptor.bDeviceClass != USB_CLASS_WIRELESS)) {
-#endif /* BCMUSBDEV_COMPOSITE */
-			ret = -1;
-			goto fail;
-#ifdef BCMUSBDEV_COMPOSITE
-		}
-#endif /* BCMUSBDEV_COMPOSITE */
-	}
-
-	/*
-	 * Only the BDC interface configuration is supported:
-	 *	Device class: USB_CLASS_VENDOR_SPEC
-	 *	if0 class: USB_CLASS_VENDOR_SPEC
-	 *	if0/ep0: control
-	 *	if0/ep1: bulk in
-	 *	if0/ep2: bulk out (ok if swapped with bulk in)
-	 */
-	if (CONFIGDESC(usb)->bNumInterfaces != 1) {
-#ifdef BCMUSBDEV_COMPOSITE
-		if (CONFIGDESC(usb)->bNumInterfaces > USB_COMPIF_MAX) {
-#endif /* BCMUSBDEV_COMPOSITE */
-			ret = -1;
-			goto fail;
-#ifdef BCMUSBDEV_COMPOSITE
-		}
-#endif /* BCMUSBDEV_COMPOSITE */
-	}
-
-	/* Check interface */
-#ifndef KERNEL26
-#ifdef BCMUSBDEV_COMPOSITE
-	if (usb_interface_claimed(IFPTR(usb, wlan_if))) {
-#else
-	if (usb_interface_claimed(IFPTR(usb, CONTROL_IF))) {
-#endif /* BCMUSBDEV_COMPOSITE */
-		ret = -1;
-		goto fail;
-	}
-#endif /* !KERNEL26 */
-
-#ifdef BCMUSBDEV_COMPOSITE
-	if ((IFDESC(usb, wlan_if).bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
-		IFDESC(usb, wlan_if).bInterfaceSubClass != 2 ||
-		IFDESC(usb, wlan_if).bInterfaceProtocol != 0xff) &&
-		(IFDESC(usb, wlan_if).bInterfaceClass != USB_CLASS_MISC ||
-		IFDESC(usb, wlan_if).bInterfaceSubClass != USB_SUBCLASS_COMMON ||
-		IFDESC(usb, wlan_if).bInterfaceProtocol != USB_PROTO_IAD)) {
-			DBUSERR(("%s: invalid control interface: class %d, subclass %d, proto %d\n",
-				__FUNCTION__,
-				IFDESC(usb, wlan_if).bInterfaceClass,
-				IFDESC(usb, wlan_if).bInterfaceSubClass,
-				IFDESC(usb, wlan_if).bInterfaceProtocol));
-#else
-	if (IFDESC(usb, CONTROL_IF).bInterfaceClass != USB_CLASS_VENDOR_SPEC ||
-		IFDESC(usb, CONTROL_IF).bInterfaceSubClass != 2 ||
-		IFDESC(usb, CONTROL_IF).bInterfaceProtocol != 0xff) {
-			DBUSERR(("%s: invalid control interface: class %d, subclass %d, proto %d\n",
-				__FUNCTION__,
-				IFDESC(usb, CONTROL_IF).bInterfaceClass,
-				IFDESC(usb, CONTROL_IF).bInterfaceSubClass,
-				IFDESC(usb, CONTROL_IF).bInterfaceProtocol));
-#endif /* BCMUSBDEV_COMPOSITE */
-			ret = -1;
-			goto fail;
-	}
-
-	/* Check control endpoint */
-#ifdef BCMUSBDEV_COMPOSITE
-	endpoint = &IFEPDESC(usb, wlan_if, 0);
-#else
-	endpoint = &IFEPDESC(usb, CONTROL_IF, 0);
-#endif /* BCMUSBDEV_COMPOSITE */
-	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT) {
-#ifdef BCMUSBDEV_COMPOSITE
-		if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
-			USB_ENDPOINT_XFER_BULK) {
-#endif /* BCMUSBDEV_COMPOSITE */
-			DBUSERR(("%s: invalid control endpoint %d\n",
-				__FUNCTION__, endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));
-			ret = -1;
-			goto fail;
-#ifdef BCMUSBDEV_COMPOSITE
-		}
-#endif /* BCMUSBDEV_COMPOSITE */
-	}
-
-#ifdef BCMUSBDEV_COMPOSITE
-	if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT) {
-#endif /* BCMUSBDEV_COMPOSITE */
-		g_probe_info.intr_pipe =
-			usb_rcvintpipe(usb, endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
-#ifdef BCMUSBDEV_COMPOSITE
-		intr_ep = TRUE;
-	}
-#endif /* BCMUSBDEV_COMPOSITE */
-
-#ifndef KERNEL26
-	/* Claim interface */
-#ifdef BCMUSBDEV_COMPOSITE
-	usb_driver_claim_interface(&dbus_usbdev, IFPTR(usb, wlan_if), &g_probe_info);
-#else
-	usb_driver_claim_interface(&dbus_usbdev, IFPTR(usb, CONTROL_IF), &g_probe_info);
-#endif /* BCMUSBDEV_COMPOSITE */
-	claimed = 1;
-#endif /* !KERNEL26 */
-	g_probe_info.rx_pipe = 0;
-	g_probe_info.rx_pipe2 = 0;
-	g_probe_info.tx_pipe = 0;
-#ifdef BCMUSBDEV_COMPOSITE
-	if (intr_ep)
-		ep = 1;
-	else
-		ep = 0;
-	num_of_eps = IFDESC(usb, wlan_if).bNumEndpoints - 1;
-#else
-	num_of_eps = IFDESC(usb, BULK_IF).bNumEndpoints - 1;
-#endif /* BCMUSBDEV_COMPOSITE */
-
-	if ((num_of_eps != 2) && (num_of_eps != 3)) {
-#ifdef BCMUSBDEV_COMPOSITE
-		if (num_of_eps > 7)
-#endif /* BCMUSBDEV_COMPOSITE */
-			ASSERT(0);
-	}
-	/* Check data endpoints and get pipes */
-#ifdef BCMUSBDEV_COMPOSITE
-	for (; ep <= num_of_eps; ep++) {
-		endpoint = &IFEPDESC(usb, wlan_if, ep);
-#else
-	for (ep = 1; ep <= num_of_eps; ep++) {
-		endpoint = &IFEPDESC(usb, BULK_IF, ep);
-#endif /* BCMUSBDEV_COMPOSITE */
-		if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
-		    USB_ENDPOINT_XFER_BULK) {
-			DBUSERR(("%s: invalid data endpoint %d\n",
-			           __FUNCTION__, ep));
-			ret = -1;
-			goto fail;
-		}
-
-		if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
-			if (!g_probe_info.rx_pipe) {
-				g_probe_info.rx_pipe = usb_rcvbulkpipe(usb,
-					(endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK));
-			} else {
-				g_probe_info.rx_pipe2 = usb_rcvbulkpipe(usb,
-					(endpoint->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK));
-			}
-
-		} else
-			g_probe_info.tx_pipe = usb_sndbulkpipe(usb, (endpoint->bEndpointAddress &
-			     USB_ENDPOINT_NUMBER_MASK));
-	}
-
-	/* Allocate interrupt URB and data buffer */
-	/* RNDIS says 8-byte intr, our old drivers used 4-byte */
-#ifdef BCMUSBDEV_COMPOSITE
-	g_probe_info.intr_size = (IFEPDESC(usb, wlan_if, 0).wMaxPacketSize == 16) ? 8 : 4;
-	g_probe_info.interval = IFEPDESC(usb, wlan_if, 0).bInterval;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21))
-	usb->quirks |= USB_QUIRK_NO_SET_INTF;
-#endif
-#else
-	g_probe_info.intr_size = (IFEPDESC(usb, CONTROL_IF, 0).wMaxPacketSize == 16) ? 8 : 4;
-	g_probe_info.interval = IFEPDESC(usb, CONTROL_IF, 0).bInterval;
-#endif /* BCMUSBDEV_COMPOSITE */
-
-#ifndef KERNEL26
-	/* usb_fill_int_urb does the interval decoding in 2.6 */
-	if (usb->speed == USB_SPEED_HIGH)
-		g_probe_info.interval = 1 << (g_probe_info.interval - 1);
-#endif
-	if (usb->speed == USB_SPEED_SUPER) {
-		g_probe_info.device_speed = SUPER_SPEED;
-		DBUSERR(("super speed device detected\n"));
-	} else if (usb->speed == USB_SPEED_HIGH) {
-		g_probe_info.device_speed = HIGH_SPEED;
-		DBUSERR(("high speed device detected\n"));
-	} else {
-		g_probe_info.device_speed = FULL_SPEED;
-		DBUSERR(("full speed device detected\n"));
-	}
-	if (g_probe_info.dereged == FALSE && probe_cb) {
-		disc_arg = probe_cb(probe_arg, "", USB_BUS, 0);
-	}
-
-	g_probe_info.disc_cb_done = FALSE;
-
-	/* Success */
-#ifdef KERNEL26
-	return DBUS_OK;
-#else
-	usb_inc_dev_use(usb);
-	return &g_probe_info;
-#endif
-
-fail:
-#ifdef BCMUSBDEV_COMPOSITE
-	if (ret != BCME_UNSUPPORTED)
-#endif /* BCMUSBDEV_COMPOSITE */
-		DBUSERR(("%s: failed with errno %d\n", __FUNCTION__, ret));
-#ifndef KERNEL26
-	if (claimed)
-#ifdef BCMUSBDEV_COMPOSITE
-		usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, wlan_if));
-#else
-		usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, CONTROL_IF));
-#endif /* BCMUSBDEV_COMPOSITE */
-#endif /* !KERNEL26 */
-
-#ifdef KERNEL26
-	usb_set_intfdata(intf, NULL);
-	return ret;
-#else
-	return NULL;
-#endif
-}
-
-/** Called by Linux kernel, is the counter part of dbus_usbos_probe() */
-#ifdef KERNEL26
-static void
-dbus_usbos_disconnect(struct usb_interface *intf)
-#else
-static void
-dbus_usbos_disconnect(struct usb_device *usb, void *ptr)
-#endif
-{
-#ifdef KERNEL26
-	struct usb_device *usb = interface_to_usbdev(intf);
-	probe_info_t *probe_usb_init_data = usb_get_intfdata(intf);
-#else
-	probe_info_t *probe_usb_init_data = (probe_info_t *) ptr;
-#endif
-	usbos_info_t *usbos_info;
-
-	if ((probe_usb_init_data == NULL) || (usb == NULL)) {
-		/* Should never happen */
-		ASSERT(0);
-		return;
-	}
-
-	usbos_info = (usbos_info_t *) probe_usb_init_data->usbos_info;
-	if (usbos_info) {
-		if ((probe_usb_init_data->dereged == FALSE) && disconnect_cb && disc_arg) {
-			disconnect_cb(disc_arg);
-			disc_arg = NULL;
-			probe_usb_init_data->disc_cb_done = TRUE;
-		}
-	}
-
-#ifndef KERNEL26
-#ifdef BCMUSBDEV_COMPOSITE
-	usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, wlan_if));
-#else
-	usb_driver_release_interface(&dbus_usbdev, IFPTR(usb, CONTROL_IF));
-#endif /* BCMUSBDEV_COMPOSITE */
-	usb_dec_dev_use(usb);
-#endif /* !KERNEL26 */
-}
-
-/** Higher layer (dbus_usb.c) wants to transmit an I/O Request Block */
-static int
-dbus_usbos_intf_send_irb(void *bus, dbus_irb_tx_t *txirb)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	urb_req_t *req;
-	int ret = DBUS_OK;
-	unsigned long flags;
-	void *pkt;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	if (!(req = dbus_usbos_qdeq(&usbos_info->req_txfreeq, &usbos_info->txfree_lock))) {
-		DBUSERR(("%s No free URB!\n", __FUNCTION__));
-		return DBUS_ERR_TXDROP;
-	}
-
-	spin_lock_irqsave(&usbos_info->txlock, flags);
-	req->arg = txirb;
-	req->usbinfo = usbos_info;
-
-	/* Prepare the URB */
-	if (txirb->buf) {
-		usb_fill_bulk_urb(req->urb, usbos_info->usb, usbos_info->tx_pipe, txirb->buf,
-			txirb->len, (usb_complete_t)dbus_usbos_send_complete, req);
-	} else if (txirb->pkt) {
-		uint32 len = 0, pktlen = 0;
-		void *transfer_buf;
-#ifdef WL_USB_ZLP_PAD
-		uint32	zlpflag = 0;
-#endif
-		len = pkttotlen(usbos_info->pub->osh, txirb->pkt);
-		/* check the length and change if not 4 bytes aligned. */
-		len	= ROUNDUP(len, sizeof(uint32));
-#ifdef WL_USB_ZLP_PAD
-		zlpflag = !(len % BCM_USB_HOST_TOTALLEN_ZLP);
-		/* the single packets which need ZLP are also processed here */
-		if (PKTNEXT(osbos_info->pub->osh, txirb->pkt) || zlpflag)
-#else
-		if (PKTNEXT(osbos_info->pub->osh, txirb->pkt))
-#endif
-		{
-
-#ifdef WL_USB_ZLP_PAD
-			if (zlpflag) {
-				/* create space for pad bytes */
-				len += BCM_USB_HOST_TOTALLEN_ZLP_PAD;
-			}
-#endif
-			transfer_buf = MALLOC(usbos_info->pub->osh, len);
-			if (!transfer_buf) {
-				ret = DBUS_ERR_TXDROP;
-				DBUSERR(("fail to alloc to usb buffer\n"));
-				goto fail;
-			}
-
-			pkt = txirb->pkt;
-			txirb->send_buf = transfer_buf;
-			req->buf_len = len;
-
-			while (pkt) {
-				pktlen = PKTLEN(usbos_info->pub->osh, pkt);
-				bcopy(PKTDATA(usbos_info->pub->osh, pkt), transfer_buf, pktlen);
-				transfer_buf += pktlen;
-				pkt = PKTNEXT(usbos_info->pub->osh, pkt);
-			}
-
-#ifdef WL_USB_ZLP_PAD
-			if (zlpflag) {
-				/* set the value of pad bytes to zero */
-				bzero(txirb->send_buf +(len - BCM_USB_HOST_TOTALLEN_ZLP_PAD),
-					BCM_USB_HOST_TOTALLEN_ZLP_PAD);
-			}
-#endif
-			usb_fill_bulk_urb(req->urb, usbos_info->usb, usbos_info->tx_pipe,
-				txirb->send_buf,
-				len,
-				(usb_complete_t)dbus_usbos_send_complete, req);
-
-		} else {
-			txirb->send_buf = NULL;
-			req->buf_len = 0;
-			len = PKTLEN(usbos_info->pub->osh, txirb->pkt);
-			len = ROUNDUP(len, sizeof(uint32));
-			usb_fill_bulk_urb(req->urb, usbos_info->usb, usbos_info->tx_pipe,
-				PKTDATA(usbos_info->pub->osh, txirb->pkt),
-				len,
-				(usb_complete_t)dbus_usbos_send_complete, req);
-		}
-	} else {
-		ASSERT(0);
-	}
-
-	req->urb->transfer_flags |= URB_QUEUE_BULK;
-
-	if ((ret = USB_SUBMIT_URB(req->urb))) {
-		dbus_usbos_qenq(&usbos_info->req_txfreeq, req, &usbos_info->txfree_lock);
-		if (txirb->send_buf) {
-			MFREE(usbos_info->pub->osh, txirb->send_buf, req->buf_len);
-			txirb->send_buf = NULL;
-			req->buf_len = 0;
-		}
-		ret = DBUS_ERR_TXDROP;
-		goto fail;
-	}
-
-	usbos_info->txposted++;
-
-	dbus_usbos_qenq(&usbos_info->req_txpostedq, req, &usbos_info->txposted_lock);
-fail:
-	spin_unlock_irqrestore(&usbos_info->txlock, flags);
-	return ret;
-}
-
-/** Higher layer (dbus_usb.c) recycles a received (and used) packet. */
-static int
-dbus_usbos_intf_recv_irb(void *bus, dbus_irb_rx_t *rxirb)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	int ret = DBUS_OK;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	ret = dbus_usbos_recv_urb_submit(usbos_info, rxirb, 0);
-	return ret;
-}
-
-static int
-dbus_usbos_intf_recv_irb_from_ep(void *bus, dbus_irb_rx_t *rxirb, uint32 ep_idx)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	int ret = DBUS_OK;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	ret = dbus_usbos_recv_urb_submit(usbos_info, rxirb, ep_idx);
-	return ret;
-}
-
-/** Higher layer (dbus_usb.c) want to cancel an IRB */
-static int
-dbus_usbos_intf_cancel_irb(void *bus, dbus_irb_tx_t *txirb)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	return DBUS_ERR;
-}
-
-static int
-dbus_usbos_intf_send_ctl(void *bus, uint8 *buf, int len)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	int ret = DBUS_OK;
-	uint16 size;
-
-	if ((usbos_info == NULL) || (buf == NULL) || (len == 0))
-		return DBUS_ERR;
-
-	if (usbos_info->ctl_urb == NULL)
-		return DBUS_ERR;
-
-	size = len;
-	usbos_info->ctl_write.wLength = cpu_to_le16p(&size);
-	usbos_info->ctl_urb->transfer_buffer_length = size;
-
-	usb_fill_control_urb(usbos_info->ctl_urb,
-		usbos_info->usb,
-		usbos_info->ctl_out_pipe,
-		(unsigned char *) &usbos_info->ctl_write,
-		buf, size, (usb_complete_t)dbus_usbos_ctlwrite_complete, usbos_info);
-
-	ret = USB_SUBMIT_URB(usbos_info->ctl_urb);
-	if (ret < 0) {
-		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, ret));
-		return DBUS_ERR_TXCTLFAIL;
-	}
-
-	return DBUS_OK;
-}
-
-/** This function does not seem to be called by anyone, including dbus_usb.c */
-static int
-dbus_usbos_intf_recv_ctl(void *bus, uint8 *buf, int len)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	int ret = DBUS_OK;
-	uint16 size;
-#ifdef USBOS_THREAD
-	unsigned long flags;
-#endif /* USBOS_THREAD */
-
-	if ((usbos_info == NULL) || (buf == NULL) || (len == 0))
-		return DBUS_ERR;
-
-	if (usbos_info->ctl_urb == NULL)
-		return DBUS_ERR;
-
-#ifdef USBOS_THREAD
-	spin_lock_irqsave(&usbos_info->ctrl_lock, flags);
-#endif
-	size = len;
-	usbos_info->ctl_read.wLength = cpu_to_le16p(&size);
-	usbos_info->ctl_urb->transfer_buffer_length = size;
-
-	if (usbos_info->rxctl_deferrespok) {
-		/* BMAC model */
-		usbos_info->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_VENDOR |
-			USB_RECIP_INTERFACE;
-		usbos_info->ctl_read.bRequest = DL_DEFER_RESP_OK;
-	} else {
-		/* full dongle model */
-		usbos_info->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_CLASS |
-			USB_RECIP_INTERFACE;
-		usbos_info->ctl_read.bRequest = 1;
-	}
-
-	usb_fill_control_urb(usbos_info->ctl_urb,
-		usbos_info->usb,
-		usbos_info->ctl_in_pipe,
-		(unsigned char *) &usbos_info->ctl_read,
-		buf, size, (usb_complete_t)dbus_usbos_ctlread_complete, usbos_info);
-
-	ret = USB_SUBMIT_URB(usbos_info->ctl_urb);
-#ifdef USBOS_THREAD
-	spin_unlock_irqrestore(&usbos_info->ctrl_lock, flags);
-#endif
-	if (ret < 0) {
-		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, ret));
-		return DBUS_ERR_RXCTLFAIL;
-	}
-
-	return ret;
-}
-
-static int
-dbus_usbos_intf_get_attrib(void *bus, dbus_attrib_t *attrib)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-
-	if ((usbos_info == NULL) || (attrib == NULL))
-		return DBUS_ERR;
-
-	attrib->bustype = DBUS_USB;
-	attrib->vid = g_probe_info.vid;
-	attrib->pid = g_probe_info.pid;
-	attrib->devid = 0x4322;
-
-	attrib->nchan = 1;
-
-	/* MaxPacketSize for USB hi-speed bulk out is 512 bytes
-	 * and 64-bytes for full-speed.
-	 * When sending pkt > MaxPacketSize, Host SW breaks it
-	 * up into multiple packets.
-	 */
-	attrib->mtu = usbos_info->maxps;
-
-	return DBUS_OK;
-}
-
-/** Called by higher layer (dbus_usb.c) when it wants to 'up' the USB interface to the dongle */
-static int
-dbus_usbos_intf_up(void *bus)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	uint16 ifnum;
-#ifdef BCMUSBDEV_COMPOSITE
-	int wlan_if = 0;
-#endif
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	if (usbos_info->usb == NULL)
-		return DBUS_ERR;
-
-#if (defined(WLC_HIGH) && defined(WLC_LOW))
-	/* full dongle use intr EP, bmac doesn't use it */
-	if (usbos_info->intr_urb) {
-		int ret;
-
-		usb_fill_int_urb(usbos_info->intr_urb, usbos_info->usb,
-			usbos_info->intr_pipe, &usbos_info->intr,
-			usbos_info->intr_size, (usb_complete_t)dbus_usbos_intr_complete,
-			usbos_info, usbos_info->interval);
-
-		if ((ret = USB_SUBMIT_URB(usbos_info->intr_urb))) {
-			DBUSERR(("%s USB_SUBMIT_URB failed with status %d\n", __FUNCTION__, ret));
-			return DBUS_ERR;
-		}
-	}
-#endif	/* (defined(WLC_HIGH) && defined(WLC_LOW)) */
-
-	if (usbos_info->ctl_urb) {
-		usbos_info->ctl_in_pipe = usb_rcvctrlpipe(usbos_info->usb, 0);
-		usbos_info->ctl_out_pipe = usb_sndctrlpipe(usbos_info->usb, 0);
-
-#ifdef BCMUSBDEV_COMPOSITE
-		wlan_if = dbus_usbos_intf_wlan(usbos_info->usb);
-		ifnum = cpu_to_le16(IFDESC(usbos_info->usb, wlan_if).bInterfaceNumber);
-#else
-		ifnum = cpu_to_le16(IFDESC(usbos_info->usb, CONTROL_IF).bInterfaceNumber);
-#endif /* BCMUSBDEV_COMPOSITE */
-		/* CTL Write */
-		usbos_info->ctl_write.bRequestType =
-			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
-		usbos_info->ctl_write.bRequest = 0;
-		usbos_info->ctl_write.wValue = cpu_to_le16(0);
-		usbos_info->ctl_write.wIndex = cpu_to_le16p(&ifnum);
-
-		/* CTL Read */
-		usbos_info->ctl_read.bRequestType =
-			USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
-		usbos_info->ctl_read.bRequest = 1;
-		usbos_info->ctl_read.wValue = cpu_to_le16(0);
-		usbos_info->ctl_read.wIndex = cpu_to_le16p(&ifnum);
-	}
-
-	/* Success, indicate usbos_info is fully up */
-	dbus_usbos_state_change(usbos_info, DBUS_STATE_UP);
-
-	return DBUS_OK;
-}
-
-static int
-dbus_usbos_intf_down(void *bus)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	dbusos_stop(usbos_info);
-	return DBUS_OK;
-}
-
-static int
-dbus_usbos_intf_stop(void *bus)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	dbusos_stop(usbos_info);
-	return DBUS_OK;
-}
-
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-static void
-dbus_usbos_intf_dump(void *bus, struct bcmstrbuf *b)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	int i = 0, j = 0, rxposted;
-
-	rxposted = atomic_read(&usbos_info->rxposted);
-	if (b) {
-		bcm_bprintf(b, "\ndbus linux dump\n");
-		bcm_bprintf(b, "txposted %d rxposted %d\n",
-			usbos_info->txposted, rxposted);
-
-		bcm_bprintf(b, "RXDPC: dpc_cnt %d dpc_pktcnt %d dpc_maxpktcnt %d avg_dpc_pktcnt\n",
-			usbos_info->dpc_cnt, usbos_info->dpc_pktcnt,
-			usbos_info->dpc_maxpktcnt, usbos_info->dpc_cnt ?
-			(usbos_info->dpc_pktcnt/usbos_info->dpc_cnt):1);
-
-		/* Histogram */
-		bcm_bprintf(b, "txposted\n");
-	} else {
-		printf("\ndbus linux dump\n");
-		printf("txposted %d rxposted %d\n",
-			usbos_info->txposted, rxposted);
-		printf("RXDPC: dpc_cnt %d dpc_pktcnt %d dpc_maxpktcnt %d avg_dpc_pktcnt %d\n",
-			usbos_info->dpc_cnt, usbos_info->dpc_pktcnt,
-			usbos_info->dpc_maxpktcnt, usbos_info->dpc_cnt ?
-			(usbos_info->dpc_pktcnt/usbos_info->dpc_cnt):1);
-
-		/* Histogram */
-		printf("txposted\n");
-	}
-
-	for (i = 0; i < usbos_info->pub->ntxq; i++) {
-		if (usbos_info->txposted_hist == NULL) {
-			break;
-		}
-		if (usbos_info->txposted_hist[i]) {
-			if (b)
-				bcm_bprintf(b, "%d: %d ", i, usbos_info->txposted_hist[i]);
-			else
-				printf("%d: %d ", i, usbos_info->txposted_hist[i]);
-			j++;
-			if (j % 10 == 0) {
-				if (b)
-					bcm_bprintf(b, "\n");
-				else
-					printf("\n");
-			}
-		}
-	}
-
-	j = 0;
-	if (b)
-		bcm_bprintf(b, "\nrxposted\n");
-	else
-		printf("\nrxposted\n");
-	for (i = 0; i < usbos_info->pub->nrxq; i++) {
-		if (usbos_info->rxposted_hist == NULL) {
-			break;
-		}
-		if (usbos_info->rxposted_hist[i]) {
-			if (b)
-				bcm_bprintf(b, "%d: %d ", i, usbos_info->rxposted_hist[i]);
-			else
-				printf("%d: %d ", i, usbos_info->rxposted_hist[i]);
-			j++;
-			if (j % 10 == 0) {
-				if (b)
-					bcm_bprintf(b, "\n");
-				else
-					printf("\n");
-			}
-		}
-	}
-	if (b)
-		bcm_bprintf(b, "\n");
-	else
-		printf("\n");
-
-	return;
-}
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-
-/** Called by higher layer (dbus_usb.c) */
-static int
-dbus_usbos_intf_set_config(void *bus, dbus_config_t *config)
-{
-	int err = DBUS_ERR;
-	usbos_info_t* usbos_info = bus;
-
-	if (config->config_id == DBUS_CONFIG_ID_RXCTL_DEFERRES) {
-		usbos_info->rxctl_deferrespok = config->rxctl_deferrespok;
-		err = DBUS_OK;
-	} else if (config->config_id == DBUS_CONFIG_ID_TXRXQUEUE) {
-		/* DBUS_CONFIG_ID_TXRXQUEUE shouldn't be called after probe stage */
-		ASSERT(disc_arg == NULL);
-		ASSERT(config->txrxqueue.maxrxq > 0);
-		ASSERT(config->txrxqueue.rxbufsize > 0);
-		if (config->txrxqueue.rxbufsize != usbos_info->rxbuf_len) {
-			int freed;
-			int state = usbos_info->pub->busstate;
-
-			dbus_usbos_unlink(&usbos_info->req_rxpostedq, &usbos_info->rxposted_lock);
-			while (atomic_read(&usbos_info->rxposted)) {
-				DBUSTRACE(("%s rxposted is %d, delay 1 ms\n", __FUNCTION__,
-					atomic_read(&usbos_info->rxposted)));
-				dbus_usbos_wait(usbos_info, 1);
-			}
-
-			freed = dbus_usbos_urbreqs_free(usbos_info, TRUE);
-			ASSERT(freed == atomic_read(&usbos_info->rxallocated));
-			BCM_REFERENCE(freed);
-			atomic_set(&usbos_info->rxallocated, 0);
-			usbos_info->rxbuf_len = config->txrxqueue.rxbufsize;
-			if (DBUS_OK != dbus_usbos_urbreqs_alloc(usbos_info,
-#ifdef CTFPOOL
-				usbos_info->pub->nrxq,
-#else
-				MIN(DBUS_USB_RXQUEUE_BATCH_ADD, usbos_info->pub->nrxq),
-#endif
-				TRUE)) {
-				goto fail;
-			}
-			dbus_usbos_state_change(usbos_info, state);
-		}
-
-		err = DBUS_OK;
-	}
-
-fail:
-	return err;
-}
-
-/**
- * In some cases, the code must submit an URB and wait for its completion.
- * Related: dbus_usbos_sync_complete()
- */
-static int
-dbus_usbos_sync_wait(usbos_info_t *usbinfo, uint16 time)
-{
-	int ret;
-	int err = DBUS_OK;
-	int ms = time;
-
-	ret = wait_event_interruptible_timeout(usbinfo->wait,
-		usbinfo->waitdone == TRUE, (ms * HZ / 1000));
-
-	if ((usbinfo->waitdone == FALSE) || (usbinfo->sync_urb_status)) {
-		DBUSERR(("%s: timeout(%d) or urb err=0x%x\n",
-			__FUNCTION__, ret, usbinfo->sync_urb_status));
-		err = DBUS_ERR;
-		BCM_REFERENCE(ret);
-	}
-	usbinfo->waitdone = FALSE;
-	return err;
-}
-
-/**
- * In some cases, the code must submit an URB and wait for its completion.
- * Related: dbus_usbos_sync_wait()
- */
-static void
-dbus_usbos_sync_complete(CALLBACK_ARGS)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *)urb->context;
-
-	usbos_info->waitdone = TRUE;
-	wake_up_interruptible(&usbos_info->wait);
-
-	usbos_info->sync_urb_status = urb->status;
-
-	if (urb->status) {
-		DBUSERR(("%s: sync urb error %d\n", __FUNCTION__, urb->status));
-	}
-}
-
-/** Called by dbus_usb.c when it wants to download firmware into the dongle */
-bool
-dbus_usbos_dl_cmd(usbos_info_t *usbinfo, uint8 cmd, void *buffer, int buflen)
-{
-	int ret = DBUS_OK;
-	char *tmpbuf;
-	uint16 size;
-
-	if ((usbinfo == NULL) || (buffer == NULL) || (buflen == 0))
-		return FALSE;
-
-	if (usbinfo->ctl_urb == NULL)
-		return FALSE;
-
-	tmpbuf = (char *) MALLOC(usbinfo->pub->osh, buflen);
-	if (!tmpbuf) {
-		DBUSERR(("%s: Unable to allocate memory \n", __FUNCTION__));
-		return FALSE;
-	}
-
-	size = buflen;
-	usbinfo->ctl_urb->transfer_buffer_length = size;
-
-	usbinfo->ctl_read.wLength = cpu_to_le16p(&size);
-	usbinfo->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_VENDOR |
-		USB_RECIP_INTERFACE;
-	usbinfo->ctl_read.bRequest = cmd;
-
-	if (cmd == DL_GO) {
-		usbinfo->ctl_read.wIndex = 1;
-	}
-
-	usb_fill_control_urb(usbinfo->ctl_urb,
-		usbinfo->usb,
-		usb_rcvctrlpipe(usbinfo->usb, 0),
-		(unsigned char *) &usbinfo->ctl_read,
-		(void *) tmpbuf, size, (usb_complete_t)dbus_usbos_sync_complete, usbinfo);
-
-	ret = USB_SUBMIT_URB(usbinfo->ctl_urb);
-	if (ret < 0) {
-		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, ret));
-		MFREE(usbinfo->pub->osh, tmpbuf, buflen);
-		return FALSE;
-	}
-
-	ret = dbus_usbos_sync_wait(usbinfo, USB_SYNC_WAIT_TIMEOUT);
-	memcpy(buffer, tmpbuf, buflen);
-	MFREE(usbinfo->pub->osh, tmpbuf, buflen);
-
-	return (ret == DBUS_OK);
-}
-
-/**
- * Called by dbus_usb.c when it wants to download a buffer into the dongle (e.g. as part of the
- * download process, when writing nvram variables).
- */
-int
-dbus_write_membytes(usbos_info_t* usbinfo, bool set, uint32 address, uint8 *data, uint size)
-{
-	hwacc_t hwacc;
-	int write_bytes = 4;
-	int status;
-	int retval = 0;
-
-	DBUSTRACE(("Enter:%s\n", __FUNCTION__));
-
-	/* Read is not supported */
-	if (set == 0) {
-		DBUSERR(("Currently read is not supported!!\n"));
-		return -1;
-	}
-
-	hwacc.cmd = DL_CMD_WRHW;
-	hwacc.addr = address;
-
-	DBUSTRACE(("Address:%x size:%d", hwacc.addr, size));
-	do {
-		if (size >= 4) {
-			write_bytes = 4;
-		} else if (size >= 2) {
-			write_bytes = 2;
-		} else {
-			write_bytes = 1;
-		}
-
-		hwacc.len = write_bytes;
-
-		while (size >= write_bytes) {
-			hwacc.data = *((unsigned int*)data);
-
-			status = USB_CONTROL_MSG(usbinfo->usb, usb_sndctrlpipe(usbinfo->usb, 0),
-				DL_WRHW, (USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE),
-				1, 0, (char *)&hwacc, sizeof(hwacc_t), USB_CTRL_EP_TIMEOUT);
-
-			if (status < 0) {
-				retval = -1;
-				DBUSERR((" Ctrl write hwacc failed w/status %d @ address:%x \n",
-					status, hwacc.addr));
-				goto err;
-			}
-
-			hwacc.addr += write_bytes;
-			data += write_bytes;
-			size -= write_bytes;
-		}
-	} while (size > 0);
-
-err:
-	return retval;
-}
-
-
-static int
-dbus_usbos_readreg(void *bus, uint32 regaddr, int datalen, uint32 *value)
-{
-	usbos_info_t *usbinfo = (usbos_info_t *) bus;
-	int ret = DBUS_ERR;
-	uint32 cmd;
-	hwacc_t	hwacc;
-	uint16 size = sizeof(hwacc_t);
-
-	if (datalen == 1)
-		cmd = DL_RDHW8;
-	else if (datalen == 2)
-		cmd = DL_RDHW16;
-	else
-		cmd = DL_RDHW32;
-
-	if (usbinfo == NULL)
-		return ret;
-
-	if (usbinfo->ctl_urb == NULL)
-		return ret;
-
-	usbinfo->ctl_urb->transfer_buffer_length = size;
-
-	usbinfo->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_VENDOR |
-		USB_RECIP_INTERFACE;
-	usbinfo->ctl_read.bRequest = cmd;
-	usbinfo->ctl_read.wLength = htol16(size);
-	usbinfo->ctl_read.wValue = htol16(regaddr & 0xFFFF);
-	usbinfo->ctl_read.wIndex = htol16(regaddr >> 16);
-
-
-	usb_fill_control_urb(usbinfo->ctl_urb,
-		usbinfo->usb,
-		usb_rcvctrlpipe(usbinfo->usb, 0),
-		(unsigned char *) &usbinfo->ctl_read,
-		(void *) &hwacc, size, (usb_complete_t)dbus_usbos_sync_complete, usbinfo);
-
-	ret = USB_SUBMIT_URB(usbinfo->ctl_urb);
-	if (ret < 0) {
-		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, ret));
-		return ret;
-	}
-
-	ret = dbus_usbos_sync_wait(usbinfo, USB_SYNC_WAIT_TIMEOUT);
-
-	if (ret == DBUS_OK) {
-		*value = hwacc.data;
-		return ret;
-	}
-	return ret;
-}
-
-int
-dbus_usbos_writereg(void *bus, uint32 regaddr, int datalen, uint32 data)
-{
-	usbos_info_t *usbinfo = (usbos_info_t *) bus;
-	int ret = DBUS_ERR;
-	uint32 cmd = DL_WRHW;
-	hwacc_t	hwacc;
-	uint16 size = sizeof(hwacc_t);
-
-	if (usbinfo == NULL)
-		return ret;
-
-	if (usbinfo->ctl_urb == NULL)
-		return ret;
-
-	hwacc.cmd = DL_WRHW;
-	hwacc.addr = regaddr;
-	hwacc.data = data;
-	hwacc.len = datalen;
-
-	usbinfo->ctl_urb->transfer_buffer_length = size;
-
-	usbinfo->ctl_write.bRequestType = USB_DIR_OUT| USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
-	usbinfo->ctl_write.bRequest = cmd;
-	usbinfo->ctl_write.wLength = htol16(size);
-	usbinfo->ctl_write.wValue = htol16(1);
-	usbinfo->ctl_write.wIndex = htol16(0);
-
-	usb_fill_control_urb(usbinfo->ctl_urb,
-		usbinfo->usb,
-		usb_sndctrlpipe(usbinfo->usb, 0),
-		(unsigned char *) &usbinfo->ctl_write,
-		(void *) &hwacc, size, (usb_complete_t)dbus_usbos_sync_complete, usbinfo);
-
-	ret = USB_SUBMIT_URB(usbinfo->ctl_urb);
-	if (ret < 0) {
-		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, ret));
-		return ret;
-	}
-
-	ret = dbus_usbos_sync_wait(usbinfo, USB_SYNC_WAIT_TIMEOUT);
-
-	return ret;
-}
-
-int
-dbus_usbos_wait(usbos_info_t *usbinfo, uint16 ms)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
-	if (in_interrupt())
-		mdelay(ms);
-	else
-		msleep_interruptible(ms);
-#else
-	wait_ms(ms);
-#endif
-	return DBUS_OK;
-}
-
-/** Called by dbus_usb.c as part of the firmware download process */
-bool
-dbus_usbos_dl_send_bulk(usbos_info_t *usbinfo, void *buffer, int len)
-{
-	int ret = DBUS_OK;
-
-#ifdef EHCI_FASTPATH_TX
-	struct ehci_qtd *qtd = optimize_ehci_qtd_alloc(GFP_KERNEL);
-	int token = EHCI_QTD_SET_CERR(3);
-
-	if (qtd == NULL)
-		goto fail;
-
-	optimize_qtd_fill_with_data(usbinfo->pub, 0, qtd, buffer, token, len);
-	optimize_submit_async(qtd, 0);
-#else
-	if (usbinfo == NULL)
-		goto fail;
-
-	if (usbinfo->blk_urb == NULL)
-		goto fail;
-
-	/* Prepare the URB */
-	usb_fill_bulk_urb(usbinfo->blk_urb, usbinfo->usb, usbinfo->tx_pipe, buffer,
-		len, (usb_complete_t)dbus_usbos_sync_complete, usbinfo);
-
-	usbinfo->blk_urb->transfer_flags |= URB_QUEUE_BULK;
-
-	if ((ret = USB_SUBMIT_URB(usbinfo->blk_urb))) {
-		DBUSERR(("%s: usb_submit_urb failed %d\n", __FUNCTION__, ret));
-		goto fail;
-	}
-#endif /* EHCI_FASTPATH_TX */
-
-	ret = dbus_usbos_sync_wait(usbinfo, USB_SYNC_WAIT_TIMEOUT);
-
-	return (ret == DBUS_OK);
-fail:
-	return FALSE;
-}
-
-static bool
-dbus_usbos_intf_recv_needed(void *bus)
-{
-	return FALSE;
-}
-
-/**
- * Higher layer (dbus_usb.c) wants to execute a function on the condition that the rx spin lock has
- * been acquired.
- */
-static void*
-dbus_usbos_intf_exec_rxlock(void *bus, exec_cb_t cb, struct exec_parms *args)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	void *ret;
-	unsigned long flags;
-
-	if (usbos_info == NULL)
-		return NULL;
-
-	spin_lock_irqsave(&usbos_info->rxlock, flags);
-	ret = cb(args);
-	spin_unlock_irqrestore(&usbos_info->rxlock, flags);
-
-	return ret;
-}
-
-static void*
-dbus_usbos_intf_exec_txlock(void *bus, exec_cb_t cb, struct exec_parms *args)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	void *ret;
-	unsigned long flags;
-
-	if (usbos_info == NULL)
-		return NULL;
-
-	spin_lock_irqsave(&usbos_info->txlock, flags);
-	ret = cb(args);
-	spin_unlock_irqrestore(&usbos_info->txlock, flags);
-
-	return ret;
-}
-
-/**
- * if an error condition was detected in this module, the higher DBUS layer (dbus_usb.c) has to
- * be notified.
- */
-static int
-dbus_usbos_errhandler(void *bus, int err)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	if (usbos_info->cbarg && usbos_info->cbs) {
-		if (usbos_info->cbs->errhandler)
-			usbos_info->cbs->errhandler(usbos_info->cbarg, err);
-	}
-
-	return DBUS_OK;
-}
-
-/**
- * if a change in bus state was detected in this module, the higher DBUS layer (dbus_usb.c) has to
- * be notified.
- */
-static int
-dbus_usbos_state_change(void *bus, int state)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-
-	if (usbos_info->cbarg && usbos_info->cbs) {
-		if (usbos_info->cbs->state_change)
-			usbos_info->cbs->state_change(usbos_info->cbarg, state);
-	}
-
-	usbos_info->pub->busstate = state;
-	return DBUS_OK;
-}
-
-int
-dbus_bus_osl_register(int vid, int pid, probe_cb_t prcb,
-	disconnect_cb_t discb, void *prarg, dbus_intf_t **intf, void *param1, void *param2)
-{
-	bzero(&g_probe_info, sizeof(probe_info_t));
-
-	probe_cb = prcb;
-	disconnect_cb = discb;
-	probe_arg = prarg;
-
-	devid_table[0].idVendor = vid;
-	devid_table[0].idProduct = pid;
-
-	*intf = &dbus_usbos_intf;
-
-	USB_REGISTER();
-
-	return DBUS_ERR_NODEVICE;
-}
-
-int
-dbus_bus_osl_deregister()
-{
-	g_probe_info.dereged = TRUE;
-
-	if (disconnect_cb && disc_arg && (g_probe_info.disc_cb_done == FALSE)) {
-		disconnect_cb(disc_arg);
-		disc_arg = NULL;
-	}
-
-	USB_DEREGISTER();
-
-	return DBUS_OK;
-}
-
-
-void *
-dbus_usbos_intf_attach(dbus_pub_t *pub, void *cbarg, dbus_intf_callbacks_t *cbs)
-{
-	usbos_info_t *usbos_info;
-
-	if (g_probe_info.dldone == FALSE) {
-		DBUSERR(("%s: err device not downloaded!\n", __FUNCTION__));
-		return NULL;
-	}
-
-	/* Sanity check for BUS_INFO() */
-	ASSERT(OFFSETOF(usbos_info_t, pub) == 0);
-
-	usbos_info = MALLOC(pub->osh, sizeof(usbos_info_t));
-	if (usbos_info == NULL)
-		return NULL;
-
-	bzero(usbos_info, sizeof(usbos_info_t));
-
-	usbos_info->pub = pub;
-	usbos_info->cbarg = cbarg;
-	usbos_info->cbs = cbs;
-
-	/* Needed for disconnect() */
-	g_probe_info.usbos_info = usbos_info;
-
-	/* Update USB Info */
-	usbos_info->usb = g_probe_info.usb;
-	usbos_info->rx_pipe = g_probe_info.rx_pipe;
-	usbos_info->rx_pipe2 = g_probe_info.rx_pipe2;
-	usbos_info->tx_pipe = g_probe_info.tx_pipe;
-	usbos_info->intr_pipe = g_probe_info.intr_pipe;
-	usbos_info->intr_size = g_probe_info.intr_size;
-	usbos_info->interval = g_probe_info.interval;
-	usbos_info->pub->device_speed = g_probe_info.device_speed;
-	if (usbos_info->rx_pipe2) {
-		usbos_info->pub->attrib.has_2nd_bulk_in_ep = 1;
-	} else {
-		usbos_info->pub->attrib.has_2nd_bulk_in_ep = 0;
-	}
-
-	if (usbos_info->tx_pipe)
-		usbos_info->maxps = usb_maxpacket(usbos_info->usb,
-			usbos_info->tx_pipe, usb_pipeout(usbos_info->tx_pipe));
-
-	INIT_LIST_HEAD(&usbos_info->req_rxfreeq);
-	INIT_LIST_HEAD(&usbos_info->req_txfreeq);
-	INIT_LIST_HEAD(&usbos_info->req_rxpostedq);
-	INIT_LIST_HEAD(&usbos_info->req_txpostedq);
-	spin_lock_init(&usbos_info->rxfree_lock);
-	spin_lock_init(&usbos_info->txfree_lock);
-	spin_lock_init(&usbos_info->rxposted_lock);
-	spin_lock_init(&usbos_info->txposted_lock);
-	spin_lock_init(&usbos_info->rxlock);
-	spin_lock_init(&usbos_info->txlock);
-
-	atomic_set(&usbos_info->rxposted, 0);
-
-#ifdef DBUS_LINUX_RXDPC
-	INIT_LIST_HEAD(&usbos_info->req_rxpendingq);
-	spin_lock_init(&usbos_info->rxpending_lock);
-#endif /* DBUS_LINUX_RXDPC */
-
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	usbos_info->txposted_hist = MALLOC(pub->osh, (usbos_info->pub->ntxq+1) * sizeof(int));
-	if (usbos_info->txposted_hist) {
-		bzero(usbos_info->txposted_hist, (usbos_info->pub->ntxq+1) * sizeof(int));
-	}
-	usbos_info->rxposted_hist = MALLOC(pub->osh, (usbos_info->pub->nrxq+1) * sizeof(int));
-	if (usbos_info->rxposted_hist) {
-		bzero(usbos_info->rxposted_hist, (usbos_info->pub->nrxq+1) * sizeof(int));
-	}
-#endif
-#ifdef USB_DISABLE_INT_EP
-	usbos_info->intr_urb = NULL;
-#else
-	if (!(usbos_info->intr_urb = USB_ALLOC_URB())) {
-		DBUSERR(("%s: usb_alloc_urb (tx) failed\n", __FUNCTION__));
-		goto fail;
-	}
-#endif
-
-	if (!(usbos_info->ctl_urb = USB_ALLOC_URB())) {
-		DBUSERR(("%s: usb_alloc_urb (tx) failed\n", __FUNCTION__));
-		goto fail;
-	}
-
-	init_waitqueue_head(&usbos_info->wait);
-
-	if (!(usbos_info->blk_urb = USB_ALLOC_URB())) {	/* for embedded image downloading */
-		DBUSERR(("%s: usb_alloc_urb (tx) failed\n", __FUNCTION__));
-		goto fail;
-	}
-
-	usbos_info->rxbuf_len = (uint)usbos_info->pub->rxsize;
-
-
-#ifdef DBUS_LINUX_RXDPC		/* Initialize DPC thread */
-	sema_init(&usbos_info->dpc_sem, 0);
-	init_completion(&usbos_info->dpc_exited);
-	usbos_info->dpc_pid = kernel_thread(dbus_usbos_dpc_thread, usbos_info, 0);
-	if (usbos_info->dpc_pid < 0) {
-		DBUSERR(("%s: failed to create dpc thread\n", __FUNCTION__));
-		goto fail;
-	}
-#endif /* DBUS_LINUX_RXDPC */
-
-	atomic_set(&usbos_info->txallocated, 0);
-	if (DBUS_OK != dbus_usbos_urbreqs_alloc(usbos_info,
-		usbos_info->pub->ntxq, FALSE)) {
-		goto fail;
-	}
-
-	atomic_set(&usbos_info->rxallocated, 0);
-	if (DBUS_OK != dbus_usbos_urbreqs_alloc(usbos_info,
-#ifdef CTFPOOL
-		usbos_info->pub->nrxq,
-#else
-		MIN(DBUS_USB_RXQUEUE_BATCH_ADD, usbos_info->pub->nrxq),
-#endif
-		TRUE)) {
-		goto fail;
-	}
-
-#ifdef USBOS_THREAD
-	if (dbus_usbos_thread_init(usbos_info) == NULL)
-		goto fail;
-#endif /* USBOS_THREAD */
-
-	pub->dev_info = g_probe_info.usb;
-
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-	spin_lock_init(&usbos_info->fastpath_lock);
-	if (optimize_init(usbos_info, usbos_info->usb, usbos_info->tx_pipe,
-		usbos_info->rx_pipe, usbos_info->rx_pipe2) != 0) {
-		DBUSERR(("%s: optimize_init failed!\n", __FUNCTION__));
-		goto fail;
-	}
-
-#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
-
-	return (void *) usbos_info;
-fail:
-#ifdef DBUS_LINUX_RXDPC
-	if (usbos_info->dpc_pid >= 0) {
-		KILL_PROC(usbos_info->dpc_pid, SIGTERM);
-		wait_for_completion(&usbos_info->dpc_exited);
-	}
-#endif /* DBUS_LINUX_RXDPC */
-	if (usbos_info->intr_urb) {
-		USB_FREE_URB(usbos_info->intr_urb);
-		usbos_info->intr_urb = NULL;
-	}
-
-	if (usbos_info->ctl_urb) {
-		USB_FREE_URB(usbos_info->ctl_urb);
-		usbos_info->ctl_urb = NULL;
-	}
-
-#if defined(BCM_DNGL_EMBEDIMAGE) || defined(BCM_REQUEST_FW)
-	if (usbos_info->blk_urb) {
-		USB_FREE_URB(usbos_info->blk_urb);
-		usbos_info->blk_urb = NULL;
-	}
-#endif
-
-	dbus_usbos_urbreqs_free(usbos_info, TRUE);
-	atomic_set(&usbos_info->rxallocated, 0);
-	dbus_usbos_urbreqs_free(usbos_info, FALSE);
-	atomic_set(&usbos_info->txallocated, 0);
-
-	g_probe_info.usbos_info = NULL;
-
-	MFREE(pub->osh, usbos_info, sizeof(usbos_info_t));
-	return NULL;
-
-}
-
-void
-dbus_usbos_intf_detach(dbus_pub_t *pub, void *info)
-{
-	usbos_info_t *usbos_info = (usbos_info_t *) info;
-	osl_t *osh = pub->osh;
-
-	if (usbos_info == NULL) {
-		return;
-	}
-
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-	optimize_deinit(usbos_info, usbos_info->usb);
-#endif
-	/* Must unlink all URBs prior to driver unload;
-	 * otherwise an URB callback can occur after driver
-	 * has been de-allocated and rmmod'd
-	 */
-	dbusos_stop(usbos_info);
-
-	if (usbos_info->intr_urb) {
-		USB_FREE_URB(usbos_info->intr_urb);
-		usbos_info->intr_urb = NULL;
-	}
-
-	if (usbos_info->ctl_urb) {
-		USB_FREE_URB(usbos_info->ctl_urb);
-		usbos_info->ctl_urb = NULL;
-	}
-
-	if (usbos_info->blk_urb) {
-		USB_FREE_URB(usbos_info->blk_urb);
-		usbos_info->blk_urb = NULL;
-	}
-
-	dbus_usbos_urbreqs_free(usbos_info, TRUE);
-	atomic_set(&usbos_info->rxallocated, 0);
-	dbus_usbos_urbreqs_free(usbos_info, FALSE);
-	atomic_set(&usbos_info->txallocated, 0);
-
-#if defined(BCMDBG) || defined(DBUS_LINUX_HIST)
-	if (usbos_info->txposted_hist) {
-		MFREE(osh, usbos_info->txposted_hist, (usbos_info->pub->ntxq+1) * sizeof(int));
-	}
-	if (usbos_info->rxposted_hist) {
-		MFREE(osh, usbos_info->rxposted_hist, (usbos_info->pub->nrxq+1) * sizeof(int));
-	}
-#endif /* BCMDBG || DBUS_LINUX_HIST */
-#ifdef USBOS_THREAD
-	dbus_usbos_thread_deinit(usbos_info);
-#endif /* USBOS_THREAD */
-
-	g_probe_info.usbos_info = NULL;
-	MFREE(osh, usbos_info, sizeof(usbos_info_t));
-}
-
-/*
- *	Kernel need have CONFIG_PM and CONFIG_USB_SUSPEND enabled
- * 	autosuspend also has to be enabled. if not enable by default,
- *	set /sys/bus/usb/devices/.../power/level to auto, where ... is the device'S ID
- *
- *	wl_down ->
- *      bcm_rpc_sleep -> bcm_rpc_tp_sleep -> dbus_pnp_sleep -> dbus_usbos_intf_pnp ->
- *
- *      wl_up ->
- *      bcm_rpc_resume -> bcm_rpc_tp_resume -> dbus_pnp_resume -> dbus_usbos_intf_pnp ->
- */
-static int
-dbus_usbos_intf_pnp(void *bus, int evnt)
-{
-#if !((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND))
-	DBUSERR(("PNP: %s not supported", __FUNCTION__));
-	return DBUS_OK;
-#else
-	usbos_info_t *usbos_info = (usbos_info_t *) bus;
-	DBUSERR(("PNP: %s evnt %d\n", __FUNCTION__, evnt));
-	if (usbos_info == NULL)
-		return DBUS_ERR;
-	if (evnt == DBUS_PNP_RESUME) {
-		DBUSTRACE(("intf pnp RESUME\n"));
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32))
-		atomic_set(&g_probe_info.intf->pm_usage_cnt, 1);
-#else
-		g_probe_info.intf->pm_usage_cnt = 1;
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33))
-		USB_AUTOPM_SET_INTERFACE(g_probe_info.intf);
-#else
-		USB_DISABLE_AUTOSUSPEND(g_probe_info.usb);
-#endif
-
-		if (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPEND_PENDING) {
-			/* SUSPEND not happened yet! */
-			g_probe_info.suspend_state = USBOS_SUSPEND_STATE_DEVICE_ACTIVE;
-		}
-
-		if (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_SUSPENDED) {
-		SPINWAIT((g_probe_info.suspend_state ==
-			USBOS_SUSPEND_STATE_DEVICE_ACTIVE), 3000);
-		}
-
-		if (g_probe_info.suspend_state == USBOS_SUSPEND_STATE_DEVICE_ACTIVE) {
-			DBUSTRACE(("resume USB device OK\n"));
-			if (!dbus_usbos_intf_up((void *)g_probe_info.usbos_info))
-				return DBUS_OK;
-		}
-		DBUSERR(("resume failed\n"));
-		return DBUS_ERR;
-	} else if (evnt == DBUS_PNP_SLEEP) {
-		DBUSTRACE(("PNP SLEEP\n"));
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 11, 1))
-		dbus_usbos_sleep(bus);
-#endif
-	}
-	return DBUS_OK;
-#endif /* ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) */
-}
-
-#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) \
-	&& (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 11, 1))
-/**
- * Before we are requesting the Linux kernel to auto suspend: Linux kernel requires a device to
- * cancel all its pending URBs when it is going to be suspended, and not generate new URBs.
- */
-static void
-dbus_usbos_sleep(usbos_info_t *usbos_info)
-{
-	ASSERT(usbos_info);
-
-	g_probe_info.suspend_state = USBOS_SUSPEND_STATE_SUSPEND_PENDING;
-	dbus_usbos_state_change(usbos_info, DBUS_STATE_SLEEP);
-	DBUSTRACE(("%s: unlink all URBs\n", __FUNCTION__));
-	if (usbos_info->intr_urb)
-		USB_UNLINK_URB(usbos_info->intr_urb);
-	if (usbos_info->ctl_urb)
-		USB_UNLINK_URB(usbos_info->ctl_urb);
-	if (usbos_info->blk_urb)
-		USB_UNLINK_URB(usbos_info->blk_urb);
-
-	dbus_usbos_unlink(&usbos_info->req_txpostedq, &usbos_info->txposted_lock);
-	if (usbos_info->txposted > 0) {
-		DBUSERR(("%s ERROR: tx REQs posted=%d in stop!\n", __FUNCTION__,
-			usbos_info->txposted));
-	}
-	dbus_usbos_unlink(&usbos_info->req_rxpostedq, &usbos_info->rxposted_lock);
-	if (atomic_read(&usbos_info->rxposted) > 0) {
-		DBUSERR(("%s ERROR: rx REQs posted=%d in stop!\n", __FUNCTION__,
-			atomic_read(&usbos_info->rxposted)));
-	}
-
-	/* Make sure all the urb are completed, usb_unlink_urb doesn't guarantee
-	* that. Wait for 9000us since max irq interval for EHCI is 8ms.
-	*/
-	SPINWAIT(usbos_info->txposted != 0 || atomic_read(&usbos_info->rxposted) != 0, 9000);
-	if (!(usbos_info->txposted == 0 && atomic_read(&usbos_info->rxposted) == 0)) {
-		printf("fail to  cancel irbs in 9000us\n");
-	}
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32))
-	atomic_set(&g_probe_info.intf->pm_usage_cnt, 0);
-#else
-	g_probe_info.intf->pm_usage_cnt = 0;
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33))
-	USB_AUTOPM_SET_INTERFACE(g_probe_info.intf);
-#else
-	USB_ENABLE_AUTOSUSPEND(g_probe_info.usb);
-#endif
-}
-#endif /* ((LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 21)) && defined(CONFIG_USB_SUSPEND)) */
-
-#ifdef USBOS_THREAD
-/**
- * Increase system performance by creating a USB thread that runs parallel to other system
- * activity.
- */
-static void*
-dbus_usbos_thread_init(usbos_info_t *usbos_info)
-{
-	usbos_list_entry_t  *entry;
-	unsigned long       flags, ii;
-
-	spin_lock_init(&usbos_info->usbos_list_lock);
-	INIT_LIST_HEAD(&usbos_info->usbos_list);
-	INIT_LIST_HEAD(&usbos_info->usbos_free_list);
-	init_waitqueue_head(&usbos_info->usbos_queue_head);
-	atomic_set(&usbos_info->usbos_list_cnt, 0);
-
-
-	for (ii = 0; ii < (usbos_info->pub->nrxq + usbos_info->pub->ntxq); ii++) {
-		entry = MALLOC(usbos_info->pub->osh, sizeof(usbos_list_entry_t));
-		if (entry) {
-			spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
-			list_add_tail((struct list_head*) entry, &usbos_info->usbos_free_list);
-			spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
-		} else {
-			DBUSERR(("Failed to create list\n"));
-		}
-	}
-
-	usbos_info->usbos_kt = kthread_create(dbus_usbos_thread_func,
-		usbos_info, "usb-thread");
-
-	if (IS_ERR(usbos_info->usbos_kt)) {
-		DBUSERR(("Thread Creation failed\n"));
-		return (NULL);
-	}
-
-	wake_up_process(usbos_info->usbos_kt);
-
-	return (usbos_info->usbos_kt);
-}
-
-
-static void
-dbus_usbos_thread_deinit(usbos_info_t *usbos_info)
-{
-	struct list_head    *cur, *next;
-	usbos_list_entry_t  *entry;
-	unsigned long       flags;
-
-	if (usbos_info->usbos_kt) {
-		wake_up_interruptible(&usbos_info->usbos_queue_head);
-		kthread_stop(usbos_info->usbos_kt);
-	}
-
-	list_for_each_safe(cur, next, &usbos_info->usbos_list)
-	{
-		entry = list_entry(cur, struct usbos_list_entry, list);
-		/* detach this entry from the list and then free the entry */
-		spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
-		list_del(cur);
-		MFREE(usbos_info->pub->osh, entry, sizeof(usbos_list_entry_t));
-		spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
-	}
-
-	list_for_each_safe(cur, next, &usbos_info->usbos_free_list)
-	{
-		entry = list_entry(cur, struct usbos_list_entry, list);
-		/* detach this entry from the list and then free the entry */
-		spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
-		list_del(cur);
-		MFREE(usbos_info->pub->osh, entry, sizeof(usbos_list_entry_t));
-		spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
-	}
-}
-
-/** Process completed URBs in a worker thread */
-static int
-dbus_usbos_thread_func(void *data)
-{
-	usbos_info_t        *usbos_info = (usbos_info_t *)data;
-	usbos_list_entry_t  *entry;
-	struct list_head    *cur, *next;
-	unsigned long       flags;
-
-#ifdef WL_THREADNICE
-	set_user_nice(current, WL_THREADNICE);
-#endif
-
-	while (1) {
-		/* If the list is empty, then go to sleep */
-		wait_event_interruptible_timeout
-		(usbos_info->usbos_queue_head,
-			atomic_read(&usbos_info->usbos_list_cnt) > 0,
-			100);
-
-		if (kthread_should_stop())
-			break;
-
-		spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
-
-		/* For each entry on the list, process it.  Remove the entry from
-		* the list when done.
-		*/
-		list_for_each_safe(cur, next, &usbos_info->usbos_list)
-		{
-			urb_req_t           *req;
-			int                 len;
-			int                 stat;
-			usbos_info_t        *usbos_info;
-
-			entry = list_entry(cur, struct usbos_list_entry, list);
-			if (entry == NULL)
-				break;
-
-			req = entry->urb_context;
-			len = entry->urb_length;
-			stat = entry->urb_status;
-			usbos_info = req->usbinfo;
-
-			/* detach this entry from the list and attach it to the free list */
-			list_del_init(cur);
-			spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
-
-			dbus_usbos_recv_complete_handle(req, len, stat);
-
-			spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
-
-			list_add_tail(cur, &usbos_info->usbos_free_list);
-
-			atomic_dec(&usbos_info->usbos_list_cnt);
-		}
-
-		spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
-
-	}
-
-	return 0;
-}
-
-/* Called on Linux calling URB callback, see dbus_usbos_recv_complete() */
-static void
-dbus_usbos_dispatch_schedule(CALLBACK_ARGS)
-{
-	urb_req_t           *req = urb->context;
-	usbos_info_t        *usbos_info = req->usbinfo;
-	usbos_list_entry_t  *entry;
-	unsigned long       flags;
-	struct list_head    *cur;
-
-	spin_lock_irqsave(&usbos_info->usbos_list_lock, flags);
-
-	cur   = usbos_info->usbos_free_list.next;
-	entry = list_entry(cur, struct usbos_list_entry, list);
-
-	/* detach this entry from the free list and prepare it insert it to use list */
-	list_del_init(cur);
-
-	if (entry) {
-		entry->urb_context = urb->context;
-		entry->urb_length  = urb->actual_length;
-		entry->urb_status  = urb->status;
-
-		atomic_inc(&usbos_info->usbos_list_cnt);
-		list_add_tail(cur, &usbos_info->usbos_list);
-	}
-	else {
-		DBUSERR(("!!!!!!OUT OF MEMORY!!!!!!!\n"));
-	}
-
-	spin_unlock_irqrestore(&usbos_info->usbos_list_lock, flags);
-
-	/* thread */
-	wake_up_interruptible(&usbos_info->usbos_queue_head);
-
-}
-
-#endif /* USBOS_THREAD */
-
-#ifdef USB_TRIGGER_DEBUG
-static bool
-dbus_usbos_ctl_send_debugtrig(usbos_info_t* usbinfo)
-{
-	bootrom_id_t id;
-
-	if (usbinfo == NULL)
-		return FALSE;
-
-	id.chip = 0xDEAD;
-
-	dbus_usbos_dl_cmd(usbinfo, DL_DBGTRIG, &id, sizeof(bootrom_id_t));
-
-	/* ignore the result for now */
-	return TRUE;
-}
-#endif /* USB_TRIGGER_DEBUG */
-
-
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-/** New optimized code for USB AP */
-void inline optimize_ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma)
-{
-	memset(qtd, 0, sizeof(*qtd));
-	wmb();
-	qtd->qtd_self = dma;
-	qtd->qtd_status = cpu_to_le32(EHCI_QTD_HALTED);
-	qtd->qtd_next = EHCI_NULL;
-	qtd->qtd_altnext = EHCI_NULL;
-	qtd->obj_next = NULL;
-	qtd->rpc = NULL;
-	/* qtd->buff = NULL; */
-	qtd->xacterrs = EHCI_QTD_XACTERR_MAX;
-	wmb();
-}
-
-struct ehci_qtd *optimize_ehci_qtd_alloc(gfp_t flags)
-{
-	struct ehci_qtd		*qtd;
-	dma_addr_t		dma;
-
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-
-	struct dma_pool *pool = usbos_info->qtd_pool;
-
-	qtd = dma_pool_alloc(pool, flags, &dma);
-	if (qtd != NULL) {
-		optimize_ehci_qtd_init(qtd, dma);
-	}
-	return qtd;
-}
-
-void optimize_ehci_qtd_free(struct ehci_qtd *qtd)
-{
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-	struct dma_pool *pool = usbos_info->qtd_pool;
-	dma_pool_free(pool, qtd, qtd->qtd_self);
-}
-
-/*
- * Loosely follows qtd_copy_status
- * Greatly simplified as there are only three options: normal, short read, and disaster
- */
-static int BCMFASTPATH get_qtd_status(struct ehci_qtd *qtd, int token, int *actual_length)
-{
-	int	status = -EINPROGRESS;
-
-	*actual_length += qtd->length - EHCI_QTD_GET_BYTES(token);
-
-	/* Short read is not an error */
-	if (unlikely (SHORT_READ_Q (token)))
-		status = -EREMOTEIO;
-
-	/* Check for serious problems */
-	if (token & EHCI_QTD_HALTED) {
-		status = -EPROTO;
-		if (token & (EHCI_QTD_BABBLE | EHCI_QTD_MISSEDMICRO | EHCI_QTD_BUFERR |
-			EHCI_QTD_XACTERR))
-			printk("EHCI Fastpath: Serious USB issue qtd %p token %08x --> status %d\n",
-				qtd, token, status);
-	}
-
-	return status;
-
-}
-
-static void dump_qtd(struct ehci_qtd *qtd)
-{
-	printk("qtd_next %08x qtd_altnext %08x qtd_status %08x\n", qtd->qtd_next,
-		qtd->qtd_altnext, qtd->qtd_status);
-}
-
-static void dump_qh(struct ehci_qh *qh)
-{
-	struct ehci_qtd *qtd = (struct ehci_qtd *)(qh->qh_curqtd | 0xa0000000);
-	printk("EHCI Fastpath: QH %p Dump\n", qh);
-	printk("qtd_next %08x info1 %08x info2 %08x current %08x\n", qh->qh_link, qh->qh_endp,
-		qh->qh_endphub, qh->qh_curqtd);
-	printk("overlay\n");
-	dump_qtd((struct ehci_qtd *)&qh->ow_next);
-	while ((((int)qtd)&EHCI_NULL) == 0)
-	{
-		printk("QTD %p\n", qtd);
-		dump_qtd((struct ehci_qtd *)qtd);
-		qtd = (struct ehci_qtd *)(qtd->qtd_next | 0xa0000000);
-	}
-}
-
-
-/**
- * This code assumes the caller holding a lock
- * It is currently called from scan_async that should have the lock
- * Lock shall be dropped around the actual completion, then reacquired
- * This is a clean implementation of the qh_completions()
- */
-static void BCMFASTPATH ehci_bypass_callback(int pipeindex, struct ehci_qh *qh, spinlock_t *lock)
-{
-							/* Loop variables */
-	struct ehci_qtd		*qtd, 			/* current QTD */
-				*end = qh->dummy, 	/* "afterend" */
-				*next;
-	int			stopped;
-
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-
-	/* printk("EHCI Fastpath: callback pipe %d QH %p lock %p\n", pipeindex, qh, lock); */
-
-	/*
-	 * This code should not require any interlocking with QTD additions
-	 * The additions never touch QH, we should never touch 'end'
-	 * Note that QTD additions will keep 'end' in place
-	 */
-	for (qtd = qh->first_qtd; qtd != end; qtd = next)
-	{
-		u32		status;		/* Status bits from QTD */
-
-		/* Get the status bits from the QTD */
-		rmb();
-		status = hc32_to_cpu(qtd->qtd_status);
-
-		if ((status & EHCI_QTD_ACTIVE) == 0) {
-			if (unlikely((status & EHCI_QTD_HALTED) != 0)) {
-				/* Retry transaction errors until we
-				 * reach the software xacterr limit
-				 */
-				if ((status & EHCI_QTD_XACTERR) &&
-					EHCI_QTD_GET_CERR(status) == 0 &&
-					--qtd->xacterrs > 0) {
-					/* Reset the token in the qtd and the
-					 * qh overlay (which still contains
-					 * the qtd) so that we pick up from
-					 * where we left off
-					 */
-					printk("EHCI Fastpath: detected XactErr "
-						"qtd %p len %d/%d retry %d\n",
-						qtd, qtd->length - EHCI_QTD_GET_BYTES(status),
-						qtd->length,
-						EHCI_QTD_XACTERR_MAX - qtd->xacterrs);
-
-					status &= ~EHCI_QTD_HALTED;
-					status |= EHCI_QTD_ACTIVE | EHCI_QTD_SET_CERR(3);
-					qtd->qtd_status = cpu_to_le32(status);
-					wmb();
-					qh->ow_status = cpu_to_le32(status);
-
-					break;
-				}
-
-				/* QTD processing was aborted - highly unlikely (never seen, so not
-				 * tested). In very new 2.6, we can retry. In 2.4 and older 2.6,
-				 * life sucks (the USB stack does the same)
-				 */
-				printk("EHCI Fastpath: QTD halted\n");
-				dump_qh(qh);
-				stopped = 1;
-			}
-		} else
-			/* Inactive QTD is an afterend, finished the list */
-			break;
-
-		/* Remove the QTD from software QH. This should be done before dropping the lock
-		 * in for upper layer
-		 */
-		next = qtd->obj_next;
-		qh->first_qtd = next;
-
-		/* Upper layer processing. */
-		if (EHCI_QTD_GET_PID(status) == 0)  /* OUT pipe */
-		{
-			if (qtd->rpc == NULL)
-			{
-				usbos_info->waitdone = TRUE;
-				wake_up_interruptible(&usbos_info->wait);
-				usbos_info->sync_urb_status = 0;
-			} else {
-
-
-
-				/* usb_info_t *usb_info = (usb_info_t *) handle; */
-				usb_info_t *usb_info = (usb_info_t *) usbos_info->cbarg;
-				/* if(usb_info && usb_info->cbs && usb_info->cbs->send_irb_complete)
-				 * usb_info->cbs->send_irb_complete(usb_info->cbarg, txirb, status);
-				 */
-
-				dbus_info_t *dbus_info = (dbus_info_t *)usb_info->cbarg;
-
-				/* Free the coalesce buffer, if multi-buffer packet only. Do not
-				 * rely on buff, as it might not even exist
-				 */
-				if (PKTNEXT(dbus_info->pub->osh, qtd->rpc)) {
-					/* printk("k-Freeing %p\n", qtd->buff); */
-					kfree(qtd->buff);
-				}
-
-				if (dbus_info->cbs && dbus_info->cbs->send_complete)
-				{
-					atomic_dec(&s_tx_pending);
-					spin_unlock(lock);
-					/* printk("Sending to RPC qtd %p\n", qtd); */
-#if !(defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_TXNOCOPY) || defined(BCM_RPC_TOC))
-	#error Configuration not supported; read dbus_if_send_irb_complete for guidelines
-#endif
-					dbus_info->cbs->send_complete(dbus_info->cbarg, qtd->rpc,
-						0);
-					if ((atomic_read(&s_tx_pending) < 16) &&
-						dbus_info->txoff && !dbus_info->txoverride) {
-						dbus_flowctrl_tx(dbus_info, OFF);
-					}
-					spin_lock(lock);
-
-					/* Things could have happened while the lock was gone,
-					 * resync to the hardware
-					 */
-					next = qh->first_qtd;
-					end = qh->dummy;
-				}
-			}
-
-			optimize_ehci_qtd_free(qtd);
-		}
-		else	   /* IN pipe */
-		{
-			/* Simulates the upstream travel */
-			usb_info_t *usb_info = (usb_info_t *) usbos_info->cbarg;
-			dbus_info_t *dbus_info = (dbus_info_t *)usb_info->cbarg;
-			/* unsigned long       flags; */
-			int actual_length = 0;
-
-			/* All our reads must be short */
-			if (!SHORT_READ_Q (status)) ASSERT(0);
-
-			/* Done with hardware, convert status to error codes */
-			status = get_qtd_status(qtd, status, &actual_length);
-
-			switch (status) {
-			/* success */
-			case 0:
-			case -EINPROGRESS:
-			case -EREMOTEIO:
-				status = 0;
-				break;
-
-			case -ECONNRESET:		/* canceled */
-			case -ENOENT:
-			case -EPROTO:
-				DBUSERR(("%s: ehci unlink. status %x\n", __FUNCTION__, status));
-				break;
-			}
-
-			if (g_probe_info.dereged) {
-				printk("%s: DBUS deregistering, ignoring recv callback\n",
-					__FUNCTION__);
-				return;
-			}
-
-			dma_unmap_single(
-				usbos_info->usb->bus->controller,
-				(dma_addr_t)qtd->qtd_buffer_hi[0],
-				actual_length,
-				DMA_FROM_DEVICE);
-
-
-			if (dbus_info->pub.busstate != DBUS_STATE_DOWN) {
-				if (status == 0) {
-					void *buf = qtd->rpc;
-
-					ASSERT(buf != NULL);
-					spin_unlock(lock);
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-					/* Note that these ifdefs are indirectly coming from
-					 * dbus_usbos_recv_urb_submit The code itself is from
-					 * dbus_if_recv_irb_complete that makes the decision
-					 * at runtime, yet it is only pkt or buf depending on
-					 * the NOCOPY setup, never both :-)
-					 */
-					if (dbus_info->cbs && dbus_info->cbs->recv_pkt)
-						dbus_info->cbs->recv_pkt(dbus_info->cbarg, buf);
-#else
-					if (actual_length > 0) {
-						if (dbus_info->cbs && dbus_info->cbs->recv_buf)
-							dbus_info->cbs->recv_buf(dbus_info->cbarg,
-							buf, actual_length);
-					}
-#endif
-					spin_lock(lock);
-
-					/* Things could have happened while the lock was gone,
-					 * resync to the hardware
-					 */
-					next = qh->first_qtd;
-					end = qh->dummy;
-
-					/* Reinitialize this qtd since it will be reused. */
-					optimize_ehci_qtd_init(qtd, qtd->qtd_self);
-
-#if defined(BCM_RPC_NOCOPY) || defined(BCM_RPC_RXNOCOPY)
-					/* Note that these ifdefs are coming from
-					 * dbus_usbos_recv_urb_submit. In the NOCOPY configuration,
-					 * force an allocation of a new packet
-					 */
-					optimize_submit_rx_request(&dbus_info->pub, 1, qtd, NULL);
-
-#else
-					/* In the copy mode, simply reuse the buffer; upper level
-					 * had already consumed the data
-					 */
-					optimize_submit_rx_request(&dbus_info->pub, 1, qtd, buf);
-#endif
-					/* Not to free this qtd because it will be reused. */
-					continue;
-				}
-			} else {
-				printk("%s: DBUS down, ignoring recv callback\n", __FUNCTION__);
-			}
-			optimize_ehci_qtd_free(qtd);
-		}
-	}
-}
-
-static void optimize_urb_callback(struct urb *urb)
-{
-	struct usb_ctrlrequest *req = urb->context;
-
-	kfree(req);
-	USB_FREE_URB(urb);
-}
-
-/* Shall be called under an external lock (currently RPC_TP_LOCK) */
-static int optimize_submit_urb(struct usb_device *usb, void *ptr, int request)
-{
-	struct usb_ctrlrequest *req;
-	struct urb *urb;
-
-	if ((urb = USB_ALLOC_URB()) == NULL) {
-		printk("EHCI Fastpath: Error allocating URB in optimize_EP!");
-		return -ENOMEM;
-	}
-
-	if ((req = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC)) == NULL) {
-		printk("EHCI Fastpath: Failed to allocate memory for control request in"
-			" optimize_EP!");
-		USB_FREE_URB(urb);
-		return -ENOMEM;
-	}
-
-	req->bRequestType = (USB_TYPE_VENDOR | USB_RECIP_OTHER);
-	req->bRequest = request;
-
-	/* Use this instead of a buffer */
-	req->wValue = ((int)ptr & 0xffff);
-	req->wIndex = ((((int)ptr)>>16) & 0xffff);
-	req->wLength = 0;
-
-	printk("EHCI Fastpath: usb_dev %p\n", usb);
-	printk("EHCI Fastpath: bus %p\n", usb->bus);
-	printk("EHCI Fastpath: Hub %p\n", usb->bus->root_hub);
-
-	usb_fill_control_urb(
-		urb,
-		usb->bus->root_hub,
-		usb_sndctrlpipe(usb->bus->root_hub, 0),
-		(void *)req,
-		NULL,
-		0,
-		optimize_urb_callback,
-		req);
-
-	USB_SUBMIT_URB(urb);
-
-	if (urb->status != 0) {
-		printk("EHCI Fastpath: Cannot submit URB in optimize_EP: %d\n", urb->status);
-	}
-
-	return urb->status;
-}
-
-static int epnum(int pipe)
-{
-	int epn = usb_pipeendpoint(pipe);
-	if (usb_pipein (pipe))
-		epn |= 0x10;
-	return epn;
-}
-
-
-static int optimize_init(usbos_info_t *usbos_info, struct usb_device *usb, int out, int in, int in2)
-{
-	int retval = -EPIPE;
-
-	atomic_set(&s_tx_pending, 0);
-	/* atomic_set(&s_rx_pending, 0); */
-
-	usbos_info->tx_ep = epnum(out);
-	usbos_info->rx_ep = epnum(in);
-	usbos_info->rx2_ep = epnum(in2);
-	usbos_info->usb_device = usb;
-
-	/* printk("EHCI Fastpath: Create pool %p %p %p\n", usb, usb->bus, usb->bus->controller); */
-
-	/* QTDs for bulk transfers - separate pool */
-	usbos_info->qtd_pool = dma_pool_create("usbnet_qtd",
-		usb->bus->controller,
-		sizeof(struct ehci_qtd),
-		EHCI_QTD_ALIGN /* byte alignment (for hw parts) */,
-		4096 /* can't cross 4K */);
-	if (!usbos_info->qtd_pool) {
-		printk("EHCI Fastpath: Cannot create the QTD pool\n");
-		goto fail;
-	}
-
-	/* detaching the EP */
-	if (optimize_submit_urb(usb, usb, EHCI_SET_BYPASS_DEV) != 0)
-		goto fail;
-	optimize_submit_urb(usb, ehci_bypass_callback, EHCI_SET_BYPASS_CB);
-	optimize_submit_urb(usb, usbos_info->qtd_pool, EHCI_SET_BYPASS_POOL);
-#ifdef EHCI_FASTPATH_TX
-	optimize_submit_urb(usb, (void*)((0<<16)|usbos_info->tx_ep), EHCI_FASTPATH);
-#endif
-#ifdef EHCI_FASTPATH_RX
-	optimize_submit_urb(usb, (void*)((1<<16)|usbos_info->rx_ep),   EHCI_FASTPATH);
-#endif
-
-	/* getting the QH */
-	printk("EHCI Fastpath: EP in %d EP in2 %d EP out %d\n", usbos_info->rx_ep,
-		usbos_info->rx2_ep, usbos_info->tx_ep);
-
-	return 0;
-
-fail:
-	return retval;
-}
-
-static int optimize_deinit_qtds(struct ehci_qh *qh, int coalesce_buf)
-{
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-	struct ehci_qtd *qtd, *end, *next;
-	unsigned long	flags;
-
-	if (qh == NULL)
-		return 0;
-
-	end = qh->dummy;
-
-	printk("%s %d. qh = %p\n", __func__, __LINE__, qh);
-
-	spin_lock_irqsave(&usbos_info->fastpath_lock, flags);
-	for (qtd = qh->first_qtd; qtd != end; qtd = next) {
-		next = qtd->obj_next;
-		qh->first_qtd = next;
-
-		/* Free the coalesce buffer, if multi-buffer packet only. Do not
-		 * rely on buff, as it might not even exist
-		 */
-		if (coalesce_buf && PKTNEXT(dbus_info->pub->osh, qtd->rpc)) {
-			printk("k-Freeing %p, ", qtd->buff);
-			kfree(qtd->buff);
-		}
-		printk("freeing qtd %p\n", qtd);
-
-		optimize_ehci_qtd_free(qtd);
-	}
-	spin_unlock_irqrestore(&usbos_info->fastpath_lock, flags);
-
-	return 0;
-}
-
-
-static BCMFASTPATH struct ehci_qh *get_ep(usbos_info_t *usbos_info, int ep)
-{
-#ifdef KERNEL26
-	struct usb_host_endpoint *epp = NULL;
-	switch (ep)
-	{
-	case 0: epp = usbos_info->usb_device->ep_out[usbos_info->tx_ep&0xf]; break;
-	case 1: epp = usbos_info->usb_device->ep_in[usbos_info->rx_ep&0xf]; break;
-	case 2: epp = usbos_info->usb_device->ep_in[usbos_info->rx2_ep&0xf]; break;
-	default: ASSERT(0);
-	}
-	if (epp != NULL)
-		return (struct ehci_qh *)epp->hcpriv;
-	else return NULL;
-#else
-	switch (ep)
-	{
-	case 0: return (struct ehci_qh *)(((struct hcd_dev*)(usbos_info->
-		usb_device->hcpriv))->ep[usbos_info->tx_ep]);
-	case 1: return (struct ehci_qh *)(((struct hcd_dev*)(usbos_info->
-		usb_device->hcpriv))->ep[usbos_info->rx_ep]);
-	case 2: return (struct ehci_qh *)(((struct hcd_dev*)(usbos_info->
-		usb_device->hcpriv))->ep[usbos_info->rx2_ep]);
-	default: ASSERT(0);
-	}
-	return NULL;
-#endif /* KERNEL26 */
-}
-
-static int optimize_deinit(usbos_info_t *usbos_info, struct usb_device *usb)
-{
-	optimize_deinit_qtds(get_ep(usbos_info, 0), 1);
-	optimize_deinit_qtds(get_ep(usbos_info, 1), 0);
-#if defined(EHCI_FASTPATH_TX) || defined(EHCI_FASTPATH_RX)
-	optimize_submit_urb(usb, (void *)0, EHCI_CLR_EP_BYPASS);
-#endif
-	dma_pool_destroy(usbos_info->qtd_pool);
-	return 0;
-}
-
-/** Reassemble the segmented packet */
-static int BCMFASTPATH optimize_gather(const dbus_pub_t *pub, void *pkt, void **buf)
-{
-	int len = 0;
-
-	void *transfer_buf = kmalloc(pkttotlen(pub->osh, pkt),
-		GFP_ATOMIC);
-	*buf = transfer_buf;
-
-	if (!transfer_buf) {
-		printk("fail to alloc to usb buffer\n");
-		return 0;
-	}
-
-	while (pkt) {
-		int pktlen = PKTLEN(pub->osh, pkt);
-		bcopy(PKTDATA(pub->osh, pkt), transfer_buf, pktlen);
-		transfer_buf += pktlen;
-		len += pktlen;
-		pkt = PKTNEXT(usbos_info->pub->osh, pkt);
-	}
-
-	/* printk("Coalesced a %d-byte buffer\n", len); */
-
-	return len;
-}
-
-int BCMFASTPATH optimize_qtd_fill_with_rpc(const dbus_pub_t *pub, int epn,
-	struct ehci_qtd *qtd, void *rpc, int token, int len)
-{
-	void *data = NULL;
-
-	if (len == 0)
-		return optimize_qtd_fill_with_data(pub, epn, qtd, data, token, len);
-
-	ASSERT(rpc != NULL);
-	data = PKTDATA(pub->osh, rpc);
-	qtd->rpc = rpc;
-
-	if (PKTNEXT(pub->osh, rpc)) {
-		len = optimize_gather(pub, rpc, &data);
-		qtd->buff = data;
-	}
-
-	return optimize_qtd_fill_with_data(pub, epn, qtd, data, token, len);
-}
-
-/** Fill the QTD from the data buffer */
-int BCMFASTPATH optimize_qtd_fill_with_data(const dbus_pub_t *pub, int epn,
-	struct ehci_qtd *qtd, void *data, int token, int len)
-{
-	int		i, bytes_fit, page_offset;
-	dma_addr_t	addr = 0;
-
-	/* struct usb_host_endpoint *ep = get_ep(epn); */
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-
-	token |= (EHCI_QTD_ACTIVE | EHCI_QTD_IOC); /* Allow execution, force interrupt */
-
-	if (len > 0) {
-		addr = dma_map_single(
-			usbos_info->usb->bus->controller,
-			data,
-			len,
-			EHCI_QTD_GET_PID(token) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
-	}
-
-	qtd->qtd_buffer[0] = cpu_to_hc32((u32)addr);
-	/* Here qtd->qtd_buffer_hi[0] is leveraged to store addr value, which
-	 * is needed when invoking dma_unmap_single() in ehci_bypass_callback().
-	 * This is valid for EHCI 32bit only.
-	 */
-	qtd->qtd_buffer_hi[0] = cpu_to_hc32((u32)addr);
-	page_offset = (addr & (EHCI_PAGE_SIZE-1));
-	bytes_fit = EHCI_PAGE_SIZE - page_offset;
-	addr -= page_offset;
-	if (len < bytes_fit)
-		bytes_fit = len;
-	else {
-		addr +=  EHCI_PAGE_SIZE;
-
-		for (i = 1; bytes_fit < len && i < EHCI_QTD_NBUFFERS; i++) {
-			qtd->qtd_buffer[i] = cpu_to_hc32((u32)addr);
-			qtd->qtd_buffer_hi[i] = 0;
-			addr += EHCI_PAGE_SIZE;
-			if ((bytes_fit + EHCI_PAGE_SIZE) < len)
-				bytes_fit += EHCI_PAGE_SIZE;
-			else
-				bytes_fit = len;
-		}
-
-		if (bytes_fit != len)
-		{
-			ASSERT(0);
-		}
-	}
-	qtd->qtd_status = cpu_to_hc32((bytes_fit << 16) | token);
-	qtd->length = bytes_fit;
-
-	return bytes_fit;
-}
-
-
-/** Reimplementation of qh_append_tds()
- * Returns nonzero if too many requests pending
- */
-int BCMFASTPATH optimize_submit_async(struct ehci_qtd *qtd, int epn)
-{
-	/* Clean implementation along the lines of qh_append_tds() */
-
-	struct ehci_qtd		*afterend; /* Element at the end of the QTD chain (after the
-					    * last useful one, "after-end")
-					    */
-	dma_addr_t		hw_addr;
-	__hc32			status;
-	unsigned long	flags;
-
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-	struct ehci_qh *qh = get_ep(usbos_info, epn);
-	usb_info_t *usb_info = (usb_info_t *) usbos_info->cbarg;
-	dbus_info_t *dbus_info = (dbus_info_t *)usb_info->cbarg;
-
-	/* printk("Submit qtd %p to pipe %d (%p)\n", qtd, epn, qh); */
-	if (qh == NULL)
-	{
-		printk("EHCI Fastpath: Attempt of optimized submit to a non-optimized pipe\n");
-		return -1;
-	}
-
-	spin_lock_irqsave(&usbos_info->fastpath_lock, flags);
-
-	/* Limit outstanding - for rpc behavior only */
-	/* printk("QH qtd_status %08x\n", qh->hw->qtd_status); */
-
-	if ((qtd->qtd_status & (1<<8)) == 0)
-	{
-		atomic_inc(&s_tx_pending);
-		if (atomic_read(&s_tx_pending) > 16*2) /* (dbus_info->tx_low_watermark * 3)) */
-			dbus_flowctrl_tx(dbus_info, TRUE);
-	}
-
-	ASSERT(qh != NULL);
-
-
-	/*
-	 * Standard list processing trick:
-	 *   * old "afterend" is filled with the incoming data while still HALTed
-	 *   * new element is appended and prepared to serve as new afterend
-	 *   * now old afterend is activated
-	 * This way, HW never races the SW - no semaphores are necessary, as long as this function
-	 * is not reentered for the same QH
-	 */
-
-	/* Make new QTD to be HALTed, wait for it to actually happen */
-	status = qtd->qtd_status;
-	qtd->qtd_status = cpu_to_le32(EHCI_QTD_HALTED);
-	wmb();
-
-	/* Now copy all information from the new QTD to the old afterend,
-	 * except the own HW address
-	 */
-	afterend = qh->dummy;
-	hw_addr = afterend->qtd_self;
-	*afterend = *qtd;
-	afterend->qtd_self = hw_addr;
-
-	/* The new QTD is ready to serve as a new afterend, append it */
-	qh->dummy = qtd;
-	afterend->qtd_next = qtd->qtd_self;
-	afterend->qtd_altnext = qtd->qtd_self;  /* Always assume short read. Harmless in our case */
-	afterend->obj_next = qtd;
-
-	/* Wait for writes to happen and enable the old afterend (now containing the QTD data) */
-	wmb();
-	afterend->qtd_status = status;
-	wmb();
-
-	spin_unlock_irqrestore(&usbos_info->fastpath_lock, flags);
-
-	return 0;
-}
-
-void BCMFASTPATH optimize_submit_rx_request(const dbus_pub_t *pub, int epn, struct ehci_qtd *qtd_in,
-                                            void *buf)
-{
-	usbos_info_t *usbos_info = g_probe_info.usbos_info;
-	int len = usbos_info->rxbuf_len;
-	void *pkt;
-	struct ehci_qtd *qtd;
-	int token = EHCI_QTD_SET_CERR(3) | EHCI_QTD_SET_PID(1);
-
-	if (qtd_in == NULL) {
-		qtd = optimize_ehci_qtd_alloc(GFP_KERNEL);
-		if (!qtd) {
-			printk("EHCI Fastpath: Out of QTDs\n");
-			return;
-		}
-	}
-	else
-		qtd = qtd_in;
-
-	if (buf == NULL)
-	{
-		/* NOCOPY, allocate own packet */
-		/* Follow dbus_usbos_recv_urb_submit */
-		pkt = PKTGET(usbos_info->pub->osh, len, FALSE);
-		if (pkt == NULL) {
-			printk("%s: PKTGET failed\n", __FUNCTION__);
-			optimize_ehci_qtd_free(qtd);
-			return;
-		}
-		/* consider the packet "native" so we don't count it as MALLOCED in the osl */
-		PKTTONATIVE(usbos_info->pub->osh, pkt);
-		qtd->rpc = pkt;
-		buf = PKTDATA(usbos_info->pub->osh, pkt);
-
-	}
-	else
-		qtd->rpc = buf;
-
-	optimize_qtd_fill_with_data(pub, epn, qtd, buf, token, len);
-	optimize_submit_async(qtd, epn);
-}
-#endif /* EHCI_FASTPATH_TX || EHCI_FASTPATH_RX */
-
-#ifdef BCM_REQUEST_FW
-void *
-dbus_get_fw_nvfile(int devid, uint8 **fw, int *fwlen, int type, uint16 boardtype,
-	uint16 boardrev)
-{
-	s8 fw_name[64];
-	s8 file_name[64];
-	const struct firmware *firmware = NULL;
-	int err;
-
-	strcpy(fw_name, "brcm/bcm");
-	if (type == DBUS_FIRMWARE) {
-		switch (devid) {
-		case BCM4350_CHIP_ID:
-			strcat(fw_name, "4350");
-			break;
-		case BCM43143_CHIP_ID:
-			strcat(fw_name, "43143");
-			break;
-		case BCM43234_CHIP_ID:
-		case BCM43235_CHIP_ID:
-		case BCM43236_CHIP_ID:
-			strcat(fw_name, "43236");
-			break;
-		case BCM43242_CHIP_ID:
-			strcat(fw_name, "43242");
-			break;
-		case BCM43526_CHIP_ID:
-			strcat(fw_name, "43526");
-			break;
-		case BCM4360_CHIP_ID:
-			strcat(fw_name, "4360");
-			break;
-		default:
-			DBUSERR(("unsupported device %x\n", devid));
-			return NULL;
-		}
-		/* load firmware */
-		strcat(fw_name, "-firmware.bin");
-		err = request_firmware(&firmware, fw_name, &g_probe_info.usb->dev);
-		if (err) {
-			DBUSERR(("fail to request firmware %s\n", fw_name));
-			return NULL;
-		}
-	} else {
-		switch (devid) {
-		case BCM4350_CHIP_ID:
-			strcat(fw_name, "4350");
-			break;
-		case BCM43143_CHIP_ID:
-			strcat(fw_name, "43143");
-			break;
-		case BCM43234_CHIP_ID:
-			strcat(fw_name, "43234");
-			break;
-		case BCM43235_CHIP_ID:
-			strcat(fw_name, "43235");
-			break;
-		case BCM43236_CHIP_ID:
-			strcat(fw_name, "43236");
-			break;
-		case BCM43242_CHIP_ID:
-			strcat(fw_name, "43242");
-			break;
-		case BCM43526_CHIP_ID:
-			strcat(fw_name, "43526");
-			break;
-		case BCM4360_CHIP_ID:
-			strcat(fw_name, "4360");
-			break;
-		default:
-			DBUSERR(("unsupported device %x\n", devid));
-			return NULL;
-		}
-		/* load board specific nvram file */
-		snprintf(file_name, sizeof(file_name), "%s-%2x-%2x.nvm", fw_name,
-			boardtype, boardrev);
-		err = request_firmware(&firmware, file_name, &g_probe_info.usb->dev);
-		if (err) {
-			/* board specific file missing - load the generic nvram file */
-			snprintf(file_name, sizeof(file_name), "%s.nvm", fw_name);
-			err = request_firmware(&firmware, file_name, &g_probe_info.usb->dev);
-			if (err) {
-				return NULL;
-			}
-		}
-	}
-
-	*fwlen = firmware->size;
-	*fw = (uint8 *)firmware->data;
-	return (void *)firmware;
-}
-
-void
-dbus_release_fw_nvfile(void *firmware)
-{
-	release_firmware((struct firmware *)firmware);
-}
-#endif /* #ifdef BCM_REQUEST_FW */
-
-/** For a composite device the interface order is not guaranteed,
- * scan the device struct for the WLAN interface
- */
-#ifdef BCMUSBDEV_COMPOSITE
-static int
-dbus_usbos_intf_wlan(struct usb_device *usb)
-{
-	int i, num_of_eps, ep, intf_wlan = -1;
-	int num_intf = CONFIGDESC(usb)->bNumInterfaces;
-	struct usb_endpoint_descriptor *endpoint;
-
-	for (i = 0; i < num_intf; i++) {
-		if (IFDESC(usb, i).bInterfaceClass != USB_CLASS_VENDOR_SPEC)
-			continue;
-		num_of_eps = IFDESC(usb, i).bNumEndpoints;
-
-		for (ep = 0; ep < num_of_eps; ep++) {
-			endpoint = &IFEPDESC(usb, i, ep);
-			if ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-				USB_ENDPOINT_XFER_BULK) {
-				intf_wlan = i;
-				break;
-			}
-		}
-		if (ep < num_of_eps)
-			break;
-	}
-
-	return intf_wlan;
-}
-#endif /* BCMUSBDEV_COMPOSITE */
diff -Nuar merlin-bkp/shared/hnddma.c merlin-new/shared/hnddma.c
--- merlin-bkp/shared/hnddma.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/hnddma.c	2014-02-24 14:15:11.000000000 +0100
@@ -2,7 +2,7 @@
  * Generic Broadcom Home Networking Division (HND) DMA module.
  * This supports the following chips: BCM42xx, 44xx, 47xx .
  *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * Copyright (C) 2014, Broadcom Corporation. All Rights Reserved.
  * 
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -16,7 +16,7 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
- * $Id: hnddma.c 423696 2013-09-13 00:56:28Z $
+ * $Id: hnddma.c 442497 2013-12-11 19:47:56Z $
  */
 
 #include <bcm_cfg.h>
@@ -1390,7 +1390,7 @@
 		/* Do a cached write instead of uncached write since DMA_MAP
 		 * will flush the cache.
 		*/
-		*(uint16 *)(PKTDATA(di->osh, p)) = 0;
+		*(uint32 *)(PKTDATA(di->osh, p)) = 0;
 #if defined(linux) && (defined(BCM47XX_CA9) || defined(__mips__))
 		DMA_MAP(di->osh, PKTDATA(di->osh, p), sizeof(uint16), DMA_TX, NULL, NULL);
 #endif
diff -Nuar merlin-bkp/shared/linux_rpc_osl.c merlin-new/shared/linux_rpc_osl.c
--- merlin-bkp/shared/linux_rpc_osl.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/linux_rpc_osl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,210 +0,0 @@
-/*
- * RPC OSL linux port
- * Broadcom 802.11abg Networking Device Driver
- *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
- * 
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * $Id: linux_rpc_osl.c 419467 2013-08-21 09:19:48Z $
- */
-#if (!defined(WLC_HIGH) && !defined(WLC_LOW))
-#error "SPLIT"
-#endif
-
-#ifdef BCMDRIVER
-#include <typedefs.h>
-#include <bcmdefs.h>
-#include <bcmendian.h>
-#include <osl.h>
-#include <bcmutils.h>
-
-#include <rpc_osl.h>
-#include <linuxver.h>
-
-struct rpc_osl {
-	osl_t *osh;
-	wait_queue_head_t wait; /* To block awaiting init frame */
-	spinlock_t	lock;
-	bool wakeup;
-	ulong flags;
-};
-
-rpc_osl_t *
-rpc_osl_attach(osl_t *osh)
-{
-	rpc_osl_t *rpc_osh;
-
-	if ((rpc_osh = (rpc_osl_t *)MALLOC(osh, sizeof(rpc_osl_t))) == NULL)
-		return NULL;
-
-	spin_lock_init(&rpc_osh->lock);
-	init_waitqueue_head(&rpc_osh->wait);
-	/* set the wakeup flag to TRUE, so we are ready
-	   to detect a call return even before we call rpc_osl_wait.
-	 */
-	rpc_osh->wakeup = TRUE;
-	rpc_osh->osh = osh;
-
-	return rpc_osh;
-}
-
-void
-rpc_osl_detach(rpc_osl_t *rpc_osh)
-{
-	if (!rpc_osh)
-		return;
-
-	MFREE(rpc_osh->osh, rpc_osh, sizeof(rpc_osl_t));
-}
-
-int
-rpc_osl_wait(rpc_osl_t *rpc_osh, uint ms, bool *ptimedout)
-{
-	unsigned long j;
-	int ret;
-
-	/* printf("%s timeout:%d\n", __FUNCTION__, ms); */
-	j = ms * HZ / 1000;
-
-	/* yield the control back to OS, wait for wake_up() call up to j ms */
-	ret = wait_event_interruptible_timeout(rpc_osh->wait, rpc_osh->wakeup == FALSE, j);
-
-	/* 0 ret => timeout */
-	if (ret == 0) {
-		if (ptimedout)
-			*ptimedout = TRUE;
-	} else if (ret < 0)
-		return ret;
-
-	RPC_OSL_LOCK(rpc_osh);
-	/* set the flag to be ready for next return  */
-	rpc_osh->wakeup = TRUE;
-	RPC_OSL_UNLOCK(rpc_osh);
-
-	return 0;
-}
-
-void
-rpc_osl_wake(rpc_osl_t *rpc_osh)
-{
-	/* Wake up if someone's waiting */
-	if (rpc_osh->wakeup == TRUE) {
-		/* this is the only place where this flag is set to FALSE
-		   It will be reset to TRUE in rpc_osl_wait.
-		 */
-		rpc_osh->wakeup = FALSE;
-		wake_up(&rpc_osh->wait);
-	}
-}
-
-void
-rpc_osl_lock(rpc_osl_t *rpc_osh)
-{
-	spin_lock_irqsave(&rpc_osh->lock, rpc_osh->flags);
-}
-
-void
-rpc_osl_unlock(rpc_osl_t *rpc_osh)
-{
-	spin_unlock_irqrestore(&rpc_osh->lock, rpc_osh->flags);
-}
-
-#else /* !BCMDRIVER */
-
-#include <typedefs.h>
-#include <osl.h>
-#include <rpc_osl.h>
-#include <pthread.h>
-#include <time.h>
-#include <errno.h>
-
-struct rpc_osl {
-	osl_t *osh;
-	pthread_cond_t wait; /* To block awaiting init frame */
-	pthread_mutex_t	lock;
-	bool wakeup;
-};
-
-rpc_osl_t *
-rpc_osl_attach(osl_t *osh)
-{
-	rpc_osl_t *rpc_osh;
-
-	if ((rpc_osh = (rpc_osl_t *)MALLOC(osh, sizeof(rpc_osl_t))) == NULL)
-		return NULL;
-
-	rpc_osh->osh = osh;
-	pthread_mutex_init(&rpc_osh->lock, NULL);
-	pthread_cond_init(&rpc_osh->wait, NULL);
-	rpc_osh->wakeup = FALSE;
-
-	return rpc_osh;
-}
-
-void
-rpc_osl_detach(rpc_osl_t *rpc_osh)
-{
-	if (rpc_osh) {
-		MFREE(rpc_osh->osh, rpc_osh, sizeof(rpc_osl_t));
-	}
-}
-
-int
-rpc_osl_wait(rpc_osl_t *rpc_osh, uint ms, bool *ptimedout)
-{
-	struct timespec timeout;
-	int ret;
-
-	printf("%s timeout:%d\n", __FUNCTION__, ms);
-	clock_gettime(CLOCK_REALTIME, &timeout);
-	timeout.tv_sec += ms/1000;
-	ms = ms - ((ms/1000) * 1000);
-	timeout.tv_nsec += ms * 1000 * 1000;
-
-	RPC_OSL_LOCK(rpc_osh);
-	rpc_osh->wakeup = FALSE;
-	while (rpc_osh->wakeup == FALSE) {
-		ret = pthread_cond_timedwait(&rpc_osh->wait, &rpc_osh->lock, &timeout);
-		/* check for timedout instead of wait condition */
-		if (ret == ETIMEDOUT) {
-			if (ptimedout)
-				*ptimedout = TRUE;
-			rpc_osh->wakeup = TRUE;
-		} else if (ret)
-			break;	/* some other error (e.g. interrupt) */
-	}
-	RPC_OSL_UNLOCK(rpc_osh);
-
-	return ret;
-}
-void
-rpc_osl_wake(rpc_osl_t *rpc_osh)
-{
-	rpc_osh->wakeup = TRUE;
-	pthread_cond_signal(&rpc_osh->wait);
-}
-
-void
-rpc_osl_lock(rpc_osl_t *rpc_osh)
-{
-	pthread_mutex_lock(&rpc_osh->lock);
-}
-
-void
-rpc_osl_unlock(rpc_osl_t *rpc_osh)
-{
-	pthread_mutex_unlock(&rpc_osh->lock);
-}
-
-#endif /* BCMDRIVER */
diff -Nuar merlin-bkp/shared/nandcore.c merlin-new/shared/nandcore.c
--- merlin-bkp/shared/nandcore.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/nandcore.c	2014-02-24 14:15:11.000000000 +0100
@@ -41,6 +41,8 @@
 #define NANDF_SMALL_BADBLOCK_POS	5
 #define NANDF_LARGE_BADBLOCK_POS	0
 
+extern int nospare;
+
 struct nandpart_timing_info {
 	const char	*name;
 	uint8	id[8];
@@ -88,6 +90,7 @@
 static int nandcore_write(hndnand_t *nfl, uint64 offset, uint len, const uchar *buf);
 static int nandcore_erase(hndnand_t *nfl, uint64 offset);
 static int nandcore_checkbadb(hndnand_t *nfl, uint64 offset);
+static int nandcore_checkbadb_nospare(hndnand_t *nfl, uint64 offset);
 static int nandcore_mark_badb(hndnand_t *nfl, uint64 offset);
 static int nandcore_read_oob(hndnand_t *nfl, uint64 addr, uint8 *oob);
 
@@ -874,6 +877,70 @@
 }
 
 static int
+nandcore_checkbadb_nospare(hndnand_t *nfl, uint64 offset)
+{
+        si_t *sih = nfl->sih;
+        nandregs_t *nc = (nandregs_t *)nfl->core;
+        aidmp_t *ai = (aidmp_t *)nfl->wrap;
+        osl_t *osh;
+        int i;
+        uint off;
+        uint32 nand_intfc_status;
+        int ret = 0;
+        uint32 reg;
+
+        ASSERT(sih);
+
+        osh = si_osh(sih);
+        if ((offset >> 20) >= nfl->size)
+                return -1;
+        if ((offset & (nfl->blocksize - 1)) != 0) {
+                return -1;
+        }
+
+        /* Set the block address for the following commands */
+        reg = (R_REG(osh, &nc->cmd_ext_address) & ~NANDCMD_EXT_ADDR_MASK);
+        W_REG(osh, &nc->cmd_ext_address, (reg | (offset >> 32)));
+
+        for (i = 0; i < 2; i++) {
+                off = offset + (nfl->pagesize * i);
+                W_REG(osh, &nc->cmd_address, off);
+                nandcore_cmd(osh, nc, NANDCMD_SPARE_RD);
+                if (nandcore_poll(sih, nc) < 0) {
+                        ret = -1;
+                        goto exit;
+                }
+                nand_intfc_status = R_REG(osh, &nc->intfc_status) & NANDIST_SPARE_VALID;
+                if (nand_intfc_status != NANDIST_SPARE_VALID) {
+                        ret = -1;
+#ifdef BCMDBG
+                        printf("%s: Spare is not valid\n", __FUNCTION__);
+#endif
+                        goto exit;
+                }
+
+                /* Toggle as little endian */
+                OR_REG(osh, &ai->ioctrl, NAND_APB_LITTLE_ENDIAN);
+
+                if ((R_REG(osh, &nc->spare_area_read_ofs[0]) & 0xff) != 0xff) {
+                        ret = -1;
+#ifdef BCMDBG
+                        printf("%s: Bad Block (0x%llx)\n", __FUNCTION__, offset);
+#endif
+                }
+
+                /* Toggle as big endian */
+                AND_REG(osh, &ai->ioctrl, ~NAND_APB_LITTLE_ENDIAN);
+
+                if (ret == -1)
+                        break;
+        }
+
+exit:
+        return ret;
+}
+
+static int
 nandcore_checkbadb(hndnand_t *nfl, uint64 offset)
 {
 	si_t *sih = nfl->sih;
@@ -887,6 +954,9 @@
 	unsigned cache, col = 0;
 	uint32 rd_oob_byte, left_oob_byte;
 
+	if(nospare)
+		return nandcore_checkbadb_nospare(nfl, offset);
+
 	ASSERT(sih);
 
 	osh = si_osh(sih);
diff -Nuar merlin-bkp/shared/qmath.c merlin-new/shared/qmath.c
--- merlin-bkp/shared/qmath.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/shared/qmath.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,717 +0,0 @@
-/*
- * qmath functions used in arithmatic and DSP operations where
- * fractional operations, saturation support is needed.
- *
- * Copyright (C) 2013, Broadcom Corporation
- * All Rights Reserved.
- * 
- * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
- * the contents of this file may not be disclosed to third parties, copied
- * or duplicated in any form, in whole or in part, without the prior
- * written permission of Broadcom Corporation.
- *
- * $Id: qmath.c 419467 2013-08-21 09:19:48Z $
- */
-
-#include <bcm_cfg.h>
-#include "qmath.h"
-
-/*
-Description: This function saturate input 32 bit number into a 16 bit number.
-If input number is greater than 0x7fff then output is saturated to 0x7fff.
-else if input number is less than 0xffff8000 then output is saturated to 0xffff8000
-else output is same as input.
-*/
-int16
-qm_sat32(int32 op)
-{
-	int16 result;
-	if (op > (int32)0x7fff) {
-		result = 0x7fff;
-	}
-	else if (op < (int32)0xffff8000) {
-		result = (int16)(0x8000);
-	}
-	else {
-		result = (int16)op;
-	}
-	return result;
-}
-
-/*
-Description: This function multiply two input 16 bit numbers and return the 32 bit result.
-This multiplication is similar to compiler multiplication. This operation is defined if
-16 bit multiplication on the processor platform is cheaper than 32 bit multiplication (as
-the most of qmath functions can be replaced with processor intrinsic instructions).
-*/
-int32
-qm_mul321616(int16 op1, int16 op2)
-{
-	return ((int32)(op1)*(int32)(op2));
-}
-
-/*
-Description: This function make 16 bit multiplication and return the result in 16 bits.
-To fit the result into 16 bits the 32 bit multiplication result is right
-shifted by 16 bits.
-*/
-int16
-qm_mul16(int16 op1, int16 op2)
-{
-	int32 result;
-	result = ((int32)(op1)*(int32)(op2));
-	return ((int16)(result >> 16));
-}
-
-/*
-Description: This function multiply two 16 bit numbers and return the result in 32 bits.
-This function remove the extra sign bit created by the multiplication by leftshifting the
-32 bit multiplication result by 1 bit before returning the result. So the output is
-twice that of compiler multiplication. (i.e. qm_muls321616(2,3)=12).
-When both input 16 bit numbers are 0x8000, then the result is saturated to 0x7fffffff.
-*/
-int32
-qm_muls321616(int16 op1, int16 op2)
-{
-	int32 result;
-	if (op1 == (int16)(0x8000) && op2 == (int16)(0x8000)) {
-		result = 0x7fffffff;
-	}
-	else {
-		result = ((int32)(op1)*(int32)(op2));
-		result = result << 1;
-	}
-	return result;
-}
-
-/*
-Description: This function make 16 bit unsigned multiplication. To fit the output into
-16 bits the 32 bit multiplication result is right shifted by 16 bits.
-*/
-uint16
-qm_mulu16(uint16 op1, uint16 op2)
-{
-	return (uint16)(((uint32)op1 * (uint32)op2)>>16);
-}
-
-/*
-Description: This function make 16 bit multiplication and return the result in 16 bits.
-To fit the multiplication result into 16 bits the multiplication result is right shifted by
-15 bits. Right shifting 15 bits instead of 16 bits is done to remove the extra sign bit formed
-due to the multiplication.
-When both the 16bit inputs are 0x8000 then the output is saturated to 0x7fffffff.
-*/
-int16
-qm_muls16(int16 op1, int16 op2)
-{
-	int32 result;
-	if (op1 == (int16)0x8000 && op2 == (int16)0x8000) {
-		result = 0x7fffffff;
-	}
-	else {
-		result = ((int32)(op1)*(int32)(op2));
-	}
-	return ((int16)(result >> 15));
-}
-
-/*
-Description: This function add two 32 bit numbers and return the 32bit result.
-If the result overflow 32 bits, the output will be saturated to 32bits.
-*/
-int32
-qm_add32(int32 op1, int32 op2)
-{
-	int32 result;
-	result = op1 + op2;
-	if (op1 < 0 && op2 < 0 && result > 0) {
-		result = 0x80000000;
-	} else if (op1 > 0 && op2 > 0 && result < 0) {
-		result = 0x7fffffff;
-	}
-	return result;
-}
-
-/*
-Description: This function add two 16 bit numbers and return the 16bit result.
-If the result overflow 16 bits, the output will be saturated to 16bits.
-*/
-int16
-qm_add16(int16 op1, int16 op2)
-{
-	int16 result;
-	int32 temp = (int32)op1 + (int32)op2;
-	if (temp > (int32)0x7fff) {
-		result = (int16)0x7fff;
-	} else if (temp < (int32)0xffff8000) {
-		result = (int16)0xffff8000;
-	} else {
-		result = (int16) temp;
-	}
-	return result;
-}
-
-/*
-Description: This function make 16 bit subtraction and return the 16bit result.
-If the result overflow 16 bits, the output will be saturated to 16bits.
-*/
-int16
-qm_sub16(int16 op1, int16 op2)
-{
-	int16 result;
-	int32 temp = (int32)op1 - (int32)op2;
-	if (temp > (int32)0x7fff) {
-		result = (int16)0x7fff;
-	} else if (temp < (int32)0xffff8000) {
-		result = (int16)0xffff8000;
-	} else {
-		result = (int16) temp;
-	}
-	return result;
-}
-
-/*
-Description: This function make 32 bit subtraction and return the 32bit result.
-If the result overflow 32 bits, the output will be saturated to 32bits.
-*/
-int32
-qm_sub32(int32 op1, int32 op2)
-{
-	int32 result;
-	result = op1 - op2;
-	if (op1 >= 0 && op2 < 0 && result < 0) {
-		result = 0x7fffffff;
-	}
-	else if (op1 < 0 && op2 > 0 && result > 0)	{
-		result = 0x80000000;
-	}
-	return result;
-}
-
-/*
-Description: This function multiply input 16 bit numbers and accumulate the result
-into the input 32 bit number and return the 32 bit accumulated result.
-If the accumulation result in overflow, then the output will be saturated.
-*/
-int32
-qm_mac321616(int32 acc, int16 op1, int16 op2)
-{
-	int32 result;
-	result = qm_add32(acc, qm_mul321616(op1, op2));
-	return result;
-}
-
-/*
-Description: This function make a 32 bit saturated left shift when the specified shift
-is +ve. This function will make a 32 bit right shift when the specified shift is -ve.
-This function return the result after shifting operation.
-*/
-int32
-qm_shl32(int32 op, int shift)
-{
-	int i;
-	int32 result;
-	result = op;
-	if (shift > 31) shift = 31;
-	else if (shift < -31) shift = -31;
-	if (shift >= 0) {
-		for (i = 0; i < shift; i++) {
-			result = qm_add32(result, result);
-		}
-	}
-	else {
-		result = result >> (-shift);
-	}
-	return result;
-}
-
-/*
-Description: This function make a 32 bit right shift when shift is +ve.
-This function make a 32 bit saturated left shift when shift is -ve. This function
-return the result of the shift operation.
-*/
-int32
-qm_shr32(int32 op, int shift)
-{
-	return qm_shl32(op, -shift);
-}
-
-/*
-Description: This function make a 16 bit saturated left shift when the specified shift
-is +ve. This function will make a 16 bit right shift when the specified shift is -ve.
-This function return the result after shifting operation.
-*/
-int16
-qm_shl16(int16 op, int shift)
-{
-	int i;
-	int16 result;
-	result = op;
-	if (shift > 15) shift = 15;
-	else if (shift < -15) shift = -15;
-	if (shift > 0) {
-		for (i = 0; i < shift; i++) {
-			result = qm_add16(result, result);
-		}
-	}
-	else {
-		result = result >> (-shift);
-	}
-	return result;
-}
-
-/*
-Description: This function make a 16 bit right shift when shift is +ve.
-This function make a 16 bit saturated left shift when shift is -ve. This function
-return the result of the shift operation.
-*/
-int16
-qm_shr16(int16 op, int shift)
-{
-	return qm_shl16(op, -shift);
-}
-
-/*
-Description: This function return the number of redundant sign bits in a 16 bit number.
-Example: qm_norm16(0x0080) = 7.
-*/
-int16
-qm_norm16(int16 op)
-{
-	uint16 u16extraSignBits;
-	if (op == 0) {
-		return 15;
-	}
-	else {
-		u16extraSignBits = 0;
-		while ((op >> 15) == (op >> 14)) {
-			u16extraSignBits++;
-			op = op << 1;
-		}
-	}
-	return u16extraSignBits;
-}
-
-/*
-Description: This function return the number of redundant sign bits in a 32 bit number.
-Example: qm_norm32(0x00000080) = 23
-*/
-int16
-qm_norm32(int32 op)
-{
-	uint16 u16extraSignBits;
-	if (op == 0) {
-		return 31;
-	}
-	else {
-		u16extraSignBits = 0;
-		while ((op >> 31) == (op >> 30)) {
-			u16extraSignBits++;
-			op = op << 1;
-		}
-	}
-	return u16extraSignBits;
-}
-
-/*
-Description: This function divide two 16 bit unsigned numbers.
-The numerator should be less than denominator. So the quotient is always less than 1.
-This function return the quotient in q.15 format.
-*/
-int16
-qm_div_s(int16 num, int16 denom)
-{
-	int16 var_out;
-	int16 iteration;
-	int32 L_num;
-	int32 L_denom;
-	L_num = (num) << 15;
-	L_denom = (denom) << 15;
-	for (iteration = 0; iteration < 15; iteration++) {
-		L_num <<= 1;
-		if (L_num >= L_denom) {
-			L_num = qm_sub32(L_num, L_denom);
-			L_num = qm_add32(L_num, 1);
-		}
-	}
-	var_out = (int16)(L_num & 0x7fff);
-	return (var_out);
-}
-
-/*
-Description: This function compute the absolute value of a 16 bit number.
-*/
-int16
-qm_abs16(int16 op)
-{
-	if (op < 0) {
-		if (op == (int16)0xffff8000) {
-			return 0x7fff;
-		} else {
-			return -op;
-		}
-	}
-	else {
-		return op;
-	}
-}
-
-/*
-Description: This function divide two 16 bit numbers.
-The quotient is returned through return value.
-The qformat of the quotient is returned through the pointer (qQuotient) passed
-to this function. The qformat of quotient is adjusted appropriately such that
-the quotient occupies all 16 bits.
-*/
-int16
-qm_div16(int16 num, int16 denom, int16 *qQuotient)
-{
-	int16 sign;
-	int16 nNum, nDenom;
-	sign = num ^ denom;
-	num = qm_abs16(num);
-	denom = qm_abs16(denom);
-	nNum = qm_norm16(num);
-	nDenom = qm_norm16(denom);
-	num = qm_shl16(num, nNum-1);
-	denom = qm_shl16(denom, nDenom);
-	*qQuotient = nNum-1-nDenom+15;
-	if (sign >= 0)	{
-		return qm_div_s(num, denom);
-	}
-	else {
-		return -qm_div_s(num, denom);
-	}
-}
-
-/*
-Description: This function compute absolute value of a 32 bit number.
-*/
-int32
-qm_abs32(int32 op)
-{
-	if (op < 0) {
-		if (op == (int32)0x80000000) {
-			return 0x7fffffff;
-		} else {
-			return -op;
-		}
-	}
-	else {
-		return op;
-	}
-}
-
-/*
-Description: This function divide two 32 bit numbers. The division is performed
-by considering only important 16 bits in 32 bit numbers.
-The quotient is returned through return value.
-The qformat of the quotient is returned through the pointer (qquotient) passed
-to this function. The qformat of quotient is adjusted appropriately such that
-the quotient occupies all 16 bits.
-*/
-int16
-qm_div163232(int32 num, int32 denom, int16 *qquotient)
-{
-	int32 sign;
-	int16 nNum, nDenom;
-	sign = num ^ denom;
-	num = qm_abs32(num);
-	denom = qm_abs32(denom);
-	nNum = qm_norm32(num);
-	nDenom = qm_norm32(denom);
-	num = qm_shl32(num, nNum - 1);
-	denom = qm_shl32(denom, nDenom);
-	*qquotient = nNum - 1 - nDenom + 15;
-	if (sign >= 0)	{
-		return qm_div_s((int16)(num >> 16), (int16)(denom >> 16));
-	}
-	else {
-		return -qm_div_s((int16)(num >> 16), (int16)(denom >> 16));
-	}
-}
-
-/*
-Description: This function multiply a 32 bit number with a 16 bit number.
-The multiplicaton result is right shifted by 16 bits to fit the result
-into 32 bit output.
-*/
-int32
-qm_mul323216(int32 op1, int16 op2)
-{
-	int16 hi;
-	uint16 lo;
-	int32 result;
-	hi = op1 >> 16;
-	lo = (int16)(op1 & 0xffff);
-	result = qm_mul321616(hi, op2);
-	result = result + (qm_mulsu321616(op2, lo) >> 16);
-	return result;
-}
-
-/*
-Description: This function multiply signed 16 bit number with unsigned 16 bit number and return
-the result in 32 bits.
-*/
-int32
-qm_mulsu321616(int16 op1, uint16 op2)
-{
-	return (int32)(op1) * op2;
-}
-
-/*
-Description: This function multiply 32 bit number with 16 bit number. The multiplication result is
-right shifted by 15 bits to fit the result into 32 bits. Right shifting by only 15 bits instead of
-16 bits is done to remove the extra sign bit formed by multiplication from the return value.
-When the input numbers are 0x80000000, 0x8000 the return value is saturated to 0x7fffffff.
-*/
-int32
-qm_muls323216(int32 op1, int16 op2)
-{
-	int16 hi;
-	uint16 lo;
-	int32 result;
-	hi = op1 >> 16;
-	lo = (int16)(op1 & 0xffff);
-	result = qm_muls321616(hi, op2);
-	result = qm_add32(result, (qm_mulsu321616(op2, lo) >> 15));
-	return result;
-}
-
-/*
-Description: This function multiply two 32 bit numbers. The multiplication result is right
-shifted by 32 bits to fit the multiplication result into 32 bits. The right shifted
-multiplication result is returned as output.
-*/
-int32
-qm_mul32(int32 a, int32 b)
-{
-	int16 hi1, hi2;
-	uint16 lo1, lo2;
-	int32 result;
-	hi1 = a >> 16;
-	hi2 = b >> 16;
-	lo1 = (uint16)(a & 0xffff);
-	lo2 = (uint16)(b & 0xffff);
-	result = qm_mul321616(hi1, hi2);
-	result = result + (qm_mulsu321616(hi1, lo2) >> 16);
-	result = result + (qm_mulsu321616(hi2, lo1) >> 16);
-	return result;
-}
-
-/*
-Description: This function multiply two 32 bit numbers. The multiplication result is
-right shifted by 31 bits to fit the multiplication result into 32 bits. The right
-shifted multiplication result is returned as output. Right shifting by only 31 bits
-instead of 32 bits is done to remove the extra sign bit formed by multiplication.
-When the input numbers are 0x80000000, 0x80000000 the return value is saturated to
-0x7fffffff.
-*/
-int32
-qm_muls32(int32 a, int32 b)
-{
-	int16 hi1, hi2;
-	uint16 lo1, lo2;
-	int32 result;
-	hi1 = a >> 16;
-	hi2 = b >> 16;
-	lo1 = (uint16)(a & 0xffff);
-	lo2 = (uint16)(b & 0xffff);
-	result = qm_muls321616(hi1, hi2);
-	result = qm_add32(result, (qm_mulsu321616(hi1, lo2) >> 15));
-	result = qm_add32(result, (qm_mulsu321616(hi2, lo1) >> 15));
-	result = qm_add32(result, (qm_mulu16(lo1, lo2) >> 15));
-	return result;
-}
-
-/* This table is log2(1+(i/32)) where i=[0:1:31], in q.15 format */
-static const int16 log_table[] = {
-0,
-1455,
-2866,
-4236,
-5568,
-6863,
-8124,
-9352,
-10549,
-11716,
-12855,
-13968,
-15055,
-16117,
-17156,
-18173,
-19168,
-20143,
-21098,
-22034,
-22952,
-23852,
-24736,
-25604,
-26455,
-27292,
-28114,
-28922,
-29717,
-30498,
-31267,
-32024
-};
-#define LOG_TABLE_SIZE 32		/* log_table size */
-#define LOG2_LOG_TABLE_SIZE 5	/* log2(log_table size) */
-#define Q_LOG_TABLE 15			/* qformat of log_table */
-#define LOG10_2		19728		/* log10(2) in q.16 */
-
-/*
-Description:
-This routine takes the input number N and its q format qN and compute
-the log10(N). This routine first normalizes the input no N.	Then N is in mag*(2^x) format.
-mag is any number in the range 2^30-(2^31 - 1). Then log2(mag * 2^x) = log2(mag) + x is computed.
-From that log10(mag * 2^x) = log2(mag * 2^x) * log10(2) is computed.
-This routine looks the log2 value in the table considering LOG2_LOG_TABLE_SIZE+1 MSBs.
-As the MSB is always 1, only next LOG2_OF_LOG_TABLE_SIZE MSBs are used for table lookup.
-Next 16 MSBs are used for interpolation.
-Inputs:
-N - number to which log10 has to be found.
-qN - q format of N
-log10N - address where log10(N) will be written.
-qLog10N - address where log10N qformat will be written.
-Note/Problem:
-For accurate results input should be in normalized or near normalized form.
-*/
-void
-qm_log10(int32 N, int16 qN, int16 *log10N, int16 *qLog10N)
-{
-	int16 s16norm, s16tableIndex, s16errorApproximation;
-	uint16 u16offset;
-	int32 s32log;
-
-	/* Logerithm of negative values is undefined.
-	* assert N is greater than 0.
-	*/
-	/* ASSERT(N > 0); */
-
-	/* normalize the N. */
-	s16norm = qm_norm32(N);
-	N = N << s16norm;
-
-	/* The qformat of N after normalization.
-	* -30 is added to treat the no as between 1.0 to 2.0
-	* i.e. after adding the -30 to the qformat the decimal point will be
-	* just rigtht of the MSB. (i.e. after sign bit and 1st MSB). i.e.
-	* at the right side of 30th bit.
-	*/
-	qN = qN + s16norm - 30;
-
-	/* take the table index as the LOG2_OF_LOG_TABLE_SIZE bits right of the MSB */
-	s16tableIndex = (int16)(N >> (32-(2+LOG2_LOG_TABLE_SIZE)));
-
-	/* remove the MSB. the MSB is always 1 after normalization. */
-	s16tableIndex = s16tableIndex & (int16)((1<<LOG2_LOG_TABLE_SIZE)-1);
-
-	/* remove the (1+LOG2_OF_LOG_TABLE_SIZE) MSBs in the N. */
-	N = N & ((1<<(32-(2+LOG2_LOG_TABLE_SIZE))) - 1);
-
-	/* take the offset as the 16 MSBS after table index.
-	*/
-	u16offset = (uint16)(N >> (32-(2+LOG2_LOG_TABLE_SIZE+16)));
-
-	/* look the log value in the table. */
-	s32log = log_table[s16tableIndex];		/* q.15 format */
-
-	/* interpolate using the offset. */
-	s16errorApproximation = (int16)qm_mulu16(u16offset,
-		(uint16)(log_table[s16tableIndex+1]-log_table[s16tableIndex])); /* q.15 */
-
-	s32log = qm_add16((int16)s32log, s16errorApproximation);	/* q.15 format */
-
-	/* adjust for the qformat of the N as
-	* log2(mag * 2^x) = log2(mag) + x
-	*/
-	s32log = qm_add32(s32log, ((int32)-qN)<<15);		/* q.15 format */
-
-	/* normalize the result. */
-	s16norm = qm_norm32(s32log);
-
-	/* bring all the important bits into lower 16 bits */
-	s32log = qm_shl32(s32log, s16norm-16);		/* q.15+s16norm-16 format */
-
-	/* compute the log10(N) by multiplying log2(N) with log10(2).
-	* as log10(mag * 2^x) = log2(mag * 2^x) * log10(2)
-	* log10N in q.15+s16norm-16+1 (LOG10_2 is in q.16)
-	*/
-	*log10N = qm_muls16((int16)s32log, (int16)LOG10_2);
-
-	/* write the q format of the result. */
-	*qLog10N = 15 + s16norm - 16 + 1;
-
-	return;
-}
-
-/*
-Description:
-This routine compute 1/N.
-This routine reformates the given no N as N * 2^qN where N is in between 0.5 and 1.0
-in q.15 format in 16 bits. So the problem now boils down to finding the inverse of a
-q.15 no in 16 bits which is in the range of 0.5 to 1.0. The output is always between
-2.0 to 1. So the output is 2.0 to 1.0 in q.30 format. Once the final output format is found
-by taking the qN into account. Inverse is found with newton rapson method. Initially
-inverse (x) is guessed as 1/0.75 (with appropriate sign). The new guess is calculated
-using the formula x' = 2*x - N*x*x. After 4 or 5 iterations the inverse is very close to
-inverse of N.
-Inputs:
-N - number to which 1/N has to be found.
-qn - q format of N.
-sqrtN - address where 1/N has to be written.
-qsqrtN - address where q format of 1/N has to be written.
-*/
-#define qx 29
-void
-qm_1byN(int32 N, int16 qN, int32 *result, int16 *qResult)
-{
-	int16 normN;
-	int32 s32firstTerm, s32secondTerm, x;
-	int i;
-
-	normN = qm_norm32(N);
-
-	/* limit N to least significant 16 bits. 15th bit is the sign bit. */
-	N = qm_shl32(N, normN-16);
-	qN = qN + normN - 16 - 15;
-	/* -15 is added to treat N as 16 bit q.15 number in the range from 0.5 to 1 */
-
-	/* Take the initial guess as 1/0.75 in qx format with appropriate sign. */
-	if (N >= 0)
-	{
-		x = (int32)((1/0.75)*(1<<qx));
-		/* input no is in the range 0.5 to 1. So 1/0.75 is taken as initial guess. */
-	}
-	else
-	{
-		x = (int32)((1/-0.75)*(1<<qx));
-		/* input no is in the range -0.5 to -1. So 1/-0.75 is taken as initial guess. */
-	}
-
-	/* iterate the equation x = 2*x - N*x*x for 4 times. */
-	for (i = 0; i < 4; i++)
-	{
-		s32firstTerm = qm_shl32(x, 1); /* s32firstTerm = 2*x in q.29 */
-		s32secondTerm = qm_muls321616((int16)(s32firstTerm>>16), (int16)(s32firstTerm>>16));
-		/* s32secondTerm = x*x in q.(29+1-16)*2+1 */
-		s32secondTerm = qm_muls321616((int16)(s32secondTerm>>16), (int16)N);
-		/* s32secondTerm = N*x*x in q.((29+1-16)*2+1)-16+15+1 i.e. in q.29 */
-		x = qm_sub32(s32firstTerm, s32secondTerm);
-		/* can be added directly as both are in q.29 */
-	}
-
-	/* Bring the x to q.30 format. */
-	*result = qm_shl32(x, 1);
-	/* giving the output in q.30 format for q.15 input in 16 bits. */
-
-	/* compute the final q format of the result. */
-	*qResult = -qN + 30;	/* adjusting the q format of actual output */
-
-	return;
-}
-#undef qx
diff -Nuar merlin-bkp/shared/spiflash.c merlin-new/shared/spiflash.c
--- merlin-bkp/shared/spiflash.c	2013-11-30 08:31:43.000000000 +0100
+++ merlin-new/shared/spiflash.c	2014-02-24 14:15:11.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * Broadcom QSPI serial flash interface
  *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * Copyright (C) 2014, Broadcom Corporation. All Rights Reserved.
  * 
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -284,7 +284,7 @@
 #define ID_SST25VF040       0x44
 #define ID_SST25VF080       0x80
 
-/* NexFlash's manufacturer ID */
+/* Winbond/NexFlash's manufacturer ID */
 #define NXPART              0xEF
 
 /* A list of NexFlash device ID's - add others as needed */
@@ -735,11 +735,14 @@
 	case SPANPART:
 	case MACRONIXPART:
 	case NUMONYXPART:
+	case NXPART:
 		/* ST compatible */
 		if (vendor_id == SPANPART)
 			name = "ST compatible";
 		else if (vendor_id == MACRONIXPART)
 			name = "ST compatible (Marconix)";
+		else if (vendor_id == NXPART)
+			name = "ST compatible (Winbond/NexFlash)";
 		else
 			name = "ST compatible (Micron)";
 
