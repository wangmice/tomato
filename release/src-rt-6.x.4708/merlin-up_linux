diff -Nuar merlin-bkp/linux/linux-2.6.36/arch/arm/mach-brcm-hnd/board_ns.c merlin-new/linux/linux-2.6.36/arch/arm/mach-brcm-hnd/board_ns.c
--- merlin-bkp/linux/linux-2.6.36/arch/arm/mach-brcm-hnd/board_ns.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/arch/arm/mach-brcm-hnd/board_ns.c	2014-02-24 14:15:11.000000000 +0100
@@ -251,7 +251,7 @@
 	if (lo_size == mem_size)
 		return;
 
-	mi->bank[1].start = PHYS_OFFSET2 + lo_size;
+	mi->bank[1].start = PHYS_OFFSET2;
 	mi->bank[1].size = mem_size - lo_size;
 	mi->nr_banks++;
 }
@@ -532,6 +532,12 @@
 		/* Setup kernel MTD partition */
 		bcm947xx_flash_parts[nparts].name = "linux";
 #ifdef CONFIG_FAILSAFE_UPGRADE
+		if (trx_size > (image_second_offset-image_first_offset)) {
+			printk("sflash size is too small to afford two images.\n");
+			dual_image_on = 0;
+			image_first_offset = 0;
+			image_second_offset = 0;
+		}
 		if (dual_image_on) {
 			bcm947xx_flash_parts[nparts].size = image_second_offset-image_first_offset;
 		} else {
@@ -600,6 +606,12 @@
 		if (dual_image_on) {
 			offset = image_second_offset;
 			rfs_off = lookup_flash_rootfs_offset(mtd, &offset, size, &trx_size);
+			/* When the second image doesn't exist,
+			 * set the rootfs use the same offset with the kernel
+			 */
+			if (rfs_off == size)
+				rfs_off = offset;
+
 			vmlz_off = offset;
 			/* Setup kernel2 MTD partition */
 			bcm947xx_flash_parts[nparts].name = "linux2";
diff -Nuar merlin-bkp/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_dmu.c merlin-new/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_dmu.c
--- merlin-bkp/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_dmu.c	2013-11-30 08:31:21.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_dmu.c	2014-02-24 14:15:11.000000000 +0100
@@ -6,7 +6,7 @@
  * Documents:
  * Northstar_top_power_uarch_v1_0.pdf
  *
- * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * Copyright (C) 2014, Broadcom Corporation. All Rights Reserved.
  * 
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -390,6 +390,8 @@
 static void __init soc_clocks_init(void * __iomem cru_regs_base,
 	struct clk * clk_ref)
 {
+	void * __iomem reg;
+	u32 val;
 
 	/* registers are already mapped with the rest of DMU block */
 	/* Update register base address */
@@ -413,6 +415,40 @@
 
 	/* Install clock sources into the lookup table */
 	clkdev_add_table(soc_clk_lookups, ARRAY_SIZE(soc_clk_lookups));
+
+	/* Correct GMAC 2.66G line rate issue, it should be 2Gbps */
+	/* This incorrect setting only exist in OTP present 4708 chip */
+	/* is a OTPed 4708 chip which Ndiv == 0x50 */
+	reg = clk_genpll.regs_base + 0x14;
+	val = readl(reg);
+	if (((val >> 20) & 0x3ff) == 0x50) {
+		/* CRU_CLKSET_KEY, unlock */
+		reg = clk_genpll.regs_base + 0x40;
+		val = 0x0000ea68;
+		writel(val, reg);
+
+		/* Change CH0_MDIV to 8 */
+		reg = clk_genpll.regs_base + 0x18;
+		val = readl(reg);
+		val &= ~((u32)0xff << 16);
+		val |= ((u32)0x8 << 16);
+		writel(val, reg);
+
+		/* Load Enable CH0 */
+		reg = clk_genpll.regs_base + 0x4;
+		val = readl(reg);
+		val &= ~(u32)0x1;
+		writel(val, reg);
+		val |= (u32)0x1;
+		writel(val, reg);
+		val &= ~(u32)0x1;
+		writel(val, reg);
+
+		/* CRU_CLKSET_KEY, lock */
+		reg = clk_genpll.regs_base + 0x40;
+		val = 0x0;
+		writel(val, reg);
+	}
 }
 
 void __init soc_dmu_init(struct clk *clk_ref)
diff -Nuar merlin-bkp/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_pcie.c merlin-new/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_pcie.c
--- merlin-bkp/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_pcie.c	2013-11-30 08:31:21.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/arch/arm/plat-brcm/bcm5301x_pcie.c	2014-02-24 14:15:11.000000000 +0100
@@ -776,7 +776,7 @@
 	__raw_writel(addr | size,
 		port->reg_base + SOC_PCIE_SYS_IARR(1));
 #ifdef CONFIG_SPARSEMEM
-	addr = PHYS_OFFSET2 + SZ_128M;
+	addr = PHYS_OFFSET2;
 	__raw_writel(addr | 0x1,
 		port->reg_base + SOC_PCIE_SYS_IMAP2(0));
 	__raw_writel(addr | size,
@@ -1280,6 +1280,70 @@
 	REG_UNMAP((void *)dmu_base);
 }
 
+static void __init
+bcm5301x_pcie_phy_init(void)
+{
+	uint32 ccb_mii_base;
+	uint32 *ccb_mii_mng_ctrl_addr;
+	uint32 *ccb_mii_mng_cmd_data_addr;
+	uint32 dmu_base, cru_straps_ctrl;
+	uint32 blkaddr = 0x863, regaddr;
+	uint32 sb = 1, op_w = 1, pa[3] = {0x0, 0x1, 0xf}, blkra = 0x1f, ta = 2;
+	uint32 i, val;
+
+	/* Check Chip ID */
+	if (!BCM4707_CHIP(CHIPID(sih->chip)))
+		return;
+
+	/* Reg map */
+	dmu_base = (uint32)REG_MAP(0x1800c000, 4096);
+	ccb_mii_base = (uint32)REG_MAP(0x18003000, 4096);
+	ccb_mii_mng_ctrl_addr = (uint32 *)ccb_mii_base;
+	ccb_mii_mng_cmd_data_addr = (uint32 *)(ccb_mii_base + 0x4);
+
+	/* Set MDC/MDIO for Internal phy */
+	SPINWAIT(((readl(ccb_mii_mng_ctrl_addr) >> 8 & 1) == 1), 1000);
+	writel(0x0000009a, ccb_mii_mng_ctrl_addr);
+
+	/* To improve PCIE phy jitter */
+	for (i = 0; i < (ARRAY_SIZE(soc_pcie_ports) - 1); i++) {
+		if (i == 2) {
+			cru_straps_ctrl = readl((uint32 *)(dmu_base + 0x2a0));
+
+			/* 3rd PCIE is not selected */
+			if (cru_straps_ctrl & 0x10)
+				break;
+		}
+
+		/* Change blkaddr */
+		SPINWAIT(((readl(ccb_mii_mng_ctrl_addr) >> 8 & 1) == 1), 1000);
+		val = (sb << 30) | (op_w << 28) | (pa[i] << 23) | (blkra << 18) |
+			(ta << 16) | (blkaddr << 4);
+		writel(val, ccb_mii_mng_cmd_data_addr);
+
+		/* Write 0x0190 to 0x13 regaddr */
+		SPINWAIT(((readl(ccb_mii_mng_ctrl_addr) >> 8 & 1) == 1), 1000);
+		regaddr = 0x13;
+		val = (sb << 30) | (op_w << 28) | (pa[i] << 23) | (regaddr << 18) |
+			(ta << 16) | 0x0190;
+		writel(val, ccb_mii_mng_cmd_data_addr);
+
+		/* Write 0x0191 to 0x19 regaddr */
+		SPINWAIT(((readl(ccb_mii_mng_ctrl_addr) >> 8 & 1) == 1), 1000);
+		regaddr = 0x19;
+		val = (sb << 30) | (op_w << 28) | (pa[i] << 23) | (regaddr << 18) |
+			(ta << 16) | 0x0191;
+		writel(val, ccb_mii_mng_cmd_data_addr);
+	}
+
+	/* Waiting MII Mgt interface idle */
+	SPINWAIT((((readl(ccb_mii_mng_ctrl_addr) >> 8) & 1) == 1), 1000);
+
+	/* Reg unmap */
+	REG_UNMAP((void *)dmu_base);
+	REG_UNMAP((void *)ccb_mii_base);
+}
+
 static int __init soc_pcie_init(void)
 {
 	unsigned int i;
@@ -1292,6 +1356,9 @@
 	pci_scan_bus(0, &pcibios_ops, &soc_pcie_ports[0].hw_pci);
 
 	bcm5301x_3rd_pcie_init();
+
+	bcm5301x_pcie_phy_init();
+
 	for (i = 1; i < ARRAY_SIZE(soc_pcie_ports); i++) {
 		struct soc_pcie_port *port = &soc_pcie_ports[i];
 
diff -Nuar merlin-bkp/linux/linux-2.6.36/arch/arm/plat-brcm/include/mach/memory.h merlin-new/linux/linux-2.6.36/arch/arm/plat-brcm/include/mach/memory.h
--- merlin-bkp/linux/linux-2.6.36/arch/arm/plat-brcm/include/mach/memory.h	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/arch/arm/plat-brcm/include/mach/memory.h	2014-02-24 14:15:11.000000000 +0100
@@ -29,7 +29,7 @@
 #define CONSISTENT_DMA_SIZE     SZ_128M
 
 /* 2nd physical memory window */
-#define PHYS_OFFSET2		0x90000000
+#define PHYS_OFFSET2		0x98000000
 
 #if !defined(__ASSEMBLY__) && defined(CONFIG_ZONE_DMA)
 extern void bcm47xx_adjust_zones(unsigned long *size, unsigned long *hole);
@@ -50,11 +50,11 @@
 
 #define __phys_to_virt(phys)						\
 	((phys) >= PHYS_OFFSET2 ? (phys) - PHYS_OFFSET2 + PAGE_OFFSET1 :	\
-	 (phys) + PAGE_OFFSET)
+	 (phys) - PHYS_OFFSET + PAGE_OFFSET)
 
 #define __virt_to_phys(virt)						\
 	 ((virt) >= PAGE_OFFSET1 ? (virt) - PAGE_OFFSET1 + PHYS_OFFSET2 :	\
-	  (virt) - PAGE_OFFSET)
+	  (virt) - PAGE_OFFSET + PHYS_OFFSET)
 
 #else
 #define __virt_to_phys(x)	((x) - PAGE_OFFSET + PHYS_OFFSET)
diff -Nuar merlin-bkp/linux/linux-2.6.36/config_base merlin-new/linux/linux-2.6.36/config_base
--- merlin-bkp/linux/linux-2.6.36/config_base	2014-02-06 08:39:45.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/config_base	2014-02-24 14:15:11.000000000 +0100
@@ -886,6 +886,7 @@
 CONFIG_MTD_BCMSFLASH=y
 CONFIG_MTD_BRCMNAND=y
 CONFIG_MTD_NFLASH=y
+# CONFIG_LINUX_MTD is not set
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
 # CONFIG_BLK_CPQ_DA is not set
diff -Nuar merlin-bkp/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/bcm_nflash.c merlin-new/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/bcm_nflash.c
--- merlin-bkp/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/bcm_nflash.c	2014-01-09 20:07:05.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/bcm_nflash.c	2014-02-24 14:15:11.000000000 +0100
@@ -62,6 +62,7 @@
 struct mtd_partition *nflash_parts;
 #endif
 
+int nospare;
 /* Mutexing is version-dependent */
 extern struct nand_hw_control *nand_hwcontrol_lock_init(void);
 
diff -Nuar merlin-bkp/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/Kconfig merlin-new/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/Kconfig
--- merlin-bkp/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/Kconfig	2013-11-30 08:31:22.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/drivers/mtd/bcm947xx/nand/Kconfig	2014-02-24 14:15:11.000000000 +0100
@@ -15,3 +15,9 @@
 	bool "Broadcom Flash support for legacy MTD partition"
 	help
 	  This enables support for Broadcom legacy MTD partition.
+
+config LINUX_MTD
+	int "Linux MTD size (MB)"
+	default "32"
+	help
+	  This can change MTD SIZE (MB), ASUS support!
diff -Nuar merlin-bkp/linux/linux-2.6.36/drivers/net/wl/wl_generic.mk merlin-new/linux/linux-2.6.36/drivers/net/wl/wl_generic.mk
--- merlin-bkp/linux/linux-2.6.36/drivers/net/wl/wl_generic.mk	2013-11-30 08:31:23.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/drivers/net/wl/wl_generic.mk	2014-02-24 14:15:11.000000000 +0100
@@ -7,8 +7,7 @@
 # $Id: wl_generic.mk,v 1.10 2011-01-21 22:12:09 $
 #
 
-#REBUILD_WL_MODULE=$(shell if [ -d "$(src)/$(SRCBASE_OFFSET)/wl/sys" -a "$(REUSE_PREBUILT_WL)" != "1" ]; then echo 1; else echo 0; fi)
-REBUILD_WL_MODULE=0
+REBUILD_WL_MODULE=$(shell if [ -d "$(src)/$(SRCBASE_OFFSET)/wl/sys" -a "$(REUSE_PREBUILT_WL)" != "1" ]; then echo 1; else echo 0; fi)
 
 # If source directory (src/wl/sys) exists and REUSE_PREBUILT_WL is undefined, 
 # then build inside $(SRCBASE_OFFSET)/wl/sys, otherwise use pre-builts
@@ -92,8 +91,8 @@
 else # SRCBASE/wl/sys doesn't exist
 
     # Otherwise, assume prebuilt object module(s) in src/wl/linux directory
-    #prebuilt := wl_$(wl_suffix).o
-    $(TARGET)-objs := $(SRCBASE_OFFSET)/wl/linux/wl.o
+    prebuilt := wl_$(wl_suffix).o
+    $(TARGET)-objs := $(SRCBASE_OFFSET)/wl/linux/$(prebuilt)
     obj-$(CONFIG_WL) := $(TARGET).o
 
     ifeq ("$(CONFIG_WL_USBAP)","y")
diff -Nuar merlin-bkp/linux/linux-2.6.36/drivers/usb/host/xhci-ring.c merlin-new/linux/linux-2.6.36/drivers/usb/host/xhci-ring.c
--- merlin-bkp/linux/linux-2.6.36/drivers/usb/host/xhci-ring.c	2013-11-30 08:31:24.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/drivers/usb/host/xhci-ring.c	2014-02-24 14:15:11.000000000 +0100
@@ -145,26 +145,36 @@
  */
 static void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring, bool consumer)
 {
-	union xhci_trb *next = ++(ring->dequeue);
 	unsigned long long addr;
 
 	ring->deq_updates++;
-	/* Update the dequeue pointer further if that was a link TRB or we're at
-	 * the end of an event ring segment (which doesn't have link TRBS)
-	 */
-	while (last_trb(xhci, ring, ring->deq_seg, next)) {
-		if (consumer && last_trb_on_last_seg(xhci, ring, ring->deq_seg, next)) {
-			ring->cycle_state = (ring->cycle_state ? 0 : 1);
-			if (!in_interrupt())
-				xhci_dbg(xhci, "Toggle cycle state for ring %p = %i\n",
-						ring,
-						(unsigned int) ring->cycle_state);
+
+	do {
+		/* Update the dequeue pointer further if that was a link TRB or
+		 * we're at the end of an event ring segment (which doesn't have
+		 * link TRBS)
+		 */
+		if (last_trb(xhci, ring, ring->deq_seg, ring->dequeue)) {
+			if (consumer && last_trb_on_last_seg(xhci, ring,
+				ring->deq_seg, ring->dequeue)) {
+				if (!in_interrupt())
+					xhci_dbg(xhci, "Toggle cycle state "
+									"for ring %p = %i\n",
+									ring,
+									(unsigned int)
+									ring->cycle_state);
+				ring->cycle_state = (ring->cycle_state ? 0 : 1);
+			}
+			ring->deq_seg = ring->deq_seg->next;
+			ring->dequeue = ring->deq_seg->trbs;
+		}
+		else {
+			ring->dequeue++;
 		}
-		ring->deq_seg = ring->deq_seg->next;
-		ring->dequeue = ring->deq_seg->trbs;
-		next = ring->dequeue;
-	}
+	} while (last_trb(xhci, ring, ring->deq_seg, ring->dequeue));
+
 	addr = (unsigned long long) xhci_trb_virt_to_dma(ring->deq_seg, ring->dequeue);
+
 	if (ring == xhci->event_ring)
 		xhci_dbg(xhci, "Event ring deq = 0x%llx (DMA)\n", addr);
 	else if (ring == xhci->cmd_ring)
diff -Nuar merlin-bkp/linux/linux-2.6.36/Makefile merlin-new/linux/linux-2.6.36/Makefile
--- merlin-bkp/linux/linux-2.6.36/Makefile	2014-02-06 08:39:45.000000000 +0100
+++ merlin-new/linux/linux-2.6.36/Makefile	2014-02-24 14:15:11.000000000 +0100
@@ -572,6 +572,16 @@
 KBUILD_CFLAGS	+= -O2
 endif
 
+ifeq ($(CONFIG_LINUX_MTD),32)
+KBUILD_CFLAGS += -D"CONFIG_LINUX_MTD=32"
+endif
+ifeq ($(CONFIG_LINUX_MTD),64)
+KBUILD_CFLAGS += -D"CONFIG_LINUX_MTD=64"
+endif
+ifeq ($(CONFIG_LINUX_MTD),128)
+KBUILD_CFLAGS += -D"CONFIG_LINUX_MTD=128"
+endif
+
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
 ifneq ($(CONFIG_FRAME_WARN),0)
