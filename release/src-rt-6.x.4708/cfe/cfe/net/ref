92c92,99
< #define TFTP_RECV_TIMEOUT	CFE_HZ*5	/* ticks */
---
> //#define TFTP_RECV_TIMEOUT	CFE_HZ*5	/* ticks */
> #define TFTP_RECV_TIMEOUT	CFE_HZ*1	/* ticks */
> 
> #ifdef RESCUE_MODE
> unsigned char tftpipfrom[4] = { 0xc0, 0xa8, 0x01, 0x01 };
> unsigned char tftpipto[4] = { 0xc0, 0xa8, 0x01, 0x01 };
> uint16_t ackport = 7777;
> #endif
126a134,136
> #ifdef RESCUE_MODE
> extern int send_rescueack(unsigned short no, unsigned short lo);
> #endif
151a162,214
> #ifdef RESCUE_MODE
> #define ip_addriszero(a) (((a)[0]|(a)[1]|(a)[2]|(a)[3]) == 0)
> static void ui_myshowifconfig(void)
> {
>         char *devname;
>         uint8_t *addr;
> 
>         devname = (char *) net_getparam(NET_DEVNAME);
>         if (devname == NULL) {
>                 xprintf("Network interface has not been configured\n");
>                 return;
>         }
>         xprintf("Device %s: ",devname);
>         addr = net_getparam(NET_HWADDR);
>         if (addr)
>                 xprintf(" hwaddr %a",addr);
>         addr = net_getparam(NET_IPADDR);
>         if (addr) {
>                 if (ip_addriszero(addr))
>                         xprintf(", ipaddr not set");
>                 else
>                         xprintf(", ipaddr %I",addr);
>         }
>         addr = net_getparam(NET_NETMASK);
>         if (addr) {
>                 if (ip_addriszero(addr))
>                         xprintf(", mask not set");
>                 else
>                         xprintf(", mask %I",addr);
>         }
>         xprintf("\n");
>         xprintf("        ");
>         addr = net_getparam(NET_GATEWAY);
>         if (addr) {
>                 if (ip_addriszero(addr))
>                         xprintf("gateway not set");
>                 else
>                         xprintf("gateway %I",addr);
>         }
>         addr = net_getparam(NET_NAMESERVER);
>         if (addr) {
>                 if (ip_addriszero(addr))
>                         xprintf(", nameserver not set");
>         else
>                 xprintf(", nameserver %I",addr);
>         }
>         addr = net_getparam(NET_DOMAIN);
>         if (addr) {
>                 xprintf(", domain %s",addr);
>         }
>         xprintf("\n");
> }
> #endif
311a375,384
> #ifdef RESCUE_MODE
>     if (info->tftp_lastblock) {
>         xprintf("- Last block -\n");
>         return 1;
>     }
>     if (info->tftp_error) {
>         xprintf("break !! tftp_error !!\n");
>         return CFE_ERR_TIMEOUT;
>     }
> #else
313a387
> #endif
337c411,419
< 	if (buf == NULL) continue;
---
> #ifdef RESCUE_MODE
>         if (!buf)
>         {
>                 xprintf("break! no netctx or timer expired ! \n");
>                 continue;
>         }
> #else
>         if (buf == NULL) continue;
> #endif
370a453,455
> #ifdef RESCUE_MODE
>         xprintf("break!! reach max retry!!\n");
> #endif
375a461,463
> #ifdef RESCUE_MODE
>         xprintf("- last blk -\n");
> #endif
413d500
< 
490a578,586
> #ifdef RESCUE_MODE
>         uint8_t asuslink[13] = "ASUSSPACELINK";
>         uint8_t maclink[13]="snxxxxxxxxxxx";
>         unsigned char tftpmask[4] = { 0xff, 0xff, 0xff, 0x00 };
>         int i;
>         char tftpnull;
>         uint8_t ipaddr[4] = { 0xc0, 0xa8, 0x01, 0x0c };
>         uint8_t hwaddr[6] = { 0x00, 0xe0, 0x18, 0x00, 0x3e, 0xc4 };
> #endif
510c606
<     for (retries = 0; retries < tftp_max_retries; retries++) {
---
>     for (retries = 0; retries < 2; retries++) {
530a627,704
> #ifdef RESCUE_MODE
>                          udp_connect(info->tftp_socket,(uint16_t) buf->eb_usrdata);
>                          ackport = buf->eb_usrdata;
>                          memcpy(info->tftp_ipaddr,buf->eb_usrptr,IP_ADDR_LEN);
>                          info->tftp_blknum = 1;
>                          info->tftp_blklen = 0;
>                          for (i=0; i<13; i++) {
>                                 if (buf->eb_ptr[i] != asuslink[i])
>                                                 break;
>                          }
>                          if (i==13) {
>                                 tftpipfrom[0]=buf->eb_ptr[16];
>                                 tftpipfrom[1]=buf->eb_ptr[15];
>                                 tftpipfrom[2]=buf->eb_ptr[14];
>                                 tftpipfrom[3]=buf->eb_ptr[13];
>                                 tftpipto[0]=buf->eb_usrptr[0];
>                                 tftpipto[1]=buf->eb_usrptr[1];
>                                 tftpipto[2]=buf->eb_usrptr[2];
>                                 tftpipto[3]=buf->eb_usrptr[3];
>                                         net_setparam(NET_IPADDR,tftpipfrom);
>                                         net_setparam(NET_NETMASK,tftpmask);
>                                         net_setparam(NET_GATEWAY,tftpipfrom);
>                                         ui_myshowifconfig();
>                                         net_setnetvars();
>                                         for (i=0; i<4; i++)
>                                                 ipaddr[i]=tftpipto[i];
>                                         for (i=0; i<6; i++)
>                                                 hwaddr[i]=buf->eb_data[6+i];
>                                         buf = udp_alloc();
>                                         if (!buf) {
>                                                 res = CFE_ERR_TIMEOUT;
>                                                 break;
>                                         }
>                                         ebuf_append_u16_be(buf, 3);
>                                         ebuf_append_u16_be(buf, 1);
>                                         ebuf_append_bytes(buf,&tftpnull, 0);
>                                         arp_delete(ipaddr);
>                                         arp_add(ipaddr,hwaddr);
>                                         udp_send(info->tftp_socket, buf, tftpipto);
>                                 }
>                                 else {
>                                         for (i=0; i<13; i++) {
>                                                 if (buf->eb_ptr[i] != maclink[i])
>                                                         break;
>                                         }
>                                         if (i==13) {
>                                                 tftpipfrom[0]=buf->eb_ptr[16];
>                                                 tftpipfrom[1]=buf->eb_ptr[15];
>                                                 tftpipfrom[2]=buf->eb_ptr[14];
>                                                 tftpipfrom[3]=buf->eb_ptr[13];
>                                                 tftpipto[0]=buf->eb_usrptr[0];
>                                                 tftpipto[1]=buf->eb_usrptr[1];
>                                                 tftpipto[2]=buf->eb_usrptr[2];
>                                                 tftpipto[3]=buf->eb_usrptr[3];
>                                                 net_setparam(NET_IPADDR,tftpipfrom);
>                                                 net_setparam(NET_NETMASK,tftpmask);
>                                                 net_setparam(NET_GATEWAY,tftpipfrom);
>                                                 ui_myshowifconfig();
>                                                 net_setnetvars();
>                                                 for (i=0; i<4; i++)
>                                                         ipaddr[i]=tftpipto[i];
>                                                 for (i=0; i<6; i++)
>                                                         hwaddr[i]=buf->eb_data[6+i];
>                                                 buf = udp_alloc();
>                                                 if (!buf) {
>                                                         res = CFE_ERR_TIMEOUT;
>                                                 break;
>                                         }
>                                         ebuf_append_u16_be(buf, 3);
>                                         ebuf_append_u16_be(buf, 1);
>                                         ebuf_append_bytes(buf,&tftpnull, 0);
>                                         arp_delete(ipaddr);
>                                         arp_add(ipaddr,hwaddr);
>                                         udp_send(info->tftp_socket, buf, tftpipto);
>                                 }
>                         }
>                         res = CFE_ERR_TIMEOUT;
> #else
535a710
> #endif
691a867,869
> #ifdef RESCUE_MODE
>         xprintf("TFTP Server.\n");
> #endif
694a873,875
> #ifdef RESCUE_MODE
>         xprintf("TFTP Client.\n");
> #endif
909a1091,1127
> 
> #ifdef RESCUE_MODE
> extern int send_rescueack(unsigned short no, unsigned short lo)
> {
>         ebuf_t *buf = NULL;
>         int acksocket;
>         char tftpnull;
>         int res, i;
> 
>         /*
>          * Open a UDP socket to the TFTP server
>          */
>         acksocket = udp_socket(UDP_PROTO_TFTP);
>         res = udp_bind(acksocket, 69);
>         if (res < 0) {
>                 return res;
>         }
>         udp_connect(acksocket, ackport);
>         for (i = 0; i < 1; i++) {
>                 buf = udp_alloc();
>                 if (!buf)
>                         return -1;
>                 /*
>                  * Send the data
>                  */
>                 ebuf_append_u16_be(buf, no);
>                 ebuf_append_u16_be(buf, lo);
>                 ebuf_append_bytes(buf,&tftpnull, 0);
>                 udp_send(acksocket ,buf, tftpipto);
>         }
>         if (buf)
>                 udp_free(buf);
>         udp_close(acksocket);
>         return 0;
> }
> #endif
> 
